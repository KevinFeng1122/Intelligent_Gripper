                        .module Gripper_AVR_program.c
                        .area text(rom, con, rel)
 0000                   .dbfile Gripper_AVR_program.c
                        .area data(ram, con, rel)
 0000                   .dbfile Gripper_AVR_program.c
 0000           _Ratio1::
 0000                   .blkb 1
                        .area idata
 0000 01                .byte 1
                        .area data(ram, con, rel)
 0001                   .dbfile Gripper_AVR_program.c
 0001                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0001                   .dbsym e Ratio1 _Ratio1 c
 0001           _Ratio2::
 0001                   .blkb 1
                        .area idata
 0001 02                .byte 2
                        .area data(ram, con, rel)
 0002                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0002                   .dbsym e Ratio2 _Ratio2 c
 0002           _Force::
 0002                   .blkb 1
                        .area idata
 0002 03                .byte 3
                        .area data(ram, con, rel)
 0003                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0003                   .dbsym e Force _Force c
 0003           _no0release::
 0003                   .blkb 2
                        .area idata
 0003 FFFF              .byte 255,255
                        .area data(ram, con, rel)
 0005                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0005                   .blkb 2
                        .area idata
 0005 0005              .byte 0,5
                        .area data(ram, con, rel)
 0007                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0007                   .blkb 2
                        .area idata
 0007 0320              .byte 3,32
                        .area data(ram, con, rel)
 0009                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0009                   .blkb 2
                        .area idata
 0009 FF07              .byte 255,7
                        .area data(ram, con, rel)
 000B                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 000B                   .blkb 1
                        .area idata
 000B D1                .byte 209
                        .area data(ram, con, rel)
 000C                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 000C                   .dbsym e no0release _no0release A[9:9]c
 000C           _no0stop::
 000C                   .blkb 2
                        .area idata
 000C FFFF              .byte 255,255
                        .area data(ram, con, rel)
 000E                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 000E                   .blkb 2
                        .area idata
 000E 0005              .byte 0,5
                        .area data(ram, con, rel)
 0010                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0010                   .blkb 2
                        .area idata
 0010 0320              .byte 3,32
                        .area data(ram, con, rel)
 0012                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0012                   .blkb 2
                        .area idata
 0012 0000              .byte 0,0
                        .area data(ram, con, rel)
 0014                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0014                   .blkb 1
                        .area idata
 0014 D7                .byte 215
                        .area data(ram, con, rel)
 0015                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0015                   .dbsym e no0stop _no0stop A[9:9]c
 0015           _no1release::
 0015                   .blkb 2
                        .area idata
 0015 FFFF              .byte 255,255
                        .area data(ram, con, rel)
 0017                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0017                   .blkb 2
                        .area idata
 0017 0105              .byte 1,5
                        .area data(ram, con, rel)
 0019                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0019                   .blkb 2
                        .area idata
 0019 0320              .byte 3,32
                        .area data(ram, con, rel)
 001B                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 001B                   .blkb 2
                        .area idata
 001B FF07              .byte 255,7
                        .area data(ram, con, rel)
 001D                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 001D                   .blkb 1
                        .area idata
 001D D0                .byte 208
                        .area data(ram, con, rel)
 001E                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 001E                   .dbsym e no1release _no1release A[9:9]c
 001E           _no1stop::
 001E                   .blkb 2
                        .area idata
 001E FFFF              .byte 255,255
                        .area data(ram, con, rel)
 0020                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0020                   .blkb 2
                        .area idata
 0020 0105              .byte 1,5
                        .area data(ram, con, rel)
 0022                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0022                   .blkb 2
                        .area idata
 0022 0320              .byte 3,32
                        .area data(ram, con, rel)
 0024                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0024                   .blkb 2
                        .area idata
 0024 0000              .byte 0,0
                        .area data(ram, con, rel)
 0026                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0026                   .blkb 1
                        .area idata
 0026 D6                .byte 214
                        .area data(ram, con, rel)
 0027                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0027                   .dbsym e no1stop _no1stop A[9:9]c
 0027           _gripper_mood::
 0027                   .blkb 1
                        .area idata
 0027 00                .byte 0
                        .area data(ram, con, rel)
 0028                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0028                   .dbsym e gripper_mood _gripper_mood c
 0028           _uart0_r_instr_chk::
 0028                   .blkb 1
                        .area idata
 0028 00                .byte 0
                        .area data(ram, con, rel)
 0029                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0029                   .dbsym e uart0_r_instr_chk _uart0_r_instr_chk c
 0029           _uart0_instr_flag::
 0029                   .blkb 1
                        .area idata
 0029 00                .byte 0
                        .area data(ram, con, rel)
 002A                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 002A                   .dbsym e uart0_instr_flag _uart0_instr_flag c
 002A           _ext_collision_alert_allow_int0::
 002A                   .blkb 1
                        .area idata
 002A 00                .byte 0
                        .area data(ram, con, rel)
 002B                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 002B                   .dbsym e ext_collision_alert_allow_int0 _ext_collision_alert_allow_int0 c
 002B           _ext_collision_alert_allow_int1::
 002B                   .blkb 1
                        .area idata
 002B 00                .byte 0
                        .area data(ram, con, rel)
 002C                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 002C                   .dbsym e ext_collision_alert_allow_int1 _ext_collision_alert_allow_int1 c
 002C           _ext_collision_alert_allow_int4::
 002C                   .blkb 1
                        .area idata
 002C 00                .byte 0
                        .area data(ram, con, rel)
 002D                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 002D                   .dbsym e ext_collision_alert_allow_int4 _ext_collision_alert_allow_int4 c
                        .area text(rom, con, rel)
 0000                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0000                   .dbfunc e delay _delay fV
 0000           ;              i -> R20,R21
 0000           ;              j -> R22,R23
 0000           ;             ms -> R16,R17
                        .even
 0000           _delay::
 0000 0E940000          xcall push_xgsetF000
 0004                   .dbline -1
 0004                   .dbline 56
 0004           ; //----------【硬件配置说明】↓------------------------------------------------------------
 0004           ; //舵机：波特率19200，电源DC12V，ID：0和1
 0004           ; //电源线和控制线的电平互不干扰
 0004           ; //电源2根，RS485两根
 0004           ; //UART0用于MCU和PC的通信，波特率19200
 0004           ; //UART1用于MCU和舵机的通信，波特率19200
 0004           ; 
 0004           ; //----------【头文件】↓------------------------------------------------------------
 0004           ; #include <iom128v.h>
 0004           ; #include <macros.h>
 0004           ; #include <string.h>
 0004           ; 
 0004           ; //----------【宏定义】↓------------------------------------------------------------
 0004           ; #define  uchar unsigned char
 0004           ; #define  uint  unsigned int
 0004           ; 
 0004           ; #define  mclk   8000000 //时钟频率8.0MHz
 0004           ; 
 0004           ; //----------【常量】↓------------------------------------------------------------
 0004           ; const uchar Ratio1=1;
 0004           ; const uchar Ratio2=2;
 0004           ; const uchar Force=3;
 0004           ; 
 0004           ; 
 0004           ; const uchar no0release[]={0xff,0xff,0x00,0x05,0x03,0x20,0xff,0x07,0xd1};//0号舵机松开（顺时针，力矩100%）
 0004           ; const uchar no0stop[]={0xff,0xff,0x00,0x05,0x03,0x20,0x00,0x00,0xd7}; //0号舵机停止（逆时针，力矩0%）
 0004           ; const uchar no1release[]={0xff,0xff,0x01,0x05,0x03,0x20,0xff,0x07,0xd0};//1号舵机松开（顺时针，力矩100%）
 0004           ; const uchar no1stop[]={0xff,0xff,0x01,0x05,0x03,0x20,0x00,0x00,0xd6}; //1号舵机停止（逆时针，力矩0%）
 0004           ; 
 0004           ; //----------【全局变量定义】↓------------------------------------------------------------
 0004           ; 
 0004           ; uchar gripper_mood=0;//夹持器模式：0-未指定；1-一般工作模式；2-参数配置模式
 0004           ; 
 0004           ; uchar cage0_state,cage1_state;//表明夹持器两端限位情况
 0004           ; 
 0004           ; /*以下变量用于建立上位机指令处理机制*/
 0004           ; uchar uart0_rdata_byte;//UART0每次接收到的单字节信息
 0004           ; uchar uart0_r_instr_chk=0;//uart0接收到的字符串开头中x字符的个数
 0004           ; uchar uart0_instr[5];//存储PC发给MCU的指令，不包含xx，仅包含四位指令代码，最后一位为NULL
 0004           ; uchar uart0_instr_flag=0;//UART0中断接收到开头和长度符合要求的instr时置为1
 0004           ; 
 0004           ; //夹持器与外部碰撞报警（中断）允许变量
 0004           ; uchar ext_collision_alert_allow_int0=0;//上侧
 0004           ; uchar ext_collision_alert_allow_int1=0;//下侧
 0004           ; uchar ext_collision_alert_allow_int4=0;//指尖
 0004           ; 
 0004           ; uchar force_high8;//应变片返回值高8位aa，long型 00 aa bb cc
 0004           ; uchar force_judge;//保存存在EEPROM中的应变片的有效值高八位，用于判断夹紧力是否到达要求
 0004           ; unsigned long force_ulong;//当前应变片测出的数值（占用4 byte，实际有效值3 byte）
 0004           ; 
 0004           ; 
 0004           ; //--------------【软件延时函数】--------------------------------------------------------------------
 0004           ; 
 0004           ; //延时函数，参数为要延时的毫秒数
 0004           ; void delay(uint ms)
 0004           ; {
 0004                   .dbline 58
 0004           ;     uint i,j;
 0004           ;       for(i=0;i<ms;i++)
 0004 4427              clr R20
 0006 5527              clr R21
 0008 0BC0              xjmp L5
 000A           L2:
 000A                   .dbline 59
 000A           ;       {
 000A                   .dbline 60
 000A           ;        for(j=0;j<1141;j++);
 000A 6627              clr R22
 000C 7727              clr R23
 000E 02C0              xjmp L9
 0010           L6:
 0010                   .dbline 60
 0010           L7:
 0010                   .dbline 60
 0010 6F5F              subi R22,255  ; offset = 1
 0012 7F4F              sbci R23,255
 0014           L9:
 0014                   .dbline 60
 0014 6537              cpi R22,117
 0016 E4E0              ldi R30,4
 0018 7E07              cpc R23,R30
 001A D0F3              brlo L6
 001C           X0:
 001C                   .dbline 61
 001C           ;     }
 001C           L3:
 001C                   .dbline 58
 001C 4F5F              subi R20,255  ; offset = 1
 001E 5F4F              sbci R21,255
 0020           L5:
 0020                   .dbline 58
 0020 4017              cp R20,R16
 0022 5107              cpc R21,R17
 0024 90F3              brlo L2
 0026           X1:
 0026                   .dbline -2
 0026           L1:
 0026                   .dbline 0 ; func end
 0026 0C940000          xjmp pop_xgsetF000
 002A                   .dbsym r i 20 i
 002A                   .dbsym r j 22 i
 002A                   .dbsym r ms 16 i
 002A                   .dbend
 002A                   .dbfunc e uart0_init _uart0_init fV
 002A           ;           baud -> R10,R11
                        .even
 002A           _uart0_init::
 002A 0E940000          xcall push_xgsetF00C
 002E 5801              movw R10,R16
 0030                   .dbline -1
 0030                   .dbline 69
 0030           ; }
 0030           ; 
 0030           ; 
 0030           ; //----------【UART0的相关函数】↓---------------------------------------------------------------
 0030           ; 
 0030           ; /*UART0的串口初始化函数*/
 0030           ; void uart0_init(uint baud)
 0030           ; {
 0030                   .dbline 70
 0030           ;    UCSR0B=0x00; 
 0030 2224              clr R2
 0032 2AB8              out 0xa,R2
 0034                   .dbline 71
 0034           ;    UCSR0A=0x00;                  //控制寄存器清零
 0034 2BB8              out 0xb,R2
 0036                   .dbline 72
 0036           ;    UCSR0C=(0<<UPM00)|(3<<UCSZ00); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
 0036 86E0              ldi R24,6
 0038 80939500          sts 149,R24
 003C                   .dbline 74
 003C           ;    
 003C           ;    baud=mclk/16/baud-1;    //波特率最大为65K
 003C 1501              movw R2,R10
 003E 4424              clr R4
 0040 5524              clr R5
 0042 40E2              ldi R20,32
 0044 51EA              ldi R21,161
 0046 67E0              ldi R22,7
 0048 70E0              ldi R23,0
 004A 5A92              st -y,R5
 004C 4A92              st -y,R4
 004E 3A92              st -y,R3
 0050 2A92              st -y,R2
 0052 8A01              movw R16,R20
 0054 9B01              movw R18,R22
 0056 0E940000          xcall div32s
 005A 41E0              ldi R20,1
 005C 50E0              ldi R21,0
 005E 60E0              ldi R22,0
 0060 70E0              ldi R23,0
 0062 1801              movw R2,R16
 0064 2901              movw R4,R18
 0066 241A              sub R2,R20
 0068 350A              sbc R3,R21
 006A 460A              sbc R4,R22
 006C 570A              sbc R5,R23
 006E 5101              movw R10,R2
 0070                   .dbline 75
 0070           ;    UBRR0L=baud;                                                 
 0070 29B8              out 0x9,R2
 0072                   .dbline 76
 0072           ;    UBRR0H=baud>>8;               //设置波特率
 0072 232C              mov R2,R3
 0074 3324              clr R3
 0076 20929000          sts 144,R2
 007A                   .dbline 78
 007A           ; 
 007A           ;    UCSR0B|=(1<<TXEN0);   //UART0发送使能
 007A 539A              sbi 0xa,3
 007C                   .dbline 79
 007C           ;    SREG=BIT(7);                  //全局中断开放
 007C 80E8              ldi R24,128
 007E 8FBF              out 0x3f,R24
 0080                   .dbline 80
 0080           ;    DDRE|=BIT(1);                 //配置TX为输出（很重要），似乎对于MEGA1280来说没用
 0080 119A              sbi 0x2,1
 0082                   .dbline -2
 0082           L10:
 0082                   .dbline 0 ; func end
 0082 0C940000          xjmp pop_xgsetF00C
 0086                   .dbsym r baud 10 i
 0086                   .dbend
 0086                   .dbfunc e uart0_sendB _uart0_sendB fV
 0086           ;           data -> R16
                        .even
 0086           _uart0_sendB::
 0086                   .dbline -1
 0086                   .dbline 85
 0086           ; }
 0086           ; 
 0086           ; /*UART0的串口发送函数，每次发送一个字节（Byte）*/
 0086           ; void uart0_sendB(uchar data)
 0086           ; {
 0086           L12:
 0086                   .dbline 86
 0086           ;    while(!(UCSR0A&(BIT(UDRE0))));//判断准备就绪否
 0086           L13:
 0086                   .dbline 86
 0086 5D9B              sbis 0xb,5
 0088 FECF              rjmp L12
 008A           X2:
 008A                   .dbline 87
 008A           ;    UDR0=data;
 008A 0CB9              out 0xc,R16
 008C           L15:
 008C                   .dbline 88
 008C           ;    while(!(UCSR0A&(BIT(TXC0))));//判断完成发送否
 008C           L16:
 008C                   .dbline 88
 008C 5E9B              sbis 0xb,6
 008E FECF              rjmp L15
 0090           X3:
 0090                   .dbline 89
 0090           ;    UCSR0A|=BIT(TXC0);//TXC0标志位手动清零，通过将TXC0置1实现
 0090 5E9A              sbi 0xb,6
 0092                   .dbline -2
 0092           L11:
 0092                   .dbline 0 ; func end
 0092 0895              ret
 0094                   .dbsym r data 16 c
 0094                   .dbend
                        .area vector(rom, abs)
                        .org 72
 0048 0C944A00          jmp _uart0_rx
                        .area text(rom, con, rel)
 0094                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0094                   .dbfunc e uart0_rx _uart0_rx fV
 0094           ;   uart0_r_byte -> R10
                        .even
 0094           _uart0_rx::
 0094 0A92              st -y,R0
 0096 1A92              st -y,R1
 0098 2A92              st -y,R2
 009A 3A92              st -y,R3
 009C 4A92              st -y,R4
 009E 5A92              st -y,R5
 00A0 6A92              st -y,R6
 00A2 7A92              st -y,R7
 00A4 8A92              st -y,R8
 00A6 9A92              st -y,R9
 00A8 0A93              st -y,R16
 00AA 1A93              st -y,R17
 00AC 2A93              st -y,R18
 00AE 3A93              st -y,R19
 00B0 8A93              st -y,R24
 00B2 9A93              st -y,R25
 00B4 AA93              st -y,R26
 00B6 BA93              st -y,R27
 00B8 EA93              st -y,R30
 00BA FA93              st -y,R31
 00BC 0FB6              IN R0,63
 00BE 0A92              st -y,R0
 00C0 AA92              st -y,R10
 00C2                   .dbline -1
 00C2                   .dbline 96
 00C2           ; }
 00C2           ; 
 00C2           ; #pragma interrupt_handler uart0_rx:19
 00C2           ; 
 00C2           ; /*UART0的串口接收函数，每次接收一个字节（Byte）*/
 00C2           ; void uart0_rx(void)
 00C2           ; {
 00C2                   .dbline 98
 00C2           ;       uchar uart0_r_byte;//UART0每次中断接收到的字符（1byte）
 00C2           ;       UCSR0B&=~BIT(RXCIE0);//关闭RXCIE1，其余位保持不变
 00C2 5798              cbi 0xa,7
 00C4                   .dbline 99
 00C4           ;       uart0_r_byte=UDR0;
 00C4 ACB0              in R10,0xc
 00C6                   .dbline 100
 00C6           ;       if(uart0_instr_make(uart0_r_byte)==0)//通过接受字符串，产生符合要求的instr
 00C6 0A2D              mov R16,R10
 00C8 1127              clr R17
 00CA 1CD0              xcall _uart0_instr_make
 00CC 0030              cpi R16,0
 00CE 0107              cpc R16,R17
 00D0 09F4              brne L19
 00D2           X4:
 00D2                   .dbline 101
 00D2           ;           {UCSR0B|=BIT(RXCIE0);}//使能RXCIE1，其余位保持不变
 00D2                   .dbline 101
 00D2 579A              sbi 0xa,7
 00D4                   .dbline 101
 00D4           L19:
 00D4                   .dbline -2
 00D4           L18:
 00D4                   .dbline 0 ; func end
 00D4 A990              ld R10,y+
 00D6 0990              ld R0,y+
 00D8 0FBE              OUT 63,R0
 00DA F991              ld R31,y+
 00DC E991              ld R30,y+
 00DE B991              ld R27,y+
 00E0 A991              ld R26,y+
 00E2 9991              ld R25,y+
 00E4 8991              ld R24,y+
 00E6 3991              ld R19,y+
 00E8 2991              ld R18,y+
 00EA 1991              ld R17,y+
 00EC 0991              ld R16,y+
 00EE 9990              ld R9,y+
 00F0 8990              ld R8,y+
 00F2 7990              ld R7,y+
 00F4 6990              ld R6,y+
 00F6 5990              ld R5,y+
 00F8 4990              ld R4,y+
 00FA 3990              ld R3,y+
 00FC 2990              ld R2,y+
 00FE 1990              ld R1,y+
 0100 0990              ld R0,y+
 0102 1895              reti
 0104                   .dbsym r uart0_r_byte 10 c
 0104                   .dbend
 0104                   .dbfunc e uart0_instr_make _uart0_instr_make fc
 0104           ;      instr_num -> R10
 0104           ;        fun_ret -> R20
 0104           ;         r_byte -> R22
                        .even
 0104           _uart0_instr_make::
 0104 0E940000          xcall push_xgsetF00C
 0108 602F              mov R22,R16
 010A                   .dbline -1
 010A                   .dbline 106
 010A           ; }
 010A           ; 
 010A           ; //UART0的指令识别函数，从接收到的字符中提取出以xx开头的指令字符串
 010A           ; uchar uart0_instr_make(uchar r_byte)
 010A           ; {
 010A                   .dbline 109
 010A           ;     uchar instr_num;//instr中已有的字符数
 010A           ;       uchar fun_ret;//存储本函数返回值 
 010A           ;     switch(uart0_r_instr_chk)//根据已有x的个数进行操作
 010A A0902800          lds R10,_uart0_r_instr_chk
 010E BB24              clr R11
 0110 AA20              tst R10
 0112 11F4              brne X5
 0114 BB20              tst R11
 0116 51F0              breq L25
 0118           X5:
 0118 C501              movw R24,R10
 011A 8130              cpi R24,1
 011C E0E0              ldi R30,0
 011E 9E07              cpc R25,R30
 0120 61F0              breq L28
 0122           X6:
 0122 8230              cpi R24,2
 0124 E0E0              ldi R30,0
 0126 9E07              cpc R25,R30
 0128 99F0              breq L31
 012A           X7:
 012A 2DC0              xjmp L23
 012C           L25:
 012C                   .dbline 112
 012C           ;       {
 012C           ;           case 0:
 012C           ;                        {
 012C                   .dbline 113
 012C           ;                        if(r_byte=='x')
 012C 6837              cpi R22,120
 012E 19F4              brne L26
 0130           X8:
 0130                   .dbline 114
 0130           ;                            {                           
 0130                   .dbline 115
 0130           ;                                uart0_r_instr_chk=1;
 0130 81E0              ldi R24,1
 0132 80932800          sts _uart0_r_instr_chk,R24
 0136                   .dbline 116
 0136           ;                                }
 0136           L26:
 0136                   .dbline 117
 0136           ;                        fun_ret=0;
 0136 4427              clr R20
 0138                   .dbline 118
 0138           ;                        break;
 0138 26C0              xjmp L23
 013A           L28:
 013A                   .dbline 121
 013A           ;                        }
 013A           ;               case 1:
 013A           ;                        {
 013A                   .dbline 122
 013A           ;                        if(r_byte=='x')
 013A 6837              cpi R22,120
 013C 21F4              brne L29
 013E           X9:
 013E                   .dbline 123
 013E           ;                            {uart0_r_instr_chk=2;}
 013E                   .dbline 123
 013E 82E0              ldi R24,2
 0140 80932800          sts _uart0_r_instr_chk,R24
 0144                   .dbline 123
 0144 03C0              xjmp L30
 0146           L29:
 0146                   .dbline 125
 0146           ;                        else
 0146           ;                                {uart0_r_instr_chk=0;}
 0146                   .dbline 125
 0146 2224              clr R2
 0148 20922800          sts _uart0_r_instr_chk,R2
 014C                   .dbline 125
 014C           L30:
 014C                   .dbline 126
 014C           ;                        fun_ret=0;
 014C 4427              clr R20
 014E                   .dbline 127
 014E           ;                        break;
 014E 1BC0              xjmp L23
 0150           L31:
 0150                   .dbline 130
 0150           ;                        }
 0150           ;               case 2:
 0150           ;                        {
 0150                   .dbline 131
 0150           ;                        instr_num=strlen(uart0_instr);
 0150 00E0              ldi R16,<_uart0_instr
 0152 10E0              ldi R17,>_uart0_instr
 0154 0E940000          xcall _strlen
 0158 A02E              mov R10,R16
 015A                   .dbline 132
 015A           ;                        if(instr_num==3)
 015A 0330              cpi R16,3
 015C 61F4              brne L32
 015E           X10:
 015E                   .dbline 133
 015E           ;                        {
 015E                   .dbline 134
 015E           ;                            uart0_instr[instr_num]=r_byte;
 015E 80E0              ldi R24,<_uart0_instr
 0160 90E0              ldi R25,>_uart0_instr
 0162 EA2D              mov R30,R10
 0164 FF27              clr R31
 0166 E80F              add R30,R24
 0168 F91F              adc R31,R25
 016A 6083              std z+0,R22
 016C                   .dbline 135
 016C           ;                                uart0_instr_flag=1;//instr已经满足开头xx和长度要求，flag置1，进行命令处理
 016C 81E0              ldi R24,1
 016E 80932900          sts _uart0_instr_flag,R24
 0172                   .dbline 136
 0172           ;                            fun_ret=1;                          
 0172 41E0              ldi R20,1
 0174                   .dbline 137
 0174           ;                        }
 0174 08C0              xjmp L23
 0176           L32:
 0176                   .dbline 139
 0176           ;                        else
 0176           ;                        {
 0176                   .dbline 140
 0176           ;                            uart0_instr[instr_num]=r_byte;
 0176 80E0              ldi R24,<_uart0_instr
 0178 90E0              ldi R25,>_uart0_instr
 017A EA2D              mov R30,R10
 017C FF27              clr R31
 017E E80F              add R30,R24
 0180 F91F              adc R31,R25
 0182 6083              std z+0,R22
 0184                   .dbline 141
 0184           ;                                fun_ret=0;
 0184 4427              clr R20
 0186                   .dbline 142
 0186           ;                        }
 0186                   .dbline 143
 0186           ;                        break;
 0186                   .dbline 145
 0186           ;                        }
 0186           ;               default:break;
 0186           L23:
 0186                   .dbline 147
 0186           ;       }
 0186           ;       return fun_ret;
 0186 042F              mov R16,R20
 0188                   .dbline -2
 0188           L21:
 0188                   .dbline 0 ; func end
 0188 0C940000          xjmp pop_xgsetF00C
 018C                   .dbsym r instr_num 10 c
 018C                   .dbsym r fun_ret 20 c
 018C                   .dbsym r r_byte 22 c
 018C                   .dbend
 018C                   .dbfunc e uart0_send_string _uart0_send_string fV
 018C           ;   str_send_num -> R14
 018C           ;              i -> R10
 018C           ;       str_send -> R12,R13
                        .even
 018C           _uart0_send_string::
 018C 0E940000          xcall push_xgset00FC
 0190 6801              movw R12,R16
 0192                   .dbline -1
 0192                   .dbline 152
 0192           ; }
 0192           ; 
 0192           ; /*UART0字符串发送函数*/
 0192           ; void uart0_send_string(uchar *str_send)//形参：待发送字符串
 0192           ; {
 0192                   .dbline 153
 0192           ;        uchar str_send_num=strlen(str_send);//待发送字符串包含的字符数，
 0192 8601              movw R16,R12
 0194 0E940000          xcall _strlen
 0198 E02E              mov R14,R16
 019A                   .dbline 155
 019A           ;                                                                               //数组str_send最后一位值为NULL
 019A           ;        uchar i=0;
 019A AA24              clr R10
 019C 07C0              xjmp L36
 019E           L35:
 019E                   .dbline 157
 019E           ;        while(i<str_send_num)
 019E           ;        {
 019E                   .dbline 158
 019E           ;          uart0_sendB(*(str_send+i));
 019E EA2D              mov R30,R10
 01A0 FF27              clr R31
 01A2 EC0D              add R30,R12
 01A4 FD1D              adc R31,R13
 01A6 0081              ldd R16,z+0
 01A8 6EDF              xcall _uart0_sendB
 01AA                   .dbline 159
 01AA           ;          i+=1;
 01AA A394              inc R10
 01AC                   .dbline 160
 01AC           ;        }
 01AC           L36:
 01AC                   .dbline 156
 01AC AE14              cp R10,R14
 01AE B8F3              brlo L35
 01B0           X11:
 01B0                   .dbline -2
 01B0           L34:
 01B0                   .dbline 0 ; func end
 01B0 0C940000          xjmp pop_xgset00FC
 01B4                   .dbsym r str_send_num 14 c
 01B4                   .dbsym r i 10 c
 01B4                   .dbsym r str_send 12 pc
 01B4                   .dbend
 01B4                   .dbfunc e uart0_send_string_with_num _uart0_send_string_with_num fV
 01B4           ;              i -> R10
 01B4           ;       char_num -> R12
 01B4           ;       str_send -> R14,R15
                        .even
 01B4           _uart0_send_string_with_num::
 01B4 0E940000          xcall push_xgset00FC
 01B8 C22E              mov R12,R18
 01BA 7801              movw R14,R16
 01BC                   .dbline -1
 01BC                   .dbline 164
 01BC           ; }
 01BC           ; 
 01BC           ; void uart0_send_string_with_num(uchar *str_send,uchar char_num)//形参：待发送字符串，字符串字符数
 01BC           ; {
 01BC                   .dbline 165
 01BC           ;        uchar i=0;
 01BC AA24              clr R10
 01BE 07C0              xjmp L40
 01C0           L39:
 01C0                   .dbline 167
 01C0           ;        while(i<char_num)
 01C0           ;        {
 01C0                   .dbline 168
 01C0           ;          uart0_sendB(*(str_send+i));
 01C0 EA2D              mov R30,R10
 01C2 FF27              clr R31
 01C4 EE0D              add R30,R14
 01C6 FF1D              adc R31,R15
 01C8 0081              ldd R16,z+0
 01CA 5DDF              xcall _uart0_sendB
 01CC                   .dbline 169
 01CC           ;          i+=1;
 01CC A394              inc R10
 01CE                   .dbline 170
 01CE           ;        }
 01CE           L40:
 01CE                   .dbline 166
 01CE AC14              cp R10,R12
 01D0 B8F3              brlo L39
 01D2           X12:
 01D2                   .dbline -2
 01D2           L38:
 01D2                   .dbline 0 ; func end
 01D2 0C940000          xjmp pop_xgset00FC
 01D6                   .dbsym r i 10 c
 01D6                   .dbsym r char_num 12 c
 01D6                   .dbsym r str_send 14 pc
 01D6                   .dbend
 01D6                   .dbfunc e uart1_init _uart1_init fV
 01D6           ;           baud -> R10,R11
                        .even
 01D6           _uart1_init::
 01D6 0E940000          xcall push_xgsetF00C
 01DA 5801              movw R10,R16
 01DC                   .dbline -1
 01DC                   .dbline 177
 01DC           ; }
 01DC           ; 
 01DC           ; //------------【UART1的相关函数】↓-------------------------------------------------------------
 01DC           ; 
 01DC           ; /*UART1的串口初始化函数*/
 01DC           ; void uart1_init(uint baud)
 01DC           ; {
 01DC                   .dbline 178
 01DC           ;     UCSR1B=0x00; 
 01DC 2224              clr R2
 01DE 20929A00          sts 154,R2
 01E2                   .dbline 179
 01E2           ;     UCSR1A=0x00;                 //控制寄存器清零
 01E2 20929B00          sts 155,R2
 01E6                   .dbline 180
 01E6           ;     UCSR1C=(0<<UPM10)|(3<<UCSZ10); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
 01E6 86E0              ldi R24,6
 01E8 80939D00          sts 157,R24
 01EC                   .dbline 182
 01EC           ;    
 01EC           ;     baud=mclk/16/baud-1;    //波特率最大为65K
 01EC 1501              movw R2,R10
 01EE 4424              clr R4
 01F0 5524              clr R5
 01F2 40E2              ldi R20,32
 01F4 51EA              ldi R21,161
 01F6 67E0              ldi R22,7
 01F8 70E0              ldi R23,0
 01FA 5A92              st -y,R5
 01FC 4A92              st -y,R4
 01FE 3A92              st -y,R3
 0200 2A92              st -y,R2
 0202 8A01              movw R16,R20
 0204 9B01              movw R18,R22
 0206 0E940000          xcall div32s
 020A 41E0              ldi R20,1
 020C 50E0              ldi R21,0
 020E 60E0              ldi R22,0
 0210 70E0              ldi R23,0
 0212 1801              movw R2,R16
 0214 2901              movw R4,R18
 0216 241A              sub R2,R20
 0218 350A              sbc R3,R21
 021A 460A              sbc R4,R22
 021C 570A              sbc R5,R23
 021E 5101              movw R10,R2
 0220                   .dbline 183
 0220           ;     UBRR1L=baud;                                                
 0220 A0929900          sts 153,R10
 0224                   .dbline 184
 0224           ;     UBRR1H=baud>>8;              //设置波特率
 0224 232C              mov R2,R3
 0226 3324              clr R3
 0228 20929800          sts 152,R2
 022C                   .dbline 186
 022C           ;    
 022C           ;     UCSR1B|=(1<<TXEN1)|(1<<RXEN1)|(1<<RXCIE1);   //接收、发送使能，接收中断使能
 022C 80919A00          lds R24,154
 0230 8869              ori R24,152
 0232 80939A00          sts 154,R24
 0236                   .dbline 187
 0236           ;     SREG=BIT(7);                 //全局中断开放
 0236 80E8              ldi R24,128
 0238 8FBF              out 0x3f,R24
 023A                   .dbline 188
 023A           ;     DDRD|=BIT(3);                //配置TX为输出（很重要），似乎对于MEGA1280来说没用
 023A 8B9A              sbi 0x11,3
 023C                   .dbline 192
 023C           ;    
 023C           ;       //RS485芯片设置为发送，DE=PD5=1
 023C           ;       //注意！该芯片为半双工通信，不可同时收和发，配置引脚时应注意这一点
 023C           ;     DDRD|=BIT(5);
 023C 8D9A              sbi 0x11,5
 023E                   .dbline 193
 023E           ;     PORTD|=BIT(5);
 023E 959A              sbi 0x12,5
 0240                   .dbline 195
 0240           ; 
 0240           ;       DDRD|=BIT(4);
 0240 8C9A              sbi 0x11,4
 0242                   .dbline 196
 0242           ;     PORTD|=BIT(4);
 0242 949A              sbi 0x12,4
 0244                   .dbline -2
 0244           L42:
 0244                   .dbline 0 ; func end
 0244 0C940000          xjmp pop_xgsetF00C
 0248                   .dbsym r baud 10 i
 0248                   .dbend
 0248                   .dbfunc e uart1_sendB _uart1_sendB fV
 0248           ;           data -> R16
                        .even
 0248           _uart1_sendB::
 0248                   .dbline -1
 0248                   .dbline 202
 0248           ; }
 0248           ; 
 0248           ; 
 0248           ; /*UART1的串口发送函数，每次发送一个字节（Byte）*/
 0248           ; void uart1_sendB(uchar data)
 0248           ; {
 0248           L44:
 0248                   .dbline 203
 0248           ;    while(!(UCSR1A&(BIT(UDRE1))));//判断准备就绪否
 0248           L45:
 0248                   .dbline 203
 0248 20909B00          lds R2,155
 024C 25FE              sbrs R2,5
 024E FCCF              rjmp L44
 0250           X13:
 0250                   .dbline 204
 0250           ;    UDR1=data;
 0250 00939C00          sts 156,R16
 0254           L47:
 0254                   .dbline 205
 0254           ;    while(!(UCSR1A&(BIT(TXC1))));//判断完成发送否
 0254           L48:
 0254                   .dbline 205
 0254 20909B00          lds R2,155
 0258 26FE              sbrs R2,6
 025A FCCF              rjmp L47
 025C           X14:
 025C                   .dbline 206
 025C           ;    UCSR1A|=BIT(TXC1);//TXC1标志位手动清零，通过将TXC1置1实现
 025C 80919B00          lds R24,155
 0260 8064              ori R24,64
 0262 80939B00          sts 155,R24
 0266                   .dbline -2
 0266           L43:
 0266                   .dbline 0 ; func end
 0266 0895              ret
 0268                   .dbsym r data 16 c
 0268                   .dbend
 0268                   .dbfunc e uart1_send_string _uart1_send_string fV
 0268           ;              i -> R10
 0268           ;        str_num -> R12
 0268           ;       str_send -> R14,R15
                        .even
 0268           _uart1_send_string::
 0268 0E940000          xcall push_xgset00FC
 026C C22E              mov R12,R18
 026E 7801              movw R14,R16
 0270                   .dbline -1
 0270                   .dbline 211
 0270           ; }
 0270           ; 
 0270           ; /*UART1字符串发送函数*/
 0270           ; void uart1_send_string(uchar *str_send,uchar str_num)//形参：待发送字符串
 0270           ; {
 0270                   .dbline 212
 0270           ;        uchar i=0;
 0270 AA24              clr R10
 0272 07C0              xjmp L52
 0274           L51:
 0274                   .dbline 214
 0274           ;        while(i<str_num)
 0274           ;        {
 0274                   .dbline 215
 0274           ;          uart1_sendB(*(str_send+i));
 0274 EA2D              mov R30,R10
 0276 FF27              clr R31
 0278 EE0D              add R30,R14
 027A FF1D              adc R31,R15
 027C 0081              ldd R16,z+0
 027E E4DF              xcall _uart1_sendB
 0280                   .dbline 216
 0280           ;          i+=1;
 0280 A394              inc R10
 0282                   .dbline 218
 0282           ;          //delay(10);
 0282           ;        }
 0282           L52:
 0282                   .dbline 213
 0282 AC14              cp R10,R12
 0284 B8F3              brlo L51
 0286           X15:
 0286                   .dbline -2
 0286           L50:
 0286                   .dbline 0 ; func end
 0286 0C940000          xjmp pop_xgset00FC
 028A                   .dbsym r i 10 c
 028A                   .dbsym r str_num 12 c
 028A                   .dbsym r str_send 14 pc
 028A                   .dbend
 028A                   .dbfunc e array_copy _array_copy fV
 028A           ;              i -> R10
 028A           ;       copy_num -> R12
 028A           ;         array2 -> R14,R15
 028A           ;    start_index -> R18
 028A           ;         array1 -> R16,R17
                        .even
 028A           _array_copy::
 028A 0E940000          xcall push_xgset00FC
 028E EE80              ldd R14,y+6
 0290 FF80              ldd R15,y+7
 0292 C884              ldd R12,y+8
 0294                   .dbline -1
 0294                   .dbline 240
 0294           ; }
 0294           ; 
 0294           ; //#pragma interrupt_handler uart1_rx:31
 0294           ; 
 0294           ; /*
 0294           ; void uart1_rx(void)
 0294           ; {     
 0294           ;     UCSR1B&=~BIT(RXCIE1);
 0294           ;       //rdata=UDR1;
 0294           ;       //flag=1;
 0294           ;       UCSR1B|=BIT(RXCIE1);
 0294           ; }
 0294           ; */
 0294           ; 
 0294           ; 
 0294           ; //------------------【字符串处理函数】↓-------------------------------------------------------
 0294           ; 
 0294           ; //数组元素拷贝函数
 0294           ; void array_copy(uchar *array1,uchar start_index,uchar *array2,uchar copy_num)
 0294           ; //将array1中自第start_index位起的copy_num个元素拷贝到array2的第0到copy_num-1位
 0294           ; //array1的元素数目不应小于start_index+copy_num+1个，array2的元素数目不应小于copy_num个
 0294           ; {
 0294                   .dbline 242
 0294           ;     uchar i;
 0294           ;       for(i=0;i<copy_num;i++)
 0294 AA24              clr R10
 0296 0FC0              xjmp L58
 0298           L55:
 0298                   .dbline 243
 0298           ;       {
 0298                   .dbline 244
 0298           ;           array2[i]=array1[start_index+i];
 0298 2A2C              mov R2,R10
 029A 3324              clr R3
 029C E22F              mov R30,R18
 029E FF27              clr R31
 02A0 E20D              add R30,R2
 02A2 F31D              adc R31,R3
 02A4 E00F              add R30,R16
 02A6 F11F              adc R31,R17
 02A8 2080              ldd R2,z+0
 02AA EA2D              mov R30,R10
 02AC FF27              clr R31
 02AE EE0D              add R30,R14
 02B0 FF1D              adc R31,R15
 02B2 2082              std z+0,R2
 02B4                   .dbline 245
 02B4           ;       }
 02B4           L56:
 02B4                   .dbline 242
 02B4 A394              inc R10
 02B6           L58:
 02B6                   .dbline 242
 02B6 AC14              cp R10,R12
 02B8 78F3              brlo L55
 02BA           X16:
 02BA                   .dbline -2
 02BA           L54:
 02BA                   .dbline 0 ; func end
 02BA 0C940000          xjmp pop_xgset00FC
 02BE                   .dbsym r i 10 c
 02BE                   .dbsym r copy_num 12 c
 02BE                   .dbsym r array2 14 pc
 02BE                   .dbsym r start_index 18 c
 02BE                   .dbsym r array1 16 pc
 02BE                   .dbend
 02BE                   .dbfunc e array_cmp _array_cmp fI
 02BE           ;              i -> R20,R21
 02BE           ;           str1 -> R18,R19
 02BE           ;           str0 -> R16,R17
                        .even
 02BE           _array_cmp::
 02BE 4A93              st -y,R20
 02C0 5A93              st -y,R21
 02C2                   .dbline -1
 02C2                   .dbline 251
 02C2           ; }
 02C2           ; 
 02C2           ; //字符数组或字符串比较函数：若返回0，则表示相等，否则不等
 02C2           ; //*str0或*str1可以使数组(例如array_eg[])，也可以是字符串常量(例如"abcd")
 02C2           ; int array_cmp(char * str0, char * str1)
 02C2           ; {
 02C2                   .dbline 253
 02C2           ;     int i;
 02C2           ;     for(i=0;str0[i]!=0 && str1[i]!=0 && str0[i]==str1[i];i++);
 02C2 4427              clr R20
 02C4 5527              clr R21
 02C6 02C0              xjmp L63
 02C8           L60:
 02C8                   .dbline 253
 02C8           L61:
 02C8                   .dbline 253
 02C8 4F5F              subi R20,255  ; offset = 1
 02CA 5F4F              sbci R21,255
 02CC           L63:
 02CC                   .dbline 253
 02CC FA01              movw R30,R20
 02CE E00F              add R30,R16
 02D0 F11F              adc R31,R17
 02D2 2080              ldd R2,z+0
 02D4 3324              clr R3
 02D6 2101              movw R4,R2
 02D8 2220              tst R2
 02DA 69F0              breq L65
 02DC           X17:
 02DC FA01              movw R30,R20
 02DE E20F              add R30,R18
 02E0 F31F              adc R31,R19
 02E2 2080              ldd R2,z+0
 02E4 3324              clr R3
 02E6 3101              movw R6,R2
 02E8 2220              tst R2
 02EA 29F0              breq L65
 02EC           X18:
 02EC 242C              mov R2,R4
 02EE 3324              clr R3
 02F0 2614              cp R2,R6
 02F2 3704              cpc R3,R7
 02F4 49F3              breq L60
 02F6           X19:
 02F6           L65:
 02F6                   .dbline 254
 02F6           ;     return str0[i]-str1[i];
 02F6 FA01              movw R30,R20
 02F8 E20F              add R30,R18
 02FA F31F              adc R31,R19
 02FC 2080              ldd R2,z+0
 02FE 3324              clr R3
 0300 FA01              movw R30,R20
 0302 E00F              add R30,R16
 0304 F11F              adc R31,R17
 0306 0081              ldd R16,z+0
 0308 1127              clr R17
 030A 0219              sub R16,R2
 030C 1309              sbc R17,R3
 030E                   .dbline -2
 030E           L59:
 030E                   .dbline 0 ; func end
 030E 5991              ld R21,y+
 0310 4991              ld R20,y+
 0312 0895              ret
 0314                   .dbsym r i 20 I
 0314                   .dbsym r str1 18 pc
 0314                   .dbsym r str0 16 pc
 0314                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0000           L67:
 0000                   .blkb 3
                        .area text(rom, con, rel)
 0314                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0314                   .dbfunc e Type _Type fpc
 0314                   .dbsym s type_name L67 A[3:3]c
 0314           ;    Instruction -> R16,R17
                        .even
 0314           _Type::
 0314                   .dbline -1
 0314                   .dbline 258
 0314           ; }
 0314           ; 
 0314           ; uchar* Type(uchar* Instruction)
 0314           ; {
 0314                   .dbline 260
 0314           ;     static uchar type_name[3];//static关键词很重要！否则子程序调用完成后，数组内容消失
 0314           ;       type_name[0]=Instruction[0];
 0314 F801              movw R30,R16
 0316 2080              ldd R2,z+0
 0318 20920000          sts L67,R2
 031C                   .dbline 261
 031C           ;       type_name[1]=Instruction[1];
 031C 2180              ldd R2,z+1
 031E 20920100          sts L67+1,R2
 0322                   .dbline 262
 0322           ;       type_name[2]=0;
 0322 2224              clr R2
 0324 20920200          sts L67+2,R2
 0328                   .dbline 263
 0328           ;       return type_name;
 0328 00E0              ldi R16,<L67
 032A 10E0              ldi R17,>L67
 032C                   .dbline -2
 032C           L66:
 032C                   .dbline 0 ; func end
 032C 0895              ret
 032E                   .dbsym r Instruction 16 pc
 032E                   .dbend
 032E                   .dbfunc e force_data_init _force_data_init fV
                        .even
 032E           _force_data_init::
 032E                   .dbline -1
 032E                   .dbline 270
 032E           ; }
 032E           ; 
 032E           ; //----------------【应变片相关函数】↓--------------------------------
 032E           ; 
 032E           ; //应变片读取配置
 032E           ; void force_data_init(void)
 032E           ; {
 032E                   .dbline 273
 032E           ;       /*A0-DT ADDO：单片机从DT读取数据;A1-SCK ADSK：单片机输出高低电平到SCK*/
 032E           ;       //PA0配置成高阻态输入
 032E           ;       DDRA&=(~BIT(0));//DDRA0=0
 032E D098              cbi 0x1a,0
 0330                   .dbline 274
 0330           ;       PORTA&=(~BIT(0));//PORTA0=0
 0330 D898              cbi 0x1b,0
 0332                   .dbline 277
 0332           ; 
 0332           ;       //PA1配置成输出
 0332           ;       DDRA|=BIT(1);//DDRA1=1
 0332 D19A              sbi 0x1a,1
 0334                   .dbline -2
 0334           L70:
 0334                   .dbline 0 ; func end
 0334 0895              ret
 0336                   .dbend
 0336                   .dbfunc e ulong_to_uchar_array _ulong_to_uchar_array fpc
 0336           ;           pNum -> R22,R23
 0336           ;     force_data -> y+0
 0336           ;       data_num -> y+9
                        .even
 0336           _ulong_to_uchar_array::
 0336 0E940000          xcall push_arg4
 033A 0E940000          xcall push_xgsetF000
 033E 2597              sbiw R28,5
 0340                   .dbline -1
 0340                   .dbline 282
 0340           ; }
 0340           ; 
 0340           ; //unsigned long型数字转成字符串，用于将应变片采集回的数据上传
 0340           ; uchar* ulong_to_uchar_array(unsigned long data_num)
 0340           ; {
 0340                   .dbline 286
 0340           ;       //long型在内存中的存储 0x12345678 →低地址78+56+34+12高地址
 0340           ;       uchar* pNum;
 0340           ;       uchar force_data[5];
 0340           ;       pNum=(uchar *)&data_num;
 0340 BE01              movw R22,R28
 0342 675F              subi R22,247  ; offset = 9
 0344 7F4F              sbci R23,255
 0346                   .dbline 287
 0346           ;       force_data[3]=*pNum;
 0346 FB01              movw R30,R22
 0348 2080              ldd R2,z+0
 034A 2B82              std y+3,R2
 034C                   .dbline 288
 034C           ;       force_data[2]=*(++pNum);
 034C CF01              movw R24,R30
 034E 0196              adiw R24,1
 0350 FC01              movw R30,R24
 0352 2080              ldd R2,z+0
 0354 2A82              std y+2,R2
 0356                   .dbline 289
 0356           ;       force_data[1]=*(++pNum);
 0356 0196              adiw R24,1
 0358 FC01              movw R30,R24
 035A 2080              ldd R2,z+0
 035C 2982              std y+1,R2
 035E                   .dbline 290
 035E           ;       force_data[0]=*(++pNum);
 035E AC01              movw R20,R24
 0360 4F5F              subi R20,255  ; offset = 1
 0362 5F4F              sbci R21,255
 0364 BA01              movw R22,R20
 0366 FA01              movw R30,R20
 0368 2080              ldd R2,z+0
 036A 2882              std y+0,R2
 036C                   .dbline 291
 036C           ;       force_data[4]=0;
 036C 2224              clr R2
 036E 2C82              std y+4,R2
 0370                   .dbline 292
 0370           ;       force_high8=0x7f-force_data[1];//有效值高八位存入全局变量中
 0370 2980              ldd R2,y+1
 0372 8FE7              ldi R24,127
 0374 8219              sub R24,R2
 0376 80930800          sts _force_high8,R24
 037A                   .dbline 295
 037A           ;       //注意根据应变片情况调整force_high8的值，即是否用0x7f减去有效值高八位
 037A           ;       
 037A           ;       return force_data;
 037A 8E01              movw R16,R28
 037C                   .dbline -2
 037C           L71:
 037C                   .dbline 0 ; func end
 037C 2596              adiw R28,5
 037E 0E940000          xcall pop_xgsetF000
 0382 2496              adiw R28,4
 0384 0895              ret
 0386                   .dbsym r pNum 22 pc
 0386                   .dbsym l force_data 0 A[5:5]c
 0386                   .dbsym l data_num 9 l
 0386                   .dbend
 0386                   .dbfunc e ReadCount _ReadCount fl
 0386           ;      ptr_count -> <dead>
 0386           ;              i -> R16
 0386           ;          Count -> y+0
                        .even
 0386           _ReadCount::
 0386 2497              sbiw R28,4
 0388                   .dbline -1
 0388                   .dbline 300
 0388           ; }
 0388           ; 
 0388           ; //应变采集模块数据读取程序，参照卖方示例编写
 0388           ; unsigned long ReadCount(void)
 0388           ; {
 0388                   .dbline 304
 0388           ;     unsigned long Count;
 0388           ;     unsigned char i;
 0388           ;       uchar* ptr_count;
 0388           ;       PORTA&=(~BIT(1));//ADSK=PORTA1=0
 0388 D998              cbi 0x1b,1
 038A                   .dbline 305
 038A           ;     Count=0;
 038A 80E0              ldi R24,0
 038C 8883              std y+0,R24
 038E 8983              std y+1,R24
 0390 8A83              std y+2,R24
 0392 8B83              std y+3,R24
 0394           L78:
 0394                   .dbline 306
 0394           ;     while(PINA&BIT(0));//读取PINA0=ADDO
 0394           L79:
 0394                   .dbline 306
 0394 C899              sbic 0x19,0
 0396 FECF              rjmp L78
 0398           X20:
 0398                   .dbline 307
 0398           ;     for(i=0;i<24;i++)
 0398 0027              clr R16
 039A 21C0              xjmp L84
 039C           L81:
 039C                   .dbline 308
 039C           ;     {
 039C                   .dbline 309
 039C           ;         PORTA|=BIT(1);//ADSK=PORTA1=1
 039C D99A              sbi 0x1b,1
 039E                   .dbline 310
 039E           ;         Count=Count<<1;
 039E 2880              ldd R2,y+0
 03A0 3980              ldd R3,y+1
 03A2 4A80              ldd R4,y+2
 03A4 5B80              ldd R5,y+3
 03A6 220C              lsl R2
 03A8 331C              rol R3
 03AA 441C              rol R4
 03AC 551C              rol R5
 03AE 2882              std y+0,R2
 03B0 3982              std y+1,R3
 03B2 4A82              std y+2,R4
 03B4 5B82              std y+3,R5
 03B6                   .dbline 311
 03B6           ;         PORTA&=(~BIT(1));//ADSK=PORTA1=0
 03B6 D998              cbi 0x1b,1
 03B8                   .dbline 312
 03B8           ;         if(PINA&BIT(0)) Count++;
 03B8 C89B              sbis 0x19,0
 03BA 10C0              rjmp L85
 03BC           X21:
 03BC                   .dbline 312
 03BC 81E0              ldi R24,1
 03BE 90E0              ldi R25,0
 03C0 A0E0              ldi R26,0
 03C2 B0E0              ldi R27,0
 03C4 2880              ldd R2,y+0
 03C6 3980              ldd R3,y+1
 03C8 4A80              ldd R4,y+2
 03CA 5B80              ldd R5,y+3
 03CC 280E              add R2,R24
 03CE 391E              adc R3,R25
 03D0 4A1E              adc R4,R26
 03D2 5B1E              adc R5,R27
 03D4 2882              std y+0,R2
 03D6 3982              std y+1,R3
 03D8 4A82              std y+2,R4
 03DA 5B82              std y+3,R5
 03DC           L85:
 03DC                   .dbline 313
 03DC           ;     }
 03DC           L82:
 03DC                   .dbline 307
 03DC 0395              inc R16
 03DE           L84:
 03DE                   .dbline 307
 03DE 0831              cpi R16,24
 03E0 E8F2              brlo L81
 03E2           X22:
 03E2                   .dbline 314
 03E2           ;     PORTA|=BIT(1);//ADSK=PORTA1=1
 03E2 D99A              sbi 0x1b,1
 03E4                   .dbline 315
 03E4           ;     Count=Count^0x800000;
 03E4 80E0              ldi R24,0
 03E6 90E0              ldi R25,0
 03E8 A0E8              ldi R26,128
 03EA B0E0              ldi R27,0
 03EC 2880              ldd R2,y+0
 03EE 3980              ldd R3,y+1
 03F0 4A80              ldd R4,y+2
 03F2 5B80              ldd R5,y+3
 03F4 2826              eor R2,R24
 03F6 3926              eor R3,R25
 03F8 4A26              eor R4,R26
 03FA 5B26              eor R5,R27
 03FC 2882              std y+0,R2
 03FE 3982              std y+1,R3
 0400 4A82              std y+2,R4
 0402 5B82              std y+3,R5
 0404                   .dbline 316
 0404           ;     PORTA&=(~BIT(1));//ADSK=PORTA1=0
 0404 D998              cbi 0x1b,1
 0406                   .dbline 317
 0406           ;     return(Count);
 0406 0881              ldd R16,y+0
 0408 1981              ldd R17,y+1
 040A 2A81              ldd R18,y+2
 040C 3B81              ldd R19,y+3
 040E                   .dbline -2
 040E           L77:
 040E                   .dbline 0 ; func end
 040E 2496              adiw R28,4
 0410 0895              ret
 0412                   .dbsym l ptr_count 1 pc
 0412                   .dbsym r i 16 c
 0412                   .dbsym l Count 0 l
 0412                   .dbend
 0412                   .dbfunc e command_data_save_force_high8 _command_data_save_force_high8 fV
 0412           ;     force_save -> R16,R17
                        .even
 0412           _command_data_save_force_high8::
 0412                   .dbline -1
 0412                   .dbline 322
 0412           ; }
 0412           ; 
 0412           ; //保存应变片数据有效值的高八位
 0412           ; void command_data_save_force_high8(force_save)
 0412           ; {
 0412                   .dbline 323
 0412           ;     SREG &=(~BIT(3));//关闭全局中断
 0412 B894              bclr 3
 0414           L88:
 0414                   .dbline 325
 0414           ;       
 0414           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 0414           L89:
 0414                   .dbline 325
 0414 E199              sbic 0x1c,1
 0416 FECF              rjmp L88
 0418           X23:
 0418                   .dbline 326
 0418           ;       EEAR=0x0030;//写地址
 0418 80E3              ldi R24,48
 041A 90E0              ldi R25,0
 041C 9FBB              out 0x1f,R25
 041E 8EBB              out 0x1e,R24
 0420                   .dbline 327
 0420           ;       EEDR=force_save;//写数据
 0420 0DBB              out 0x1d,R16
 0422                   .dbline 328
 0422           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0422 E29A              sbi 0x1c,2
 0424                   .dbline 329
 0424           ;       EECR&=(~BIT(EEWE));//EEWE置0
 0424 E198              cbi 0x1c,1
 0426                   .dbline 330
 0426           ;       EECR|=BIT(EEWE);//EEWE置1
 0426 E19A              sbi 0x1c,1
 0428                   .dbline 332
 0428           ;       
 0428           ;       SREG |= BIT(3);//打开全局中断
 0428 3894              bset 3
 042A                   .dbline -2
 042A           L87:
 042A                   .dbline 0 ; func end
 042A 0895              ret
 042C                   .dbsym r force_save 16 I
 042C                   .dbend
 042C                   .dbfunc e command_data_read_force_high8 _command_data_read_force_high8 fV
 042C           ;           PARA -> R16,R17
                        .even
 042C           _command_data_read_force_high8::
 042C                   .dbline -1
 042C                   .dbline 337
 042C           ; }
 042C           ; 
 042C           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动第一阶段
 042C           ; void command_data_read_force_high8(uchar* PARA)
 042C           ; {
 042C                   .dbline 338
 042C           ;     SREG &=(~BIT(3));//关闭全局中断
 042C B894              bclr 3
 042E           L92:
 042E                   .dbline 340
 042E           ;       
 042E           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 042E           L93:
 042E                   .dbline 340
 042E E199              sbic 0x1c,1
 0430 FECF              rjmp L92
 0432           X24:
 0432                   .dbline 341
 0432           ;       EEAR=0x0030;//写地址
 0432 80E3              ldi R24,48
 0434 90E0              ldi R25,0
 0436 9FBB              out 0x1f,R25
 0438 8EBB              out 0x1e,R24
 043A                   .dbline 342
 043A           ;       EECR|=BIT(EERE);//读允许位置1
 043A E09A              sbi 0x1c,0
 043C                   .dbline 343
 043C           ;       *PARA=EEDR;//读出EEDR中的数据
 043C 2DB2              in R2,0x1d
 043E F801              movw R30,R16
 0440 2082              std z+0,R2
 0442                   .dbline 345
 0442           ; 
 0442           ;       SREG |= BIT(3);//打开全局中断
 0442 3894              bset 3
 0444                   .dbline -2
 0444           L91:
 0444                   .dbline 0 ; func end
 0444 0895              ret
 0446                   .dbsym r PARA 16 pc
 0446                   .dbend
 0446                   .dbfunc e timer1_init _timer1_init fV
                        .even
 0446           _timer1_init::
 0446                   .dbline -1
 0446                   .dbline 350
 0446           ; }
 0446           ; 
 0446           ; //定时计数器初始化函数
 0446           ; void timer1_init(void)
 0446           ; {
 0446                   .dbline 351
 0446           ;     TCCR1B=0X04;//256内部分频
 0446 84E0              ldi R24,4
 0448 8EBD              out 0x2e,R24
 044A                   .dbline 352
 044A           ;       TCNT1=0xC2F6;//定时周期500ms，计算方法见开发文档
 044A 86EF              ldi R24,49910
 044C 92EC              ldi R25,194
 044E 9DBD              out 0x2d,R25
 0450 8CBD              out 0x2c,R24
 0452                   .dbline 353
 0452           ;       TIFR=0x04;//定时计数器1溢出标志位清除，置1清除，上电默认为0
 0452 84E0              ldi R24,4
 0454 86BF              out 0x36,R24
 0456                   .dbline -2
 0456           L95:
 0456                   .dbline 0 ; func end
 0456 0895              ret
 0458                   .dbend
                        .area vector(rom, abs)
                        .org 56
 0038 0C942C02          jmp _timer1_interrupt_handler
                        .area text(rom, con, rel)
 0458                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
                        .area data(ram, con, rel)
 002D                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 002D           L97:
 002D                   .blkb 6
                        .area idata
 002D 7A7A32317700      .byte 'z,'z,50,49,'w,0
                        .area data(ram, con, rel)
 0033                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
                        .area text(rom, con, rel)
 0458                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0458                   .dbfunc e timer1_interrupt_handler _timer1_interrupt_handler fV
 0458           ; msg_force_array -> y+0
                        .even
 0458           _timer1_interrupt_handler::
 0458 0A92              st -y,R0
 045A 1A92              st -y,R1
 045C 2A92              st -y,R2
 045E 3A92              st -y,R3
 0460 4A92              st -y,R4
 0462 5A92              st -y,R5
 0464 6A92              st -y,R6
 0466 7A92              st -y,R7
 0468 8A92              st -y,R8
 046A 9A92              st -y,R9
 046C 0A93              st -y,R16
 046E 1A93              st -y,R17
 0470 2A93              st -y,R18
 0472 3A93              st -y,R19
 0474 8A93              st -y,R24
 0476 9A93              st -y,R25
 0478 AA93              st -y,R26
 047A BA93              st -y,R27
 047C EA93              st -y,R30
 047E FA93              st -y,R31
 0480 0FB6              IN R0,63
 0482 0A92              st -y,R0
 0484 2697              sbiw R28,6
 0486                   .dbline -1
 0486                   .dbline 361
 0486           ; }
 0486           ; 
 0486           ; //声明中断函数
 0486           ; #pragma interrupt_handler timer1_interrupt_handler:15
 0486           ; 
 0486           ; //定时计数器1中断处理函数
 0486           ; void timer1_interrupt_handler(void)
 0486           ; {
 0486                   .dbline 362
 0486           ;     uchar msg_force_array[]="zz21w";
 0486 80E0              ldi R24,<L97
 0488 90E0              ldi R25,>L97
 048A FE01              movw R30,R28
 048C 06E0              ldi R16,6
 048E 10E0              ldi R17,0
 0490 FA93              st -y,R31
 0492 EA93              st -y,R30
 0494 9A93              st -y,R25
 0496 8A93              st -y,R24
 0498 0E940000          xcall asgnblk
 049C                   .dbline 363
 049C           ;       force_ulong=ReadCount();//读取数据放入全局变量
 049C 74DF              xcall _ReadCount
 049E 10930400          sts _force_ulong+1,R17
 04A2 00930300          sts _force_ulong,R16
 04A6 30930600          sts _force_ulong+2+1,R19
 04AA 20930500          sts _force_ulong+2,R18
 04AE                   .dbline 364
 04AE           ;       ulong_to_uchar_array(force_ulong);//数据类型转换
 04AE 43DF              xcall _ulong_to_uchar_array
 04B0                   .dbline 365
 04B0           ;       msg_force_array[4]=force_high8;
 04B0 20900800          lds R2,_force_high8
 04B4 2C82              std y+4,R2
 04B6                   .dbline 366
 04B6           ;       uart0_send_string(msg_force_array);//向上位机发送夹紧力实时数值（仅有效值高八位）
 04B6 8E01              movw R16,R28
 04B8 69DE              xcall _uart0_send_string
 04BA                   .dbline 367
 04BA           ;       TCNT1=0xC2F6;//需要重新设定周期500ms
 04BA 86EF              ldi R24,49910
 04BC 92EC              ldi R25,194
 04BE 9DBD              out 0x2d,R25
 04C0 8CBD              out 0x2c,R24
 04C2                   .dbline -2
 04C2           L96:
 04C2                   .dbline 0 ; func end
 04C2 2696              adiw R28,6
 04C4 0990              ld R0,y+
 04C6 0FBE              OUT 63,R0
 04C8 F991              ld R31,y+
 04CA E991              ld R30,y+
 04CC B991              ld R27,y+
 04CE A991              ld R26,y+
 04D0 9991              ld R25,y+
 04D2 8991              ld R24,y+
 04D4 3991              ld R19,y+
 04D6 2991              ld R18,y+
 04D8 1991              ld R17,y+
 04DA 0991              ld R16,y+
 04DC 9990              ld R9,y+
 04DE 8990              ld R8,y+
 04E0 7990              ld R7,y+
 04E2 6990              ld R6,y+
 04E4 5990              ld R5,y+
 04E6 4990              ld R4,y+
 04E8 3990              ld R3,y+
 04EA 2990              ld R2,y+
 04EC 1990              ld R1,y+
 04EE 0990              ld R0,y+
 04F0 1895              reti
 04F2                   .dbsym l msg_force_array 0 A[6:6]c
 04F2                   .dbend
 04F2                   .dbfunc e ratio_command_check _ratio_command_check fc
 04F2           ;      check_sum -> R10
 04F2           ;          PARA3 -> R10
 04F2           ;          PARA2 -> R18
 04F2           ;             ID -> R16
                        .even
 04F2           _ratio_command_check::
 04F2 AA92              st -y,R10
 04F4 A980              ldd R10,y+1
 04F6                   .dbline -1
 04F6                   .dbline 374
 04F6           ; }
 04F6           ; 
 04F6           ; //----------------【舵机控制相关函数】↓---------------------------------------------
 04F6           ; 
 04F6           ; //指令校验码生成函数，公式由舵机使用说明书指定
 04F6           ; uchar ratio_command_check(uchar ID,uchar PARA2,uchar PARA3)
 04F6           ; {
 04F6                   .dbline 376
 04F6           ;     uchar check_sum;
 04F6           ;       check_sum=0x05+0x03+0x20+ID+PARA2+PARA3;
 04F6 802F              mov R24,R16
 04F8 885D              subi R24,216    ; addi 40
 04FA 820F              add R24,R18
 04FC 8A0D              add R24,R10
 04FE A82E              mov R10,R24
 0500                   .dbline 377
 0500           ;       return ~check_sum;
 0500 082F              mov R16,R24
 0502 0095              com R16
 0504                   .dbline -2
 0504           L99:
 0504                   .dbline 0 ; func end
 0504 A990              ld R10,y+
 0506 0895              ret
 0508                   .dbsym r check_sum 10 c
 0508                   .dbsym r PARA3 10 c
 0508                   .dbsym r PARA2 18 c
 0508                   .dbsym r ID 16 c
 0508                   .dbend
 0508                   .dbfunc e command_data_save_finger_0_ratio_1 _command_data_save_finger_0_ratio_1 fV
 0508           ;          PARA3 -> R18
 0508           ;          PARA2 -> R16
                        .even
 0508           _command_data_save_finger_0_ratio_1::
 0508                   .dbline -1
 0508                   .dbline 382
 0508           ; }
 0508           ; 
 0508           ; //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指移动0第一阶段
 0508           ; void command_data_save_finger_0_ratio_1(uchar PARA2,uchar PARA3)
 0508           ; {
 0508                   .dbline 383
 0508           ;     SREG &=(~BIT(3));//关闭全局中断
 0508 B894              bclr 3
 050A           L101:
 050A                   .dbline 385
 050A           ;       
 050A           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 050A           L102:
 050A                   .dbline 385
 050A E199              sbic 0x1c,1
 050C FECF              rjmp L101
 050E           X25:
 050E                   .dbline 386
 050E           ;       EEAR=0x0000;//写地址
 050E 2224              clr R2
 0510 3324              clr R3
 0512 3FBA              out 0x1f,R3
 0514 2EBA              out 0x1e,R2
 0516                   .dbline 387
 0516           ;       EEDR=PARA2;//写数据
 0516 0DBB              out 0x1d,R16
 0518                   .dbline 388
 0518           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0518 E29A              sbi 0x1c,2
 051A                   .dbline 389
 051A           ;       EECR&=(~BIT(EEWE));//EEWE置0
 051A E198              cbi 0x1c,1
 051C                   .dbline 390
 051C           ;       EECR|=BIT(EEWE);//EEWE置1
 051C E19A              sbi 0x1c,1
 051E           L104:
 051E                   .dbline 392
 051E           ;       
 051E           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 051E           L105:
 051E                   .dbline 392
 051E E199              sbic 0x1c,1
 0520 FECF              rjmp L104
 0522           X26:
 0522                   .dbline 393
 0522           ;       EEAR=0x0001;//写地址
 0522 81E0              ldi R24,1
 0524 90E0              ldi R25,0
 0526 9FBB              out 0x1f,R25
 0528 8EBB              out 0x1e,R24
 052A                   .dbline 394
 052A           ;       EEDR=PARA3;//写数据
 052A 2DBB              out 0x1d,R18
 052C                   .dbline 395
 052C           ;       EECR|=BIT(EEMWE);//EEMWE置1
 052C E29A              sbi 0x1c,2
 052E                   .dbline 396
 052E           ;       EECR&=(~BIT(EEWE));//EEWE置0
 052E E198              cbi 0x1c,1
 0530                   .dbline 397
 0530           ;       EECR|=BIT(EEWE);//EEWE置1
 0530 E19A              sbi 0x1c,1
 0532                   .dbline 399
 0532           ;       
 0532           ;       SREG |= BIT(3);//打开全局中断
 0532 3894              bset 3
 0534                   .dbline -2
 0534           L100:
 0534                   .dbline 0 ; func end
 0534 0895              ret
 0536                   .dbsym r PARA3 18 c
 0536                   .dbsym r PARA2 16 c
 0536                   .dbend
 0536                   .dbfunc e command_data_save_finger_0_ratio_2 _command_data_save_finger_0_ratio_2 fV
 0536           ;          PARA3 -> R18
 0536           ;          PARA2 -> R16
                        .even
 0536           _command_data_save_finger_0_ratio_2::
 0536                   .dbline -1
 0536                   .dbline 404
 0536           ; }
 0536           ; 
 0536           ; //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指0移动第二阶段
 0536           ; void command_data_save_finger_0_ratio_2(uchar PARA2,uchar PARA3)
 0536           ; {
 0536                   .dbline 405
 0536           ;     SREG &=(~BIT(3));//关闭全局中断
 0536 B894              bclr 3
 0538           L108:
 0538                   .dbline 407
 0538           ;       
 0538           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 0538           L109:
 0538                   .dbline 407
 0538 E199              sbic 0x1c,1
 053A FECF              rjmp L108
 053C           X27:
 053C                   .dbline 408
 053C           ;       EEAR=0x0002;//写地址
 053C 82E0              ldi R24,2
 053E 90E0              ldi R25,0
 0540 9FBB              out 0x1f,R25
 0542 8EBB              out 0x1e,R24
 0544                   .dbline 409
 0544           ;       EEDR=PARA2;//写数据
 0544 0DBB              out 0x1d,R16
 0546                   .dbline 410
 0546           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0546 E29A              sbi 0x1c,2
 0548                   .dbline 411
 0548           ;       EECR&=(~BIT(EEWE));//EEWE置0
 0548 E198              cbi 0x1c,1
 054A                   .dbline 412
 054A           ;       EECR|=BIT(EEWE);//EEWE置1
 054A E19A              sbi 0x1c,1
 054C           L111:
 054C                   .dbline 414
 054C           ;       
 054C           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 054C           L112:
 054C                   .dbline 414
 054C E199              sbic 0x1c,1
 054E FECF              rjmp L111
 0550           X28:
 0550                   .dbline 415
 0550           ;       EEAR=0x0003;//写地址
 0550 83E0              ldi R24,3
 0552 90E0              ldi R25,0
 0554 9FBB              out 0x1f,R25
 0556 8EBB              out 0x1e,R24
 0558                   .dbline 416
 0558           ;       EEDR=PARA3;//写数据
 0558 2DBB              out 0x1d,R18
 055A                   .dbline 417
 055A           ;       EECR|=BIT(EEMWE);//EEMWE置1
 055A E29A              sbi 0x1c,2
 055C                   .dbline 418
 055C           ;       EECR&=(~BIT(EEWE));//EEWE置0
 055C E198              cbi 0x1c,1
 055E                   .dbline 419
 055E           ;       EECR|=BIT(EEWE);//EEWE置1
 055E E19A              sbi 0x1c,1
 0560                   .dbline 421
 0560           ;       
 0560           ;       SREG |= BIT(3);//打开全局中断
 0560 3894              bset 3
 0562                   .dbline -2
 0562           L107:
 0562                   .dbline 0 ; func end
 0562 0895              ret
 0564                   .dbsym r PARA3 18 c
 0564                   .dbsym r PARA2 16 c
 0564                   .dbend
 0564                   .dbfunc e command_data_save_finger_0_ratio_3 _command_data_save_finger_0_ratio_3 fV
 0564           ;          PARA3 -> R18
 0564           ;          PARA2 -> R16
                        .even
 0564           _command_data_save_finger_0_ratio_3::
 0564                   .dbline -1
 0564                   .dbline 426
 0564           ; }
 0564           ; 
 0564           ; //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指0移动松开阶段
 0564           ; void command_data_save_finger_0_ratio_3(uchar PARA2,uchar PARA3)
 0564           ; {
 0564                   .dbline 427
 0564           ;     SREG &=(~BIT(3));//关闭全局中断
 0564 B894              bclr 3
 0566           L115:
 0566                   .dbline 429
 0566           ;       
 0566           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 0566           L116:
 0566                   .dbline 429
 0566 E199              sbic 0x1c,1
 0568 FECF              rjmp L115
 056A           X29:
 056A                   .dbline 430
 056A           ;       EEAR=0x0004;//写地址
 056A 84E0              ldi R24,4
 056C 90E0              ldi R25,0
 056E 9FBB              out 0x1f,R25
 0570 8EBB              out 0x1e,R24
 0572                   .dbline 431
 0572           ;       EEDR=PARA2;//写数据
 0572 0DBB              out 0x1d,R16
 0574                   .dbline 432
 0574           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0574 E29A              sbi 0x1c,2
 0576                   .dbline 433
 0576           ;       EECR&=(~BIT(EEWE));//EEWE置0
 0576 E198              cbi 0x1c,1
 0578                   .dbline 434
 0578           ;       EECR|=BIT(EEWE);//EEWE置1
 0578 E19A              sbi 0x1c,1
 057A           L118:
 057A                   .dbline 436
 057A           ;       
 057A           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 057A           L119:
 057A                   .dbline 436
 057A E199              sbic 0x1c,1
 057C FECF              rjmp L118
 057E           X30:
 057E                   .dbline 437
 057E           ;       EEAR=0x0005;//写地址
 057E 85E0              ldi R24,5
 0580 90E0              ldi R25,0
 0582 9FBB              out 0x1f,R25
 0584 8EBB              out 0x1e,R24
 0586                   .dbline 438
 0586           ;       EEDR=PARA3;//写数据
 0586 2DBB              out 0x1d,R18
 0588                   .dbline 439
 0588           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0588 E29A              sbi 0x1c,2
 058A                   .dbline 440
 058A           ;       EECR&=(~BIT(EEWE));//EEWE置0
 058A E198              cbi 0x1c,1
 058C                   .dbline 441
 058C           ;       EECR|=BIT(EEWE);//EEWE置1
 058C E19A              sbi 0x1c,1
 058E                   .dbline 443
 058E           ;       
 058E           ;       SREG |= BIT(3);//打开全局中断
 058E 3894              bset 3
 0590                   .dbline -2
 0590           L114:
 0590                   .dbline 0 ; func end
 0590 0895              ret
 0592                   .dbsym r PARA3 18 c
 0592                   .dbsym r PARA2 16 c
 0592                   .dbend
 0592                   .dbfunc e command_data_read_finger_0_ratio_1 _command_data_read_finger_0_ratio_1 fV
 0592           ;          PARA3 -> R18,R19
 0592           ;          PARA2 -> R16,R17
                        .even
 0592           _command_data_read_finger_0_ratio_1::
 0592                   .dbline -1
 0592                   .dbline 448
 0592           ; }
 0592           ; 
 0592           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指0移动第一阶段
 0592           ; void command_data_read_finger_0_ratio_1(uchar* PARA2,uchar* PARA3)
 0592           ; {
 0592                   .dbline 449
 0592           ;     SREG &=(~BIT(3));//关闭全局中断
 0592 B894              bclr 3
 0594           L122:
 0594                   .dbline 451
 0594           ;       
 0594           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 0594           L123:
 0594                   .dbline 451
 0594 E199              sbic 0x1c,1
 0596 FECF              rjmp L122
 0598           X31:
 0598                   .dbline 452
 0598           ;       EEAR=0x0000;//写地址
 0598 2224              clr R2
 059A 3324              clr R3
 059C 3FBA              out 0x1f,R3
 059E 2EBA              out 0x1e,R2
 05A0                   .dbline 453
 05A0           ;       EECR|=BIT(EERE);//读允许位置1
 05A0 E09A              sbi 0x1c,0
 05A2                   .dbline 454
 05A2           ;       *PARA2=EEDR;//读出EEDR中的数据
 05A2 2DB2              in R2,0x1d
 05A4 F801              movw R30,R16
 05A6 2082              std z+0,R2
 05A8           L125:
 05A8                   .dbline 456
 05A8           ; 
 05A8           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 05A8           L126:
 05A8                   .dbline 456
 05A8 E199              sbic 0x1c,1
 05AA FECF              rjmp L125
 05AC           X32:
 05AC                   .dbline 457
 05AC           ;       EEAR=0x0001;//写地址
 05AC 81E0              ldi R24,1
 05AE 90E0              ldi R25,0
 05B0 9FBB              out 0x1f,R25
 05B2 8EBB              out 0x1e,R24
 05B4                   .dbline 458
 05B4           ;       EECR|=BIT(EERE);//读允许位置1
 05B4 E09A              sbi 0x1c,0
 05B6                   .dbline 459
 05B6           ;       *PARA3=EEDR;//读出EEDR中的数据
 05B6 2DB2              in R2,0x1d
 05B8 F901              movw R30,R18
 05BA 2082              std z+0,R2
 05BC                   .dbline 461
 05BC           ;       
 05BC           ;       SREG |= BIT(3);//打开全局中断
 05BC 3894              bset 3
 05BE                   .dbline -2
 05BE           L121:
 05BE                   .dbline 0 ; func end
 05BE 0895              ret
 05C0                   .dbsym r PARA3 18 pc
 05C0                   .dbsym r PARA2 16 pc
 05C0                   .dbend
 05C0                   .dbfunc e command_data_read_finger_0_ratio_2 _command_data_read_finger_0_ratio_2 fV
 05C0           ;          PARA3 -> R18,R19
 05C0           ;          PARA2 -> R16,R17
                        .even
 05C0           _command_data_read_finger_0_ratio_2::
 05C0                   .dbline -1
 05C0                   .dbline 466
 05C0           ; }
 05C0           ; 
 05C0           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指0移动第二阶段
 05C0           ; void command_data_read_finger_0_ratio_2(uchar* PARA2,uchar* PARA3)
 05C0           ; {
 05C0                   .dbline 467
 05C0           ;     SREG &=(~BIT(3));//关闭全局中断
 05C0 B894              bclr 3
 05C2           L129:
 05C2                   .dbline 469
 05C2           ;       
 05C2           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 05C2           L130:
 05C2                   .dbline 469
 05C2 E199              sbic 0x1c,1
 05C4 FECF              rjmp L129
 05C6           X33:
 05C6                   .dbline 470
 05C6           ;       EEAR=0x0002;//写地址
 05C6 82E0              ldi R24,2
 05C8 90E0              ldi R25,0
 05CA 9FBB              out 0x1f,R25
 05CC 8EBB              out 0x1e,R24
 05CE                   .dbline 471
 05CE           ;       EECR|=BIT(EERE);//读允许位置1
 05CE E09A              sbi 0x1c,0
 05D0                   .dbline 472
 05D0           ;       *PARA2=EEDR;//读出EEDR中的数据
 05D0 2DB2              in R2,0x1d
 05D2 F801              movw R30,R16
 05D4 2082              std z+0,R2
 05D6           L132:
 05D6                   .dbline 474
 05D6           ; 
 05D6           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 05D6           L133:
 05D6                   .dbline 474
 05D6 E199              sbic 0x1c,1
 05D8 FECF              rjmp L132
 05DA           X34:
 05DA                   .dbline 475
 05DA           ;       EEAR=0x0003;//写地址
 05DA 83E0              ldi R24,3
 05DC 90E0              ldi R25,0
 05DE 9FBB              out 0x1f,R25
 05E0 8EBB              out 0x1e,R24
 05E2                   .dbline 476
 05E2           ;       EECR|=BIT(EERE);//读允许位置1
 05E2 E09A              sbi 0x1c,0
 05E4                   .dbline 477
 05E4           ;       *PARA3=EEDR;//读出EEDR中的数据
 05E4 2DB2              in R2,0x1d
 05E6 F901              movw R30,R18
 05E8 2082              std z+0,R2
 05EA                   .dbline 479
 05EA           ;       
 05EA           ;       SREG |= BIT(3);//打开全局中断
 05EA 3894              bset 3
 05EC                   .dbline -2
 05EC           L128:
 05EC                   .dbline 0 ; func end
 05EC 0895              ret
 05EE                   .dbsym r PARA3 18 pc
 05EE                   .dbsym r PARA2 16 pc
 05EE                   .dbend
 05EE                   .dbfunc e command_data_read_finger_0_ratio_3 _command_data_read_finger_0_ratio_3 fV
 05EE           ;          PARA3 -> R18,R19
 05EE           ;          PARA2 -> R16,R17
                        .even
 05EE           _command_data_read_finger_0_ratio_3::
 05EE                   .dbline -1
 05EE                   .dbline 484
 05EE           ; }
 05EE           ; 
 05EE           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指0移动移动阶段
 05EE           ; void command_data_read_finger_0_ratio_3(uchar* PARA2,uchar* PARA3)
 05EE           ; {
 05EE                   .dbline 485
 05EE           ;     SREG &=(~BIT(3));//关闭全局中断
 05EE B894              bclr 3
 05F0           L136:
 05F0                   .dbline 487
 05F0           ;       
 05F0           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 05F0           L137:
 05F0                   .dbline 487
 05F0 E199              sbic 0x1c,1
 05F2 FECF              rjmp L136
 05F4           X35:
 05F4                   .dbline 488
 05F4           ;       EEAR=0x0004;//写地址
 05F4 84E0              ldi R24,4
 05F6 90E0              ldi R25,0
 05F8 9FBB              out 0x1f,R25
 05FA 8EBB              out 0x1e,R24
 05FC                   .dbline 489
 05FC           ;       EECR|=BIT(EERE);//读允许位置1
 05FC E09A              sbi 0x1c,0
 05FE                   .dbline 490
 05FE           ;       *PARA2=EEDR;//读出EEDR中的数据
 05FE 2DB2              in R2,0x1d
 0600 F801              movw R30,R16
 0602 2082              std z+0,R2
 0604           L139:
 0604                   .dbline 492
 0604           ; 
 0604           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 0604           L140:
 0604                   .dbline 492
 0604 E199              sbic 0x1c,1
 0606 FECF              rjmp L139
 0608           X36:
 0608                   .dbline 493
 0608           ;       EEAR=0x0005;//写地址
 0608 85E0              ldi R24,5
 060A 90E0              ldi R25,0
 060C 9FBB              out 0x1f,R25
 060E 8EBB              out 0x1e,R24
 0610                   .dbline 494
 0610           ;       EECR|=BIT(EERE);//读允许位置1
 0610 E09A              sbi 0x1c,0
 0612                   .dbline 495
 0612           ;       *PARA3=EEDR;//读出EEDR中的数据
 0612 2DB2              in R2,0x1d
 0614 F901              movw R30,R18
 0616 2082              std z+0,R2
 0618                   .dbline 497
 0618           ;       
 0618           ;       SREG |= BIT(3);//打开全局中断
 0618 3894              bset 3
 061A                   .dbline -2
 061A           L135:
 061A                   .dbline 0 ; func end
 061A 0895              ret
 061C                   .dbsym r PARA3 18 pc
 061C                   .dbsym r PARA2 16 pc
 061C                   .dbend
 061C                   .dbfunc e command_data_save_finger_1_ratio_1 _command_data_save_finger_1_ratio_1 fV
 061C           ;          PARA3 -> R18
 061C           ;          PARA2 -> R16
                        .even
 061C           _command_data_save_finger_1_ratio_1::
 061C                   .dbline -1
 061C                   .dbline 502
 061C           ; }
 061C           ; 
 061C           ; //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指1移动第一阶段
 061C           ; void command_data_save_finger_1_ratio_1(uchar PARA2,uchar PARA3)
 061C           ; {
 061C                   .dbline 503
 061C           ;     SREG &=(~BIT(3));//关闭全局中断
 061C B894              bclr 3
 061E           L143:
 061E                   .dbline 505
 061E           ;       
 061E           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 061E           L144:
 061E                   .dbline 505
 061E E199              sbic 0x1c,1
 0620 FECF              rjmp L143
 0622           X37:
 0622                   .dbline 506
 0622           ;       EEAR=0x0010;//写地址
 0622 80E1              ldi R24,16
 0624 90E0              ldi R25,0
 0626 9FBB              out 0x1f,R25
 0628 8EBB              out 0x1e,R24
 062A                   .dbline 507
 062A           ;       EEDR=PARA2;//写数据
 062A 0DBB              out 0x1d,R16
 062C                   .dbline 508
 062C           ;       EECR|=BIT(EEMWE);//EEMWE置1
 062C E29A              sbi 0x1c,2
 062E                   .dbline 509
 062E           ;       EECR&=(~BIT(EEWE));//EEWE置0
 062E E198              cbi 0x1c,1
 0630                   .dbline 510
 0630           ;       EECR|=BIT(EEWE);//EEWE置1
 0630 E19A              sbi 0x1c,1
 0632           L146:
 0632                   .dbline 512
 0632           ;       
 0632           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 0632           L147:
 0632                   .dbline 512
 0632 E199              sbic 0x1c,1
 0634 FECF              rjmp L146
 0636           X38:
 0636                   .dbline 513
 0636           ;       EEAR=0x0011;//写地址
 0636 81E1              ldi R24,17
 0638 90E0              ldi R25,0
 063A 9FBB              out 0x1f,R25
 063C 8EBB              out 0x1e,R24
 063E                   .dbline 514
 063E           ;       EEDR=PARA3;//写数据
 063E 2DBB              out 0x1d,R18
 0640                   .dbline 515
 0640           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0640 E29A              sbi 0x1c,2
 0642                   .dbline 516
 0642           ;       EECR&=(~BIT(EEWE));//EEWE置0
 0642 E198              cbi 0x1c,1
 0644                   .dbline 517
 0644           ;       EECR|=BIT(EEWE);//EEWE置1
 0644 E19A              sbi 0x1c,1
 0646                   .dbline 519
 0646           ;       
 0646           ;       SREG |= BIT(3);//打开全局中断
 0646 3894              bset 3
 0648                   .dbline -2
 0648           L142:
 0648                   .dbline 0 ; func end
 0648 0895              ret
 064A                   .dbsym r PARA3 18 c
 064A                   .dbsym r PARA2 16 c
 064A                   .dbend
 064A                   .dbfunc e command_data_save_finger_1_ratio_2 _command_data_save_finger_1_ratio_2 fV
 064A           ;          PARA3 -> R18
 064A           ;          PARA2 -> R16
                        .even
 064A           _command_data_save_finger_1_ratio_2::
 064A                   .dbline -1
 064A                   .dbline 524
 064A           ; }
 064A           ; 
 064A           ; //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指1移动第二阶段
 064A           ; void command_data_save_finger_1_ratio_2(uchar PARA2,uchar PARA3)
 064A           ; {
 064A                   .dbline 525
 064A           ;     SREG &=(~BIT(3));//关闭全局中断
 064A B894              bclr 3
 064C           L150:
 064C                   .dbline 527
 064C           ;       
 064C           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 064C           L151:
 064C                   .dbline 527
 064C E199              sbic 0x1c,1
 064E FECF              rjmp L150
 0650           X39:
 0650                   .dbline 528
 0650           ;       EEAR=0x0012;//写地址
 0650 82E1              ldi R24,18
 0652 90E0              ldi R25,0
 0654 9FBB              out 0x1f,R25
 0656 8EBB              out 0x1e,R24
 0658                   .dbline 529
 0658           ;       EEDR=PARA2;//写数据
 0658 0DBB              out 0x1d,R16
 065A                   .dbline 530
 065A           ;       EECR|=BIT(EEMWE);//EEMWE置1
 065A E29A              sbi 0x1c,2
 065C                   .dbline 531
 065C           ;       EECR&=(~BIT(EEWE));//EEWE置0
 065C E198              cbi 0x1c,1
 065E                   .dbline 532
 065E           ;       EECR|=BIT(EEWE);//EEWE置1
 065E E19A              sbi 0x1c,1
 0660           L153:
 0660                   .dbline 534
 0660           ;       
 0660           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 0660           L154:
 0660                   .dbline 534
 0660 E199              sbic 0x1c,1
 0662 FECF              rjmp L153
 0664           X40:
 0664                   .dbline 535
 0664           ;       EEAR=0x0013;//写地址
 0664 83E1              ldi R24,19
 0666 90E0              ldi R25,0
 0668 9FBB              out 0x1f,R25
 066A 8EBB              out 0x1e,R24
 066C                   .dbline 536
 066C           ;       EEDR=PARA3;//写数据
 066C 2DBB              out 0x1d,R18
 066E                   .dbline 537
 066E           ;       EECR|=BIT(EEMWE);//EEMWE置1
 066E E29A              sbi 0x1c,2
 0670                   .dbline 538
 0670           ;       EECR&=(~BIT(EEWE));//EEWE置0
 0670 E198              cbi 0x1c,1
 0672                   .dbline 539
 0672           ;       EECR|=BIT(EEWE);//EEWE置1
 0672 E19A              sbi 0x1c,1
 0674                   .dbline 541
 0674           ;       
 0674           ;       SREG |= BIT(3);//打开全局中断
 0674 3894              bset 3
 0676                   .dbline -2
 0676           L149:
 0676                   .dbline 0 ; func end
 0676 0895              ret
 0678                   .dbsym r PARA3 18 c
 0678                   .dbsym r PARA2 16 c
 0678                   .dbend
 0678                   .dbfunc e command_data_save_finger_1_ratio_3 _command_data_save_finger_1_ratio_3 fV
 0678           ;          PARA3 -> R18
 0678           ;          PARA2 -> R16
                        .even
 0678           _command_data_save_finger_1_ratio_3::
 0678                   .dbline -1
 0678                   .dbline 546
 0678           ; }
 0678           ; 
 0678           ; //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指1移动松开阶段
 0678           ; void command_data_save_finger_1_ratio_3(uchar PARA2,uchar PARA3)
 0678           ; {
 0678                   .dbline 547
 0678           ;     SREG &=(~BIT(3));//关闭全局中断
 0678 B894              bclr 3
 067A           L157:
 067A                   .dbline 549
 067A           ;       
 067A           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 067A           L158:
 067A                   .dbline 549
 067A E199              sbic 0x1c,1
 067C FECF              rjmp L157
 067E           X41:
 067E                   .dbline 550
 067E           ;       EEAR=0x0014;//写地址
 067E 84E1              ldi R24,20
 0680 90E0              ldi R25,0
 0682 9FBB              out 0x1f,R25
 0684 8EBB              out 0x1e,R24
 0686                   .dbline 551
 0686           ;       EEDR=PARA2;//写数据
 0686 0DBB              out 0x1d,R16
 0688                   .dbline 552
 0688           ;       EECR|=BIT(EEMWE);//EEMWE置1
 0688 E29A              sbi 0x1c,2
 068A                   .dbline 553
 068A           ;       EECR&=(~BIT(EEWE));//EEWE置0
 068A E198              cbi 0x1c,1
 068C                   .dbline 554
 068C           ;       EECR|=BIT(EEWE);//EEWE置1
 068C E19A              sbi 0x1c,1
 068E           L160:
 068E                   .dbline 556
 068E           ;       
 068E           ;       while(EECR & BIT(EEWE));//判断EEWE是否为0
 068E           L161:
 068E                   .dbline 556
 068E E199              sbic 0x1c,1
 0690 FECF              rjmp L160
 0692           X42:
 0692                   .dbline 557
 0692           ;       EEAR=0x0015;//写地址
 0692 85E1              ldi R24,21
 0694 90E0              ldi R25,0
 0696 9FBB              out 0x1f,R25
 0698 8EBB              out 0x1e,R24
 069A                   .dbline 558
 069A           ;       EEDR=PARA3;//写数据
 069A 2DBB              out 0x1d,R18
 069C                   .dbline 559
 069C           ;       EECR|=BIT(EEMWE);//EEMWE置1
 069C E29A              sbi 0x1c,2
 069E                   .dbline 560
 069E           ;       EECR&=(~BIT(EEWE));//EEWE置0
 069E E198              cbi 0x1c,1
 06A0                   .dbline 561
 06A0           ;       EECR|=BIT(EEWE);//EEWE置1
 06A0 E19A              sbi 0x1c,1
 06A2                   .dbline 563
 06A2           ;       
 06A2           ;       SREG |= BIT(3);//打开全局中断
 06A2 3894              bset 3
 06A4                   .dbline -2
 06A4           L156:
 06A4                   .dbline 0 ; func end
 06A4 0895              ret
 06A6                   .dbsym r PARA3 18 c
 06A6                   .dbsym r PARA2 16 c
 06A6                   .dbend
 06A6                   .dbfunc e command_data_read_finger_1_ratio_1 _command_data_read_finger_1_ratio_1 fV
 06A6           ;          PARA3 -> R18,R19
 06A6           ;          PARA2 -> R16,R17
                        .even
 06A6           _command_data_read_finger_1_ratio_1::
 06A6                   .dbline -1
 06A6                   .dbline 568
 06A6           ; }
 06A6           ; 
 06A6           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动第一阶段
 06A6           ; void command_data_read_finger_1_ratio_1(uchar* PARA2,uchar* PARA3)
 06A6           ; {
 06A6                   .dbline 569
 06A6           ;     SREG &=(~BIT(3));//关闭全局中断
 06A6 B894              bclr 3
 06A8           L164:
 06A8                   .dbline 571
 06A8           ;       
 06A8           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 06A8           L165:
 06A8                   .dbline 571
 06A8 E199              sbic 0x1c,1
 06AA FECF              rjmp L164
 06AC           X43:
 06AC                   .dbline 572
 06AC           ;       EEAR=0x0010;//写地址
 06AC 80E1              ldi R24,16
 06AE 90E0              ldi R25,0
 06B0 9FBB              out 0x1f,R25
 06B2 8EBB              out 0x1e,R24
 06B4                   .dbline 573
 06B4           ;       EECR|=BIT(EERE);//读允许位置1
 06B4 E09A              sbi 0x1c,0
 06B6                   .dbline 574
 06B6           ;       *PARA2=EEDR;//读出EEDR中的数据
 06B6 2DB2              in R2,0x1d
 06B8 F801              movw R30,R16
 06BA 2082              std z+0,R2
 06BC           L167:
 06BC                   .dbline 576
 06BC           ; 
 06BC           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 06BC           L168:
 06BC                   .dbline 576
 06BC E199              sbic 0x1c,1
 06BE FECF              rjmp L167
 06C0           X44:
 06C0                   .dbline 577
 06C0           ;       EEAR=0x0011;//写地址
 06C0 81E1              ldi R24,17
 06C2 90E0              ldi R25,0
 06C4 9FBB              out 0x1f,R25
 06C6 8EBB              out 0x1e,R24
 06C8                   .dbline 578
 06C8           ;       EECR|=BIT(EERE);//读允许位置1
 06C8 E09A              sbi 0x1c,0
 06CA                   .dbline 579
 06CA           ;       *PARA3=EEDR;//读出EEDR中的数据
 06CA 2DB2              in R2,0x1d
 06CC F901              movw R30,R18
 06CE 2082              std z+0,R2
 06D0                   .dbline 581
 06D0           ;       
 06D0           ;       SREG |= BIT(3);//打开全局中断
 06D0 3894              bset 3
 06D2                   .dbline -2
 06D2           L163:
 06D2                   .dbline 0 ; func end
 06D2 0895              ret
 06D4                   .dbsym r PARA3 18 pc
 06D4                   .dbsym r PARA2 16 pc
 06D4                   .dbend
 06D4                   .dbfunc e command_data_read_finger_1_ratio_2 _command_data_read_finger_1_ratio_2 fV
 06D4           ;          PARA3 -> R18,R19
 06D4           ;          PARA2 -> R16,R17
                        .even
 06D4           _command_data_read_finger_1_ratio_2::
 06D4                   .dbline -1
 06D4                   .dbline 586
 06D4           ; }
 06D4           ; 
 06D4           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动第二阶段
 06D4           ; void command_data_read_finger_1_ratio_2(uchar* PARA2,uchar* PARA3)
 06D4           ; {
 06D4                   .dbline 587
 06D4           ;     SREG &=(~BIT(3));//关闭全局中断
 06D4 B894              bclr 3
 06D6           L171:
 06D6                   .dbline 589
 06D6           ;       
 06D6           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 06D6           L172:
 06D6                   .dbline 589
 06D6 E199              sbic 0x1c,1
 06D8 FECF              rjmp L171
 06DA           X45:
 06DA                   .dbline 590
 06DA           ;       EEAR=0x0012;//写地址
 06DA 82E1              ldi R24,18
 06DC 90E0              ldi R25,0
 06DE 9FBB              out 0x1f,R25
 06E0 8EBB              out 0x1e,R24
 06E2                   .dbline 591
 06E2           ;       EECR|=BIT(EERE);//读允许位置1
 06E2 E09A              sbi 0x1c,0
 06E4                   .dbline 592
 06E4           ;       *PARA2=EEDR;//读出EEDR中的数据
 06E4 2DB2              in R2,0x1d
 06E6 F801              movw R30,R16
 06E8 2082              std z+0,R2
 06EA           L174:
 06EA                   .dbline 594
 06EA           ; 
 06EA           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 06EA           L175:
 06EA                   .dbline 594
 06EA E199              sbic 0x1c,1
 06EC FECF              rjmp L174
 06EE           X46:
 06EE                   .dbline 595
 06EE           ;       EEAR=0x0013;//写地址
 06EE 83E1              ldi R24,19
 06F0 90E0              ldi R25,0
 06F2 9FBB              out 0x1f,R25
 06F4 8EBB              out 0x1e,R24
 06F6                   .dbline 596
 06F6           ;       EECR|=BIT(EERE);//读允许位置1
 06F6 E09A              sbi 0x1c,0
 06F8                   .dbline 597
 06F8           ;       *PARA3=EEDR;//读出EEDR中的数据
 06F8 2DB2              in R2,0x1d
 06FA F901              movw R30,R18
 06FC 2082              std z+0,R2
 06FE                   .dbline 599
 06FE           ;       
 06FE           ;       SREG |= BIT(3);//打开全局中断
 06FE 3894              bset 3
 0700                   .dbline -2
 0700           L170:
 0700                   .dbline 0 ; func end
 0700 0895              ret
 0702                   .dbsym r PARA3 18 pc
 0702                   .dbsym r PARA2 16 pc
 0702                   .dbend
 0702                   .dbfunc e command_data_read_finger_1_ratio_3 _command_data_read_finger_1_ratio_3 fV
 0702           ;          PARA3 -> R18,R19
 0702           ;          PARA2 -> R16,R17
                        .even
 0702           _command_data_read_finger_1_ratio_3::
 0702                   .dbline -1
 0702                   .dbline 604
 0702           ; }
 0702           ; 
 0702           ; //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动移动阶段
 0702           ; void command_data_read_finger_1_ratio_3(uchar* PARA2,uchar* PARA3)
 0702           ; {
 0702                   .dbline 605
 0702           ;     SREG &=(~BIT(3));//关闭全局中断
 0702 B894              bclr 3
 0704           L178:
 0704                   .dbline 607
 0704           ;       
 0704           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 0704           L179:
 0704                   .dbline 607
 0704 E199              sbic 0x1c,1
 0706 FECF              rjmp L178
 0708           X47:
 0708                   .dbline 608
 0708           ;       EEAR=0x0014;//写地址
 0708 84E1              ldi R24,20
 070A 90E0              ldi R25,0
 070C 9FBB              out 0x1f,R25
 070E 8EBB              out 0x1e,R24
 0710                   .dbline 609
 0710           ;       EECR|=BIT(EERE);//读允许位置1
 0710 E09A              sbi 0x1c,0
 0712                   .dbline 610
 0712           ;       *PARA2=EEDR;//读出EEDR中的数据
 0712 2DB2              in R2,0x1d
 0714 F801              movw R30,R16
 0716 2082              std z+0,R2
 0718           L181:
 0718                   .dbline 612
 0718           ; 
 0718           ;       while(EECR & BIT(EEWE));//等待前面的“写”操作完成
 0718           L182:
 0718                   .dbline 612
 0718 E199              sbic 0x1c,1
 071A FECF              rjmp L181
 071C           X48:
 071C                   .dbline 613
 071C           ;       EEAR=0x0015;//写地址
 071C 85E1              ldi R24,21
 071E 90E0              ldi R25,0
 0720 9FBB              out 0x1f,R25
 0722 8EBB              out 0x1e,R24
 0724                   .dbline 614
 0724           ;       EECR|=BIT(EERE);//读允许位置1
 0724 E09A              sbi 0x1c,0
 0726                   .dbline 615
 0726           ;       *PARA3=EEDR;//读出EEDR中的数据
 0726 2DB2              in R2,0x1d
 0728 F901              movw R30,R18
 072A 2082              std z+0,R2
 072C                   .dbline 617
 072C           ;       
 072C           ;       SREG |= BIT(3);//打开全局中断
 072C 3894              bset 3
 072E                   .dbline -2
 072E           L177:
 072E                   .dbline 0 ; func end
 072E 0895              ret
 0730                   .dbsym r PARA3 18 pc
 0730                   .dbsym r PARA2 16 pc
 0730                   .dbend
 0730                   .dbfunc e ext_interrupt_init _ext_interrupt_init fV
                        .even
 0730           _ext_interrupt_init::
 0730                   .dbline -1
 0730                   .dbline 624
 0730           ; }
 0730           ; 
 0730           ; 
 0730           ; //----------------【外部中断向量定义与外部中断处理函数】↓--------------------------------
 0730           ; 
 0730           ; void ext_interrupt_init(void)
 0730           ; {
 0730                   .dbline 626
 0730           ;     //PD0=INT0=夹持器上方触碰，带上拉电阻输入
 0730           ;     DDRD&=(~BIT(0));//意思是DDRD0=0，其余位不变。但注意不可按注释的方式写！
 0730 8898              cbi 0x11,0
 0732                   .dbline 627
 0732           ;     PORTD|=BIT(0);//意思是PORTD0=1，其余位不变。但注意不可按注释的方式写！
 0732 909A              sbi 0x12,0
 0734                   .dbline 630
 0734           ;       
 0734           ;     //PD1=INT1=夹持器下方触碰，带上拉电阻输入
 0734           ;     DDRD&=(~BIT(1));
 0734 8998              cbi 0x11,1
 0736                   .dbline 631
 0736           ;     PORTD|=BIT(1);
 0736 919A              sbi 0x12,1
 0738                   .dbline 634
 0738           ; 
 0738           ;       //PE4=INT4=夹持器前方触碰，带上拉电阻输入
 0738           ;     DDRE&=(~BIT(4));
 0738 1498              cbi 0x2,4
 073A                   .dbline 635
 073A           ;     PORTE|=BIT(4);
 073A 1C9A              sbi 0x3,4
 073C                   .dbline 638
 073C           ;       
 073C           ;       //INT0和INT1的外部中断寄存器配置
 073C           ;     EICRA|=BIT(ISC01)|BIT(ISC11);//中断触发方式：下降沿触发
 073C 80916A00          lds R24,106
 0740 8A60              ori R24,10
 0742 80936A00          sts 106,R24
 0746                   .dbline 639
 0746           ;     EIMSK|=BIT(0)|BIT(1);//中断使能   
 0746 89B7              in R24,0x39
 0748 8360              ori R24,3
 074A 89BF              out 0x39,R24
 074C                   .dbline 642
 074C           ; 
 074C           ;     //INT4的外部中断寄存器配置
 074C           ;     EICRB|=BIT(ISC41);//中断触发方式：下降沿触发
 074C 8AB7              in R24,0x3a
 074E 8260              ori R24,2
 0750 8ABF              out 0x3a,R24
 0752                   .dbline 643
 0752           ;     EIMSK|=BIT(4);//中断使能
 0752 89B7              in R24,0x39
 0754 8061              ori R24,16
 0756 89BF              out 0x39,R24
 0758                   .dbline -2
 0758           L184:
 0758                   .dbline 0 ; func end
 0758 0895              ret
 075A                   .dbend
                        .area vector(rom, abs)
                        .org 4
 0004 0C94AD03          jmp _interrupt_0_handler
                        .area text(rom, con, rel)
 075A                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 075A                   .dbfunc e interrupt_0_handler _interrupt_0_handler fV
                        .even
 075A           _interrupt_0_handler::
 075A 0A92              st -y,R0
 075C 1A92              st -y,R1
 075E 2A92              st -y,R2
 0760 3A92              st -y,R3
 0762 4A92              st -y,R4
 0764 5A92              st -y,R5
 0766 6A92              st -y,R6
 0768 7A92              st -y,R7
 076A 8A92              st -y,R8
 076C 9A92              st -y,R9
 076E 0A93              st -y,R16
 0770 1A93              st -y,R17
 0772 2A93              st -y,R18
 0774 3A93              st -y,R19
 0776 8A93              st -y,R24
 0778 9A93              st -y,R25
 077A AA93              st -y,R26
 077C BA93              st -y,R27
 077E EA93              st -y,R30
 0780 FA93              st -y,R31
 0782 0FB6              IN R0,63
 0784 0A92              st -y,R0
 0786                   .dbline -1
 0786                   .dbline 651
 0786           ; }
 0786           ; 
 0786           ; //夹持器上方触碰（INT0）中断向量定义 
 0786           ; #pragma interrupt_handler interrupt_0_handler:2
 0786           ; 
 0786           ; //夹持器上方触碰（INT0）中断处理函数
 0786           ; void interrupt_0_handler(void)
 0786           ; {
 0786                   .dbline 652
 0786           ;       if(ext_collision_alert_allow_int0)
 0786 20902A00          lds R2,_ext_collision_alert_allow_int0
 078A 2220              tst R2
 078C 49F0              breq L186
 078E           X49:
 078E                   .dbline 653
 078E           ;       {
 078E                   .dbline 654
 078E           ;           delay(50);
 078E 02E3              ldi R16,50
 0790 10E0              ldi R17,0
 0792 36DC              xcall _delay
 0794                   .dbline 655
 0794           ;               uart0_send_string("zz41");
 0794 00E0              ldi R16,<L188
 0796 10E0              ldi R17,>L188
 0798 F9DC              xcall _uart0_send_string
 079A                   .dbline 656
 079A           ;         ext_collision_alert_allow_int0=0;//全局变量
 079A 2224              clr R2
 079C 20922A00          sts _ext_collision_alert_allow_int0,R2
 07A0                   .dbline 657
 07A0           ;       }
 07A0           L186:
 07A0                   .dbline -2
 07A0           L185:
 07A0                   .dbline 0 ; func end
 07A0 0990              ld R0,y+
 07A2 0FBE              OUT 63,R0
 07A4 F991              ld R31,y+
 07A6 E991              ld R30,y+
 07A8 B991              ld R27,y+
 07AA A991              ld R26,y+
 07AC 9991              ld R25,y+
 07AE 8991              ld R24,y+
 07B0 3991              ld R19,y+
 07B2 2991              ld R18,y+
 07B4 1991              ld R17,y+
 07B6 0991              ld R16,y+
 07B8 9990              ld R9,y+
 07BA 8990              ld R8,y+
 07BC 7990              ld R7,y+
 07BE 6990              ld R6,y+
 07C0 5990              ld R5,y+
 07C2 4990              ld R4,y+
 07C4 3990              ld R3,y+
 07C6 2990              ld R2,y+
 07C8 1990              ld R1,y+
 07CA 0990              ld R0,y+
 07CC 1895              reti
 07CE                   .dbend
                        .area vector(rom, abs)
                        .org 8
 0008 0C94E703          jmp _interrupt_1_handler
                        .area text(rom, con, rel)
 07CE                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 07CE                   .dbfunc e interrupt_1_handler _interrupt_1_handler fV
                        .even
 07CE           _interrupt_1_handler::
 07CE 0A92              st -y,R0
 07D0 1A92              st -y,R1
 07D2 2A92              st -y,R2
 07D4 3A92              st -y,R3
 07D6 4A92              st -y,R4
 07D8 5A92              st -y,R5
 07DA 6A92              st -y,R6
 07DC 7A92              st -y,R7
 07DE 8A92              st -y,R8
 07E0 9A92              st -y,R9
 07E2 0A93              st -y,R16
 07E4 1A93              st -y,R17
 07E6 2A93              st -y,R18
 07E8 3A93              st -y,R19
 07EA 8A93              st -y,R24
 07EC 9A93              st -y,R25
 07EE AA93              st -y,R26
 07F0 BA93              st -y,R27
 07F2 EA93              st -y,R30
 07F4 FA93              st -y,R31
 07F6 0FB6              IN R0,63
 07F8 0A92              st -y,R0
 07FA                   .dbline -1
 07FA                   .dbline 665
 07FA           ; }
 07FA           ; 
 07FA           ; //夹持器下方触碰（INT1）中断向量定义 
 07FA           ; #pragma interrupt_handler interrupt_1_handler:3
 07FA           ; 
 07FA           ; //夹持器下方触碰（INT1）中断处理函数
 07FA           ; void interrupt_1_handler(void)
 07FA           ; {
 07FA                   .dbline 666
 07FA           ;       if(ext_collision_alert_allow_int1)
 07FA 20902B00          lds R2,_ext_collision_alert_allow_int1
 07FE 2220              tst R2
 0800 49F0              breq L190
 0802           X50:
 0802                   .dbline 667
 0802           ;       {
 0802                   .dbline 668
 0802           ;           delay(50);
 0802 02E3              ldi R16,50
 0804 10E0              ldi R17,0
 0806 FCDB              xcall _delay
 0808                   .dbline 669
 0808           ;               uart0_send_string("zz42");
 0808 00E0              ldi R16,<L192
 080A 10E0              ldi R17,>L192
 080C BFDC              xcall _uart0_send_string
 080E                   .dbline 670
 080E           ;         ext_collision_alert_allow_int1=0;//全局变量
 080E 2224              clr R2
 0810 20922B00          sts _ext_collision_alert_allow_int1,R2
 0814                   .dbline 671
 0814           ;       }
 0814           L190:
 0814                   .dbline -2
 0814           L189:
 0814                   .dbline 0 ; func end
 0814 0990              ld R0,y+
 0816 0FBE              OUT 63,R0
 0818 F991              ld R31,y+
 081A E991              ld R30,y+
 081C B991              ld R27,y+
 081E A991              ld R26,y+
 0820 9991              ld R25,y+
 0822 8991              ld R24,y+
 0824 3991              ld R19,y+
 0826 2991              ld R18,y+
 0828 1991              ld R17,y+
 082A 0991              ld R16,y+
 082C 9990              ld R9,y+
 082E 8990              ld R8,y+
 0830 7990              ld R7,y+
 0832 6990              ld R6,y+
 0834 5990              ld R5,y+
 0836 4990              ld R4,y+
 0838 3990              ld R3,y+
 083A 2990              ld R2,y+
 083C 1990              ld R1,y+
 083E 0990              ld R0,y+
 0840 1895              reti
 0842                   .dbend
                        .area vector(rom, abs)
                        .org 20
 0014 0C942104          jmp _interrupt_4_handler
                        .area text(rom, con, rel)
 0842                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0842                   .dbfunc e interrupt_4_handler _interrupt_4_handler fV
                        .even
 0842           _interrupt_4_handler::
 0842 0A92              st -y,R0
 0844 1A92              st -y,R1
 0846 2A92              st -y,R2
 0848 3A92              st -y,R3
 084A 4A92              st -y,R4
 084C 5A92              st -y,R5
 084E 6A92              st -y,R6
 0850 7A92              st -y,R7
 0852 8A92              st -y,R8
 0854 9A92              st -y,R9
 0856 0A93              st -y,R16
 0858 1A93              st -y,R17
 085A 2A93              st -y,R18
 085C 3A93              st -y,R19
 085E 8A93              st -y,R24
 0860 9A93              st -y,R25
 0862 AA93              st -y,R26
 0864 BA93              st -y,R27
 0866 EA93              st -y,R30
 0868 FA93              st -y,R31
 086A 0FB6              IN R0,63
 086C 0A92              st -y,R0
 086E                   .dbline -1
 086E                   .dbline 679
 086E           ; }
 086E           ; 
 086E           ; //夹持器指尖触碰（INT4）中断向量定义 
 086E           ; #pragma interrupt_handler interrupt_4_handler:6
 086E           ; 
 086E           ; //夹持器指尖触碰（INT4）中断处理函数
 086E           ; void interrupt_4_handler(void)
 086E           ; {
 086E                   .dbline 680
 086E           ;       if(ext_collision_alert_allow_int4)
 086E 20902C00          lds R2,_ext_collision_alert_allow_int4
 0872 2220              tst R2
 0874 49F0              breq L194
 0876           X51:
 0876                   .dbline 681
 0876           ;       {
 0876                   .dbline 682
 0876           ;           delay(50);
 0876 02E3              ldi R16,50
 0878 10E0              ldi R17,0
 087A C2DB              xcall _delay
 087C                   .dbline 683
 087C           ;               uart0_send_string("zz43");
 087C 00E0              ldi R16,<L196
 087E 10E0              ldi R17,>L196
 0880 85DC              xcall _uart0_send_string
 0882                   .dbline 684
 0882           ;         ext_collision_alert_allow_int4=0;//全局变量
 0882 2224              clr R2
 0884 20922C00          sts _ext_collision_alert_allow_int4,R2
 0888                   .dbline 685
 0888           ;       }
 0888           L194:
 0888                   .dbline -2
 0888           L193:
 0888                   .dbline 0 ; func end
 0888 0990              ld R0,y+
 088A 0FBE              OUT 63,R0
 088C F991              ld R31,y+
 088E E991              ld R30,y+
 0890 B991              ld R27,y+
 0892 A991              ld R26,y+
 0894 9991              ld R25,y+
 0896 8991              ld R24,y+
 0898 3991              ld R19,y+
 089A 2991              ld R18,y+
 089C 1991              ld R17,y+
 089E 0991              ld R16,y+
 08A0 9990              ld R9,y+
 08A2 8990              ld R8,y+
 08A4 7990              ld R7,y+
 08A6 6990              ld R6,y+
 08A8 5990              ld R5,y+
 08AA 4990              ld R4,y+
 08AC 3990              ld R3,y+
 08AE 2990              ld R2,y+
 08B0 1990              ld R1,y+
 08B2 0990              ld R0,y+
 08B4 1895              reti
 08B6                   .dbend
                        .area data(ram, con, rel)
 0033                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0033           L198:
 0033                   .blkb 2
                        .area idata
 0033 FFFF              .byte 255,255
                        .area data(ram, con, rel)
 0035                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0035                   .blkb 2
                        .area idata
 0035 0005              .byte 0,5
                        .area data(ram, con, rel)
 0037                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0037                   .blkb 2
                        .area idata
 0037 0320              .byte 3,32
                        .area data(ram, con, rel)
 0039                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0039                   .blkb 2
                        .area idata
 0039 0000              .byte 0,0
                        .area data(ram, con, rel)
 003B                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 003B                   .blkb 1
                        .area idata
 003B 00                .byte 0
                        .area data(ram, con, rel)
 003C                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 003C           L199:
 003C                   .blkb 2
                        .area idata
 003C 7A7A              .byte 'z,'z
                        .area data(ram, con, rel)
 003E                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 003E                   .blkb 2
                        .area idata
 003E 3434              .byte 52,52
                        .area data(ram, con, rel)
 0040                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0040                   .blkb 2
                        .area idata
 0040 3030              .byte 48,48
                        .area data(ram, con, rel)
 0042                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0042                   .blkb 1
                        .area idata
 0042 30                .byte 48
                        .area data(ram, con, rel)
 0043                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
                        .area text(rom, con, rel)
 08B6                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 08B6                   .dbfunc e main _main fV
 08B6           ; com_finger1_ratio_2_PARA3 -> y+45
 08B6           ; com_finger1_ratio_2_PARA2 -> y+44
 08B6           ; com_finger0_ratio_2_PARA3 -> y+43
 08B6           ; com_finger0_ratio_2_PARA2 -> y+42
 08B6           ; com_finger1_ratio_3_PARA3 -> y+41
 08B6           ; com_finger1_ratio_3_PARA2 -> y+40
 08B6           ; com_finger1_ratio_1_PARA3 -> y+39
 08B6           ; com_finger1_ratio_1_PARA2 -> y+38
 08B6           ; com_finger0_ratio_3_PARA3 -> y+37
 08B6           ; com_finger0_ratio_3_PARA2 -> y+36
 08B6           ; com_finger0_ratio_1_PARA3 -> y+35
 08B6           ; com_finger0_ratio_1_PARA2 -> y+34
 08B6           ; hold_stage_2_continue -> y+53
 08B6           ;          CHECK -> R10
 08B6           ;     approach_1 -> R14
 08B6           ;     approach_0 -> R12
 08B6           ;          PARA3 -> R22
 08B6           ;          PARA2 -> R20
 08B6           ; release_allow_motor_1 -> y+52
 08B6           ; release_allow_motor_0 -> y+51
 08B6           ;  motor_command -> y+25
 08B6           ; hold_allow_motor_1 -> y+50
 08B6           ; hold_allow_motor_0 -> y+49
 08B6           ; msg_eeprom_array -> y+8
 08B6           ; msg_interrupt_array -> y+1
 08B6           ; stop_allow_empty -> y+48
 08B6           ; stop_allow_cage_1 -> y+47
 08B6           ; stop_allow_cage_0 -> y+46
 08B6           ;         cage_1 -> R12
 08B6           ;         cage_0 -> R10
 08B6           ;              i -> R10
                        .even
 08B6           _main::
 08B6 E697              sbiw R28,54
 08B8                   .dbline -1
 08B8                   .dbline 692
 08B8           ; }
 08B8           ; 
 08B8           ; 
 08B8           ; 
 08B8           ; //---------------------------【主函数】↓-----------------------------------------------------------
 08B8           ; void main(void)
 08B8           ; {
 08B8                   .dbline 699
 08B8           ; 
 08B8           ;       //.....................[函数体内变量声明]...............................
 08B8           ; 
 08B8           ;       uchar i;//清空指令存储变量时所用循环的计数变量
 08B8           ;       
 08B8           ;       //向舵机发送移动命令时所用的变量（下面2个）↓
 08B8           ;       uchar motor_command[9]={0xff,0xff,0x00,0x05,0x03,0x20,0x00,0x00,0x00};//
 08B8 80E0              ldi R24,<L198
 08BA 90E0              ldi R25,>L198
 08BC FE01              movw R30,R28
 08BE 7996              adiw R30,25
 08C0 09E0              ldi R16,9
 08C2 10E0              ldi R17,0
 08C4 FA93              st -y,R31
 08C6 EA93              st -y,R30
 08C8 9A93              st -y,R25
 08CA 8A93              st -y,R24
 08CC 0E940000          xcall asgnblk
 08D0                   .dbline 704
 08D0           ;       uchar CHECK;//舵机指令最后一位校验码
 08D0           ;       
 08D0           ;       //上电手指复位阶段用到的变量（下面2个）↓
 08D0           ;       //保证舵机停止命令只进行一次
 08D0           ;       uchar cage_0=1;
 08D0 AA24              clr R10
 08D2 A394              inc R10
 08D4                   .dbline 705
 08D4           ;       uchar cage_1=1;
 08D4 CC24              clr R12
 08D6 C394              inc R12
 08D8                   .dbline 713
 08D8           ;       
 08D8           ;       //正常工作模式（模式一）手指松开阶段用到的变量（下面2个）↓
 08D8           ;       //保证每次夹紧操作时舵机停止命令只进行一次      
 08D8           ;       uchar approach_0;
 08D8           ;       uchar approach_1;
 08D8           ;       
 08D8           ;       //夹紧第二阶段的while循环跳出指示
 08D8           ;       uchar hold_stage_2_continue=1;
 08D8 0024              clr R0
 08DA 0394              inc R0
 08DC 0DAA              std y+53,R0
 08DE                   .dbline 717
 08DE           ;       
 08DE           ;       //大循环中查询两端限位和空夹所用到的变量（下面7个）↓
 08DE           ;       //while大循环从两端限位后开始，因此不允许再次发送舵机停止命令，而是等待限位结束
 08DE           ;       uchar stop_allow_cage_0=0;
 08DE 0024              clr R0
 08E0 0EA6              std y+46,R0
 08E2                   .dbline 718
 08E2           ;       uchar stop_allow_cage_1=0;
 08E2 0FA6              std y+47,R0
 08E4                   .dbline 720
 08E4           ;       //不允许手指向端部移动，允许手指向中间移动，设置四个变量是因为考虑到两端限位跟空夹
 08E4           ;       uchar release_allow_motor_0=0;
 08E4 0BAA              std y+51,R0
 08E6                   .dbline 721
 08E6           ;       uchar release_allow_motor_1=0;
 08E6 0CAA              std y+52,R0
 08E8                   .dbline 722
 08E8           ;       uchar hold_allow_motor_0=1;
 08E8 0024              clr R0
 08EA 0394              inc R0
 08EC 09AA              std y+49,R0
 08EE                   .dbline 723
 08EE           ;       uchar hold_allow_motor_1=1;
 08EE 0AAA              std y+50,R0
 08F0                   .dbline 725
 08F0           ;       //允许上电复位后就开始检测是否空夹
 08F0           ;       uchar stop_allow_empty=1;
 08F0 08AA              std y+48,R0
 08F2                   .dbline 728
 08F2           ;       
 08F2           ;       //调试模式手指移动速度，初始值为通过串口设定前的默认值
 08F2           ;       uchar PARA2=0x10,PARA3=0x01;//保证低速，仅允许通过串口命令更改其值！
 08F2 40E1              ldi R20,16
 08F4                   .dbline 728
 08F4 61E0              ldi R22,1
 08F6                   .dbline 739
 08F6           ;       
 08F6           ;       //一般模式手指移动速度，仅允从EEPROM中获取数值
 08F6           ;       uchar com_finger0_ratio_1_PARA2,com_finger0_ratio_1_PARA3;//手指0，Ratio 1
 08F6           ;       uchar com_finger0_ratio_2_PARA2,com_finger0_ratio_2_PARA3;//手指0，Ratio 2
 08F6           ;       uchar com_finger0_ratio_3_PARA2,com_finger0_ratio_3_PARA3;//手指0，Ratio 3
 08F6           ;       uchar com_finger1_ratio_1_PARA2,com_finger1_ratio_1_PARA3;//手指1，Ratio 1
 08F6           ;       uchar com_finger1_ratio_2_PARA2,com_finger1_ratio_2_PARA3;//手指1，Ratio 2
 08F6           ;       uchar com_finger1_ratio_3_PARA2,com_finger1_ratio_3_PARA3;//手指1，Ratio 3
 08F6           ;       
 08F6           ;       uchar msg_eeprom_array[17];//向上位机返回EEPROM中数值
 08F6           ;       uchar msg_interrupt_array[7]={'z','z','4','4','0','0','0'};//向上位机返回夹持器与外部碰撞报警（中断）允许变量的值
 08F6 80E0              ldi R24,<L199
 08F8 90E0              ldi R25,>L199
 08FA FE01              movw R30,R28
 08FC 3196              adiw R30,1
 08FE 07E0              ldi R16,7
 0900 10E0              ldi R17,0
 0902 FA93              st -y,R31
 0904 EA93              st -y,R30
 0906 9A93              st -y,R25
 0908 8A93              st -y,R24
 090A 0E940000          xcall asgnblk
 090E                   .dbline 744
 090E           ;       
 090E           ;       
 090E           ;       //.......................[初始化配置].........................
 090E           ;       
 090E           ;     uart0_init(19200);//串口0（与上位机通信）初始化，波特率均为19200
 090E 00E0              ldi R16,19200
 0910 1BE4              ldi R17,75
 0912 8BDB              xcall _uart0_init
 0914                   .dbline 745
 0914           ;     uart1_init(19200);//串口1（与舵机通信）初始化，波特率均为19200
 0914 00E0              ldi R16,19200
 0916 1BE4              ldi R17,75
 0918 5EDC              xcall _uart1_init
 091A                   .dbline 746
 091A           ;       timer1_init();//定时计数器1初始化
 091A 95DD              xcall _timer1_init
 091C                   .dbline 747
 091C           ;       force_data_init();//应变片读取初始化
 091C 08DD              xcall _force_data_init
 091E                   .dbline 753
 091E           ;       
 091E           ;       
 091E           ;       //限位的配置
 091E           ;       
 091E           ;       //PE2=接近开关0，高阻态输入
 091E           ;       DDRE&=(~BIT(2));//DDRE2=0
 091E 1298              cbi 0x2,2
 0920                   .dbline 754
 0920           ;       PORTE&=(~BIT(2));//PORTE2=0
 0920 1A98              cbi 0x3,2
 0922                   .dbline 757
 0922           ;       
 0922           ;       //PE3=接近开关1，高阻态输入
 0922           ;       DDRE&=(~BIT(3));//DDRE2=0
 0922 1398              cbi 0x2,3
 0924                   .dbline 758
 0924           ;       PORTE&=(~BIT(3));//PORTE2=0
 0924 1B98              cbi 0x3,3
 0926                   .dbline 761
 0926           ;       
 0926           ;     //PE5=INT5=限位0，带上拉电阻输入
 0926           ;     DDRE&=(~BIT(5));//意思是DDRE5=0，其余位不变。但注意不可按注释的方式写！
 0926 1598              cbi 0x2,5
 0928                   .dbline 762
 0928           ;     PORTE|=BIT(5);//意思是PORTE5=1，其余位不变。但注意不可按注释的方式写！
 0928 1D9A              sbi 0x3,5
 092A                   .dbline 765
 092A           ;       
 092A           ;     //PE6=INT6=限位1，带上拉电阻输入
 092A           ;     DDRE&=(~BIT(6));
 092A 1698              cbi 0x2,6
 092C                   .dbline 766
 092C           ;     PORTE|=BIT(6);
 092C 1E9A              sbi 0x3,6
 092E                   .dbline 769
 092E           ; 
 092E           ;       //PE7=空夹，带上拉电阻输入
 092E           ;     DDRE&=(~BIT(7));
 092E 1798              cbi 0x2,7
 0930                   .dbline 770
 0930           ;     PORTE|=BIT(7);
 0930 1F9A              sbi 0x3,7
 0932                   .dbline 775
 0932           ;       
 0932           ;       
 0932           ;       //................[功能：上电后手指复位]....................................
 0932           ; 
 0932           ;     SREG |= 0X80;//打开全局中断
 0932 7894              bset 7
 0934                   .dbline 778
 0934           ;     
 0934           ;     //相关变量初始化
 0934           ;     cage0_state=0;
 0934 2224              clr R2
 0936 20921000          sts _cage0_state,R2
 093A                   .dbline 779
 093A           ;     cage1_state=0;
 093A 20920F00          sts _cage1_state,R2
 093E                   .dbline 782
 093E           ; 
 093E           ;     //命令舵机停止转动
 093E           ;     uart1_send_string((uchar*)no0stop,9);
 093E 29E0              ldi R18,9
 0940 00E0              ldi R16,<_no0stop
 0942 10E0              ldi R17,>_no0stop
 0944 91DC              xcall _uart1_send_string
 0946                   .dbline 783
 0946           ;       delay(50);
 0946 02E3              ldi R16,50
 0948 10E0              ldi R17,0
 094A 5ADB              xcall _delay
 094C                   .dbline 784
 094C           ;       uart1_send_string((uchar*)no1stop,9);
 094C 29E0              ldi R18,9
 094E 00E0              ldi R16,<_no1stop
 0950 10E0              ldi R17,>_no1stop
 0952 8ADC              xcall _uart1_send_string
 0954                   .dbline 785
 0954           ;     delay(50);
 0954 02E3              ldi R16,50
 0956 10E0              ldi R17,0
 0958 53DB              xcall _delay
 095A                   .dbline 788
 095A           ;       
 095A           ;     //使手爪松开
 095A           ;     uart1_send_string((uchar*)no0release,9);
 095A 29E0              ldi R18,9
 095C 00E0              ldi R16,<_no0release
 095E 10E0              ldi R17,>_no0release
 0960 83DC              xcall _uart1_send_string
 0962                   .dbline 789
 0962           ;       delay(50);
 0962 02E3              ldi R16,50
 0964 10E0              ldi R17,0
 0966 4CDB              xcall _delay
 0968                   .dbline 790
 0968           ;     uart1_send_string((uchar*)no1release,9);
 0968 29E0              ldi R18,9
 096A 00E0              ldi R16,<_no1release
 096C 10E0              ldi R17,>_no1release
 096E 7CDC              xcall _uart1_send_string
 0970 1CC0              xjmp L201
 0972           L200:
 0972                   .dbline 794
 0972           ; 
 0972           ;     //等待两端限位触发        
 0972           ;       while(cage_0|cage_1)
 0972           ;       {
 0972                   .dbline 795
 0972           ;           if(cage_0)
 0972 AA20              tst R10
 0974 61F0              breq L203
 0976           X52:
 0976                   .dbline 796
 0976           ;               {
 0976                   .dbline 797
 0976           ;           if(!(PINE & BIT(5)))//PE5=0进入
 0976 0D99              sbic 0x1,5
 0978 0AC0              rjmp L205
 097A           X53:
 097A                   .dbline 798
 097A           ;               {
 097A                   .dbline 799
 097A           ;                       delay(50);
 097A 02E3              ldi R16,50
 097C 10E0              ldi R17,0
 097E 40DB              xcall _delay
 0980                   .dbline 800
 0980           ;                               if(!(PINE & BIT(5)))
 0980 0D99              sbic 0x1,5
 0982 05C0              rjmp L207
 0984           X54:
 0984                   .dbline 801
 0984           ;                               {
 0984                   .dbline 802
 0984           ;                               uart1_send_string((uchar*)no0stop,9);
 0984 29E0              ldi R18,9
 0986 00E0              ldi R16,<_no0stop
 0988 10E0              ldi R17,>_no0stop
 098A 6EDC              xcall _uart1_send_string
 098C                   .dbline 804
 098C           ;                                       //uart0_send_string("zz30");
 098C           ;                                       cage_0=0;
 098C AA24              clr R10
 098E                   .dbline 805
 098E           ;                           }
 098E           L207:
 098E                   .dbline 807
 098E           ;                       
 098E           ;                   }
 098E           L205:
 098E                   .dbline 808
 098E           ;               }
 098E           L203:
 098E                   .dbline 810
 098E           ;               
 098E           ;           if(cage_1)
 098E CC20              tst R12
 0990 61F0              breq L209
 0992           X55:
 0992                   .dbline 811
 0992           ;               {
 0992                   .dbline 812
 0992           ;           if(!(PINE & BIT(6)))//PE6=0进入
 0992 0E99              sbic 0x1,6
 0994 0AC0              rjmp L211
 0996           X56:
 0996                   .dbline 813
 0996           ;               {
 0996                   .dbline 814
 0996           ;                       delay(50);
 0996 02E3              ldi R16,50
 0998 10E0              ldi R17,0
 099A 32DB              xcall _delay
 099C                   .dbline 815
 099C           ;                               if(!(PINE & BIT(6)))
 099C 0E99              sbic 0x1,6
 099E 05C0              rjmp L213
 09A0           X57:
 09A0                   .dbline 816
 09A0           ;                               {
 09A0                   .dbline 817
 09A0           ;                               uart1_send_string((uchar*)no1stop,9);
 09A0 29E0              ldi R18,9
 09A2 00E0              ldi R16,<_no1stop
 09A4 10E0              ldi R17,>_no1stop
 09A6 60DC              xcall _uart1_send_string
 09A8                   .dbline 819
 09A8           ;                                       //uart0_send_string("zz31");
 09A8           ;                                       cage_1=0;
 09A8 CC24              clr R12
 09AA                   .dbline 820
 09AA           ;                           }
 09AA           L213:
 09AA                   .dbline 822
 09AA           ;                       
 09AA           ;                   }
 09AA           L211:
 09AA                   .dbline 823
 09AA           ;               }
 09AA           L209:
 09AA                   .dbline 824
 09AA           ;       }
 09AA           L201:
 09AA                   .dbline 793
 09AA 2A2C              mov R2,R10
 09AC 2C28              or R2,R12
 09AE 09F7              brne L200
 09B0           X58:
 09B0                   .dbline 826
 09B0           ;       
 09B0           ;     uart0_send_string("zz00");//向上位机报告准备就绪
 09B0 00E0              ldi R16,<L215
 09B2 10E0              ldi R17,>L215
 09B4 EBDB              xcall _uart0_send_string
 09B6                   .dbline 828
 09B6           ;       
 09B6           ;       UCSR0B|=(1<<RXEN0)|(1<<RXCIE0);   //UART0接收使能，接收中断使能
 09B6 8AB1              in R24,0xa
 09B8 8069              ori R24,144
 09BA 8AB9              out 0xa,R24
 09BC EDC4              xjmp L217
 09BE           L216:
 09BE                   .dbline 834
 09BE           ;       
 09BE           ;       
 09BE           ; //........................[while(1)大循环]............................................
 09BE           ;       
 09BE           ;     while(1)
 09BE           ;       {
 09BE                   .dbline 835
 09BE           ;                if(uart0_instr_flag==1)
 09BE 80912900          lds R24,_uart0_instr_flag
 09C2 8130              cpi R24,1
 09C4 09F0              breq X127
 09C6 3EC4              xjmp L219
 09C8           X127:
 09C8           X59:
 09C8                   .dbline 836
 09C8           ;                {
 09C8                   .dbline 837
 09C8           ;                switch(gripper_mood)
 09C8 A0902700          lds R10,_gripper_mood
 09CC BB24              clr R11
 09CE AA20              tst R10
 09D0 11F4              brne X60
 09D2 BB20              tst R11
 09D4 61F0              breq L224
 09D6           X60:
 09D6 C501              movw R24,R10
 09D8 8130              cpi R24,1
 09DA E0E0              ldi R30,0
 09DC 9E07              cpc R25,R30
 09DE 09F4              brne X128
 09E0 5CC0              xjmp L231
 09E2           X128:
 09E2           X61:
 09E2 8230              cpi R24,2
 09E4 E0E0              ldi R30,0
 09E6 9E07              cpc R25,R30
 09E8 09F4              brne X129
 09EA 45C2              xjmp L346
 09EC           X129:
 09EC           X62:
 09EC DBC3              xjmp L222
 09EE           L224:
 09EE                   .dbline 840
 09EE           ;                    {
 09EE           ;                    case 0:
 09EE           ;                            {
 09EE                   .dbline 841
 09EE           ;                                if(array_cmp(uart0_instr,"0100")==0)
 09EE 20E0              ldi R18,<L227
 09F0 30E0              ldi R19,>L227
 09F2 00E0              ldi R16,<_uart0_instr
 09F4 10E0              ldi R17,>_uart0_instr
 09F6 63DC              xcall _array_cmp
 09F8 0030              cpi R16,0
 09FA 0107              cpc R16,R17
 09FC 09F0              breq X130
 09FE 38C0              xjmp L225
 0A00           X130:
 0A00           X63:
 0A00                   .dbline 842
 0A00           ;                                    {
 0A00                   .dbline 844
 0A00           ;                                        //uart0_send_string(" mood 0: enter 1-regular working mood! ");
 0A00           ;                                                gripper_mood=1;
 0A00 81E0              ldi R24,1
 0A02 80932700          sts _gripper_mood,R24
 0A06                   .dbline 845
 0A06           ;                                                ext_interrupt_init();//外部中断（夹持器与外部环境碰撞）初始化
 0A06 94DE              xcall _ext_interrupt_init
 0A08                   .dbline 849
 0A08           ;                                                //初始化后会立即出发一次INT0和INT1，所以报警允许变量需要先置0再置1
 0A08           ;                                                
 0A08           ;                                                //夹持器与外部碰撞报警（中断）允许变量
 0A08           ;                                                ext_collision_alert_allow_int0=1;//上侧
 0A08 81E0              ldi R24,1
 0A0A 80932A00          sts _ext_collision_alert_allow_int0,R24
 0A0E                   .dbline 850
 0A0E           ;                                                ext_collision_alert_allow_int1=1;//下侧
 0A0E 80932B00          sts _ext_collision_alert_allow_int1,R24
 0A12                   .dbline 851
 0A12           ;                                                ext_collision_alert_allow_int4=1;//指尖
 0A12 80932C00          sts _ext_collision_alert_allow_int4,R24
 0A16                   .dbline 855
 0A16           ; 
 0A16           ;                                                
 0A16           ;                                                //获取EEPROM中存储的RATIO值
 0A16           ;                                        command_data_read_finger_0_ratio_1(&com_finger0_ratio_1_PARA2,&com_finger0_ratio_1_PARA3);
 0A16 9E01              movw R18,R28
 0A18 2D5D              subi R18,221  ; offset = 35
 0A1A 3F4F              sbci R19,255
 0A1C 8E01              movw R16,R28
 0A1E 0E5D              subi R16,222  ; offset = 34
 0A20 1F4F              sbci R17,255
 0A22 B7DD              xcall _command_data_read_finger_0_ratio_1
 0A24                   .dbline 856
 0A24           ;                                                command_data_read_finger_0_ratio_2(&com_finger0_ratio_2_PARA2,&com_finger0_ratio_2_PARA3);
 0A24 9E01              movw R18,R28
 0A26 255D              subi R18,213  ; offset = 43
 0A28 3F4F              sbci R19,255
 0A2A 8E01              movw R16,R28
 0A2C 065D              subi R16,214  ; offset = 42
 0A2E 1F4F              sbci R17,255
 0A30 C7DD              xcall _command_data_read_finger_0_ratio_2
 0A32                   .dbline 857
 0A32           ;                                                command_data_read_finger_0_ratio_3(&com_finger0_ratio_3_PARA2,&com_finger0_ratio_3_PARA3);
 0A32 9E01              movw R18,R28
 0A34 2B5D              subi R18,219  ; offset = 37
 0A36 3F4F              sbci R19,255
 0A38 8E01              movw R16,R28
 0A3A 0C5D              subi R16,220  ; offset = 36
 0A3C 1F4F              sbci R17,255
 0A3E D7DD              xcall _command_data_read_finger_0_ratio_3
 0A40                   .dbline 858
 0A40           ;                                                command_data_read_finger_1_ratio_1(&com_finger1_ratio_1_PARA2,&com_finger1_ratio_1_PARA3);
 0A40 9E01              movw R18,R28
 0A42 295D              subi R18,217  ; offset = 39
 0A44 3F4F              sbci R19,255
 0A46 8E01              movw R16,R28
 0A48 0A5D              subi R16,218  ; offset = 38
 0A4A 1F4F              sbci R17,255
 0A4C 2CDE              xcall _command_data_read_finger_1_ratio_1
 0A4E                   .dbline 859
 0A4E           ;                                                command_data_read_finger_1_ratio_2(&com_finger1_ratio_2_PARA2,&com_finger1_ratio_2_PARA3);
 0A4E 9E01              movw R18,R28
 0A50 235D              subi R18,211  ; offset = 45
 0A52 3F4F              sbci R19,255
 0A54 8E01              movw R16,R28
 0A56 045D              subi R16,212  ; offset = 44
 0A58 1F4F              sbci R17,255
 0A5A 3CDE              xcall _command_data_read_finger_1_ratio_2
 0A5C                   .dbline 860
 0A5C           ;                                                command_data_read_finger_1_ratio_3(&com_finger1_ratio_3_PARA2,&com_finger1_ratio_3_PARA3);
 0A5C 9E01              movw R18,R28
 0A5E 275D              subi R18,215  ; offset = 41
 0A60 3F4F              sbci R19,255
 0A62 8E01              movw R16,R28
 0A64 085D              subi R16,216  ; offset = 40
 0A66 1F4F              sbci R17,255
 0A68 4CDE              xcall _command_data_read_finger_1_ratio_3
 0A6A                   .dbline 863
 0A6A           ;       
 0A6A           ;                                                //获取EEPROM中存储的夹紧力阈值有效值高八位
 0A6A           ;                                                command_data_read_force_high8(&force_judge);
 0A6A 00E0              ldi R16,<_force_judge
 0A6C 10E0              ldi R17,>_force_judge
 0A6E DEDC              xcall _command_data_read_force_high8
 0A70                   .dbline 866
 0A70           ;                                                
 0A70           ;       
 0A70           ;                                    }
 0A70           L225:
 0A70                   .dbline 868
 0A70           ;                                
 0A70           ;                                        if(array_cmp(uart0_instr,"0200")==0)
 0A70 20E0              ldi R18,<L230
 0A72 30E0              ldi R19,>L230
 0A74 00E0              ldi R16,<_uart0_instr
 0A76 10E0              ldi R17,>_uart0_instr
 0A78 22DC              xcall _array_cmp
 0A7A 0030              cpi R16,0
 0A7C 0107              cpc R16,R17
 0A7E 09F0              breq X131
 0A80 91C3              xjmp L222
 0A82           X131:
 0A82           X64:
 0A82                   .dbline 869
 0A82           ;                                        {
 0A82                   .dbline 871
 0A82           ;                                        //uart0_send_string(" mood 0: enter 2-configuration mood! ");
 0A82           ;                                                gripper_mood=2;
 0A82 82E0              ldi R24,2
 0A84 80932700          sts _gripper_mood,R24
 0A88                   .dbline 872
 0A88           ;                                                ext_interrupt_init();//外部中断（夹持器与外部环境碰撞）初始化
 0A88 53DE              xcall _ext_interrupt_init
 0A8A                   .dbline 876
 0A8A           ;                                                //初始化后会立即出发一次INT0和INT1，所以报警允许变量需要先置0再置1
 0A8A           ;                                                
 0A8A           ;                                                //夹持器与外部碰撞报警（中断）允许变量
 0A8A           ;                                                ext_collision_alert_allow_int0=1;//上侧
 0A8A 81E0              ldi R24,1
 0A8C 80932A00          sts _ext_collision_alert_allow_int0,R24
 0A90                   .dbline 877
 0A90           ;                                                ext_collision_alert_allow_int1=1;//下侧
 0A90 80932B00          sts _ext_collision_alert_allow_int1,R24
 0A94                   .dbline 878
 0A94           ;                                                ext_collision_alert_allow_int4=1;//指尖
 0A94 80932C00          sts _ext_collision_alert_allow_int4,R24
 0A98                   .dbline 879
 0A98           ;                                        }
 0A98                   .dbline 881
 0A98           ;                                
 0A98           ;                                        break;
 0A98 85C3              xjmp L222
 0A9A           L231:
 0A9A                   .dbline 885
 0A9A           ;                            }
 0A9A           ;                        
 0A9A           ;                        case 1:
 0A9A           ;                            {
 0A9A                   .dbline 886
 0A9A           ;                                if(array_cmp(uart0_instr,"1000")==0)//调试模式・读取EEPROM中存储的RATIO和力阈值
 0A9A 20E0              ldi R18,<L234
 0A9C 30E0              ldi R19,>L234
 0A9E 00E0              ldi R16,<_uart0_instr
 0AA0 10E0              ldi R17,>_uart0_instr
 0AA2 0DDC              xcall _array_cmp
 0AA4 5801              movw R10,R16
 0AA6 0030              cpi R16,0
 0AA8 0107              cpc R16,R17
 0AAA 09F0              breq X132
 0AAC 56C0              xjmp L232
 0AAE           X132:
 0AAE           X65:
 0AAE                   .dbline 887
 0AAE           ;                                        {
 0AAE                   .dbline 891
 0AAE           ;                                                //更新ratio变量值、力阈值和消息数组的值
 0AAE           ;                                                
 0AAE           ;                                                //获取EEPROM中存储的RATIO值
 0AAE           ;                                        command_data_read_finger_0_ratio_1(&com_finger0_ratio_1_PARA2,&com_finger0_ratio_1_PARA3);
 0AAE 9E01              movw R18,R28
 0AB0 2D5D              subi R18,221  ; offset = 35
 0AB2 3F4F              sbci R19,255
 0AB4 8E01              movw R16,R28
 0AB6 0E5D              subi R16,222  ; offset = 34
 0AB8 1F4F              sbci R17,255
 0ABA 6BDD              xcall _command_data_read_finger_0_ratio_1
 0ABC                   .dbline 892
 0ABC           ;                                                command_data_read_finger_0_ratio_2(&com_finger0_ratio_2_PARA2,&com_finger0_ratio_2_PARA3);
 0ABC 9E01              movw R18,R28
 0ABE 255D              subi R18,213  ; offset = 43
 0AC0 3F4F              sbci R19,255
 0AC2 8E01              movw R16,R28
 0AC4 065D              subi R16,214  ; offset = 42
 0AC6 1F4F              sbci R17,255
 0AC8 7BDD              xcall _command_data_read_finger_0_ratio_2
 0ACA                   .dbline 893
 0ACA           ;                                                command_data_read_finger_0_ratio_3(&com_finger0_ratio_3_PARA2,&com_finger0_ratio_3_PARA3);
 0ACA 9E01              movw R18,R28
 0ACC 2B5D              subi R18,219  ; offset = 37
 0ACE 3F4F              sbci R19,255
 0AD0 8E01              movw R16,R28
 0AD2 0C5D              subi R16,220  ; offset = 36
 0AD4 1F4F              sbci R17,255
 0AD6 8BDD              xcall _command_data_read_finger_0_ratio_3
 0AD8                   .dbline 894
 0AD8           ;                                                command_data_read_finger_1_ratio_1(&com_finger1_ratio_1_PARA2,&com_finger1_ratio_1_PARA3);
 0AD8 9E01              movw R18,R28
 0ADA 295D              subi R18,217  ; offset = 39
 0ADC 3F4F              sbci R19,255
 0ADE 8E01              movw R16,R28
 0AE0 0A5D              subi R16,218  ; offset = 38
 0AE2 1F4F              sbci R17,255
 0AE4 E0DD              xcall _command_data_read_finger_1_ratio_1
 0AE6                   .dbline 895
 0AE6           ;                                                command_data_read_finger_1_ratio_2(&com_finger1_ratio_2_PARA2,&com_finger1_ratio_2_PARA3);
 0AE6 9E01              movw R18,R28
 0AE8 235D              subi R18,211  ; offset = 45
 0AEA 3F4F              sbci R19,255
 0AEC 8E01              movw R16,R28
 0AEE 045D              subi R16,212  ; offset = 44
 0AF0 1F4F              sbci R17,255
 0AF2 F0DD              xcall _command_data_read_finger_1_ratio_2
 0AF4                   .dbline 896
 0AF4           ;                                                command_data_read_finger_1_ratio_3(&com_finger1_ratio_3_PARA2,&com_finger1_ratio_3_PARA3);
 0AF4 9E01              movw R18,R28
 0AF6 275D              subi R18,215  ; offset = 41
 0AF8 3F4F              sbci R19,255
 0AFA 8E01              movw R16,R28
 0AFC 085D              subi R16,216  ; offset = 40
 0AFE 1F4F              sbci R17,255
 0B00 00DE              xcall _command_data_read_finger_1_ratio_3
 0B02                   .dbline 898
 0B02           ;       
 0B02           ;                                                msg_eeprom_array[0]='z';
 0B02 8AE7              ldi R24,122
 0B04 8887              std y+8,R24
 0B06                   .dbline 899
 0B06           ;                                                msg_eeprom_array[1]='z';
 0B06 8987              std y+9,R24
 0B08                   .dbline 900
 0B08           ;                                                msg_eeprom_array[2]='3';
 0B08 83E3              ldi R24,51
 0B0A 8A87              std y+10,R24
 0B0C                   .dbline 901
 0B0C           ;                                                msg_eeprom_array[3]='3';
 0B0C 8B87              std y+11,R24
 0B0E                   .dbline 902
 0B0E           ;                                                msg_eeprom_array[4]=com_finger0_ratio_1_PARA2;
 0B0E 2AA0              ldd R2,y+34
 0B10 2C86              std y+12,R2
 0B12                   .dbline 903
 0B12           ;                                                msg_eeprom_array[5]=com_finger0_ratio_1_PARA3;
 0B12 2BA0              ldd R2,y+35
 0B14 2D86              std y+13,R2
 0B16                   .dbline 904
 0B16           ;                                                msg_eeprom_array[6]=com_finger0_ratio_2_PARA2;
 0B16 2AA4              ldd R2,y+42
 0B18 2E86              std y+14,R2
 0B1A                   .dbline 905
 0B1A           ;                                                msg_eeprom_array[7]=com_finger0_ratio_2_PARA3;
 0B1A 2BA4              ldd R2,y+43
 0B1C 2F86              std y+15,R2
 0B1E                   .dbline 906
 0B1E           ;                                                msg_eeprom_array[8]=com_finger0_ratio_3_PARA2;
 0B1E 2CA0              ldd R2,y+36
 0B20 288A              std y+16,R2
 0B22                   .dbline 907
 0B22           ;                                                msg_eeprom_array[9]=com_finger0_ratio_3_PARA3;
 0B22 2DA0              ldd R2,y+37
 0B24 298A              std y+17,R2
 0B26                   .dbline 908
 0B26           ;                                                msg_eeprom_array[10]=com_finger1_ratio_1_PARA2;
 0B26 2EA0              ldd R2,y+38
 0B28 2A8A              std y+18,R2
 0B2A                   .dbline 909
 0B2A           ;                                                msg_eeprom_array[11]=com_finger1_ratio_1_PARA3;
 0B2A 2FA0              ldd R2,y+39
 0B2C 2B8A              std y+19,R2
 0B2E                   .dbline 910
 0B2E           ;                                                msg_eeprom_array[12]=com_finger1_ratio_2_PARA2;
 0B2E 2CA4              ldd R2,y+44
 0B30 2C8A              std y+20,R2
 0B32                   .dbline 911
 0B32           ;                                                msg_eeprom_array[13]=com_finger1_ratio_2_PARA3;
 0B32 2DA4              ldd R2,y+45
 0B34 2D8A              std y+21,R2
 0B36                   .dbline 912
 0B36           ;                                                msg_eeprom_array[14]=com_finger1_ratio_3_PARA2;
 0B36 28A4              ldd R2,y+40
 0B38 2E8A              std y+22,R2
 0B3A                   .dbline 913
 0B3A           ;                                                msg_eeprom_array[15]=com_finger1_ratio_3_PARA3;
 0B3A 29A4              ldd R2,y+41
 0B3C 2F8A              std y+23,R2
 0B3E                   .dbline 916
 0B3E           ;       
 0B3E           ;                                                //获取EEPROM中存储的夹紧力阈值有效值高八位
 0B3E           ;                                                command_data_read_force_high8(&force_judge);
 0B3E 00E0              ldi R16,<_force_judge
 0B40 10E0              ldi R17,>_force_judge
 0B42 74DC              xcall _command_data_read_force_high8
 0B44                   .dbline 917
 0B44           ;                                                msg_eeprom_array[16]=force_judge;
 0B44 20900700          lds R2,_force_judge
 0B48 288E              std y+24,R2
 0B4A                   .dbline 919
 0B4A           ;                                                
 0B4A           ;                                                delay(50);
 0B4A 02E3              ldi R16,50
 0B4C 10E0              ldi R17,0
 0B4E 58DA              xcall _delay
 0B50                   .dbline 920
 0B50           ;                                                uart0_send_string_with_num(msg_eeprom_array,17);//上传EEPROM中存储的数值
 0B50 21E1              ldi R18,17
 0B52 8E01              movw R16,R28
 0B54 085F              subi R16,248  ; offset = 8
 0B56 1F4F              sbci R17,255
 0B58 2DDB              xcall _uart0_send_string_with_num
 0B5A                   .dbline 922
 0B5A           ;       
 0B5A           ;                                        }
 0B5A           L232:
 0B5A                   .dbline 925
 0B5A           ;       
 0B5A           ;                                        
 0B5A           ;                                        if(array_cmp(uart0_instr,"1100")==0)//松开
 0B5A 20E0              ldi R18,<L253
 0B5C 30E0              ldi R19,>L253
 0B5E 00E0              ldi R16,<_uart0_instr
 0B60 10E0              ldi R17,>_uart0_instr
 0B62 ADDB              xcall _array_cmp
 0B64 5801              movw R10,R16
 0B66 0030              cpi R16,0
 0B68 0107              cpc R16,R17
 0B6A 09F0              breq X133
 0B6C 35C0              xjmp L251
 0B6E           X133:
 0B6E           X66:
 0B6E                   .dbline 926
 0B6E           ;                                        {
 0B6E                   .dbline 927
 0B6E           ;                                        if(release_allow_motor_0)
 0B6E 0BA8              ldd R0,y+51
 0B70 0020              tst R0
 0B72 B9F0              breq L254
 0B74           X67:
 0B74                   .dbline 928
 0B74           ;                                                {
 0B74                   .dbline 930
 0B74           ;                                                    //构造舵机指令
 0B74           ;                                                        motor_command[2]=0x00;//ID=0
 0B74 2224              clr R2
 0B76 2B8E              std y+27,R2
 0B78                   .dbline 931
 0B78           ;                                                        motor_command[6]=com_finger0_ratio_3_PARA2;
 0B78 2CA0              ldd R2,y+36
 0B7A 2F8E              std y+31,R2
 0B7C                   .dbline 932
 0B7C           ;                                                        motor_command[7]=com_finger0_ratio_3_PARA3+0x04;
 0B7C 8DA1              ldd R24,y+37
 0B7E 8C5F              subi R24,252    ; addi 4
 0B80 88A3              std y+32,R24
 0B82                   .dbline 933
 0B82           ;                                                        CHECK=ratio_command_check(0,com_finger0_ratio_3_PARA2,com_finger0_ratio_3_PARA3+0x04);
 0B82 8DA1              ldd R24,y+37
 0B84 8C5F              subi R24,252    ; addi 4
 0B86 8883              std y+0,R24
 0B88 2CA1              ldd R18,y+36
 0B8A 0027              clr R16
 0B8C B2DC              xcall _ratio_command_check
 0B8E A02E              mov R10,R16
 0B90                   .dbline 934
 0B90           ;                                                        motor_command[8]=CHECK;
 0B90 A9A2              std y+33,R10
 0B92                   .dbline 935
 0B92           ;                                                        delay(50);
 0B92 02E3              ldi R16,50
 0B94 10E0              ldi R17,0
 0B96 34DA              xcall _delay
 0B98                   .dbline 936
 0B98           ;                                                        uart1_send_string(motor_command,9);//下发指令
 0B98 29E0              ldi R18,9
 0B9A 8E01              movw R16,R28
 0B9C 075E              subi R16,231  ; offset = 25
 0B9E 1F4F              sbci R17,255
 0BA0 63DB              xcall _uart1_send_string
 0BA2                   .dbline 937
 0BA2           ;                                                }
 0BA2           L254:
 0BA2                   .dbline 939
 0BA2           ;                                                
 0BA2           ;                                                if(release_allow_motor_1)
 0BA2 0CA8              ldd R0,y+52
 0BA4 0020              tst R0
 0BA6 C1F0              breq L260
 0BA8           X68:
 0BA8                   .dbline 940
 0BA8           ;                                                {
 0BA8                   .dbline 942
 0BA8           ;                                                    //构造舵机指令
 0BA8           ;                                                        motor_command[2]=0x01;//ID=1
 0BA8 81E0              ldi R24,1
 0BAA 8B8F              std y+27,R24
 0BAC                   .dbline 943
 0BAC           ;                                                        motor_command[6]=com_finger1_ratio_3_PARA2;
 0BAC 28A4              ldd R2,y+40
 0BAE 2F8E              std y+31,R2
 0BB0                   .dbline 944
 0BB0           ;                                                        motor_command[7]=com_finger1_ratio_3_PARA3+0x04;
 0BB0 89A5              ldd R24,y+41
 0BB2 8C5F              subi R24,252    ; addi 4
 0BB4 88A3              std y+32,R24
 0BB6                   .dbline 945
 0BB6           ;                                                        CHECK=ratio_command_check(1,com_finger1_ratio_3_PARA2,com_finger1_ratio_3_PARA3+0x04);
 0BB6 89A5              ldd R24,y+41
 0BB8 8C5F              subi R24,252    ; addi 4
 0BBA 8883              std y+0,R24
 0BBC 28A5              ldd R18,y+40
 0BBE 01E0              ldi R16,1
 0BC0 98DC              xcall _ratio_command_check
 0BC2 C02E              mov R12,R16
 0BC4 AC2C              mov R10,R12
 0BC6                   .dbline 946
 0BC6           ;                                                        motor_command[8]=CHECK;
 0BC6 A9A2              std y+33,R10
 0BC8                   .dbline 947
 0BC8           ;                                                        delay(50);
 0BC8 02E3              ldi R16,50
 0BCA 10E0              ldi R17,0
 0BCC 19DA              xcall _delay
 0BCE                   .dbline 948
 0BCE           ;                                                        uart1_send_string(motor_command,9);//下发指令
 0BCE 29E0              ldi R18,9
 0BD0 8E01              movw R16,R28
 0BD2 075E              subi R16,231  ; offset = 25
 0BD4 1F4F              sbci R17,255
 0BD6 48DB              xcall _uart1_send_string
 0BD8                   .dbline 949
 0BD8           ;                                                }
 0BD8           L260:
 0BD8                   .dbline 950
 0BD8           ;                                        }
 0BD8           L251:
 0BD8                   .dbline 952
 0BD8           ;                                
 0BD8           ;                                        if(array_cmp(uart0_instr,"1200")==0)//夹紧
 0BD8 20E0              ldi R18,<L268
 0BDA 30E0              ldi R19,>L268
 0BDC 00E0              ldi R16,<_uart0_instr
 0BDE 10E0              ldi R17,>_uart0_instr
 0BE0 6EDB              xcall _array_cmp
 0BE2 6801              movw R12,R16
 0BE4 0030              cpi R16,0
 0BE6 0107              cpc R16,R17
 0BE8 09F0              breq X134
 0BEA C0C0              xjmp L266
 0BEC           X134:
 0BEC           X69:
 0BEC                   .dbline 953
 0BEC           ;                                        {
 0BEC                   .dbline 954
 0BEC           ;                                        if(hold_allow_motor_0 & hold_allow_motor_1)
 0BEC 29A8              ldd R2,y+49
 0BEE 0AA8              ldd R0,y+50
 0BF0 2020              and R2,R0
 0BF2 09F4              brne X135
 0BF4 BBC0              xjmp L269
 0BF6           X135:
 0BF6           X70:
 0BF6                   .dbline 955
 0BF6           ;                                                {
 0BF6                   .dbline 958
 0BF6           ;                                                    //第一阶段
 0BF6           ;                                                        //构造舵机指令
 0BF6           ;                                                        motor_command[2]=0x00;//ID=0
 0BF6 2224              clr R2
 0BF8 2B8E              std y+27,R2
 0BFA                   .dbline 959
 0BFA           ;                                                        motor_command[6]=com_finger0_ratio_1_PARA2;
 0BFA 2AA0              ldd R2,y+34
 0BFC 2F8E              std y+31,R2
 0BFE                   .dbline 960
 0BFE           ;                                                        motor_command[7]=com_finger0_ratio_1_PARA3;
 0BFE 2BA0              ldd R2,y+35
 0C00 28A2              std y+32,R2
 0C02                   .dbline 961
 0C02           ;                                                        CHECK=ratio_command_check(0,com_finger0_ratio_1_PARA2,com_finger0_ratio_1_PARA3);
 0C02 2BA0              ldd R2,y+35
 0C04 2882              std y+0,R2
 0C06 2AA1              ldd R18,y+34
 0C08 0027              clr R16
 0C0A 73DC              xcall _ratio_command_check
 0C0C C02E              mov R12,R16
 0C0E AC2C              mov R10,R12
 0C10                   .dbline 962
 0C10           ;                                                        motor_command[8]=CHECK;
 0C10 A9A2              std y+33,R10
 0C12                   .dbline 963
 0C12           ;                                                        delay(50);
 0C12 02E3              ldi R16,50
 0C14 10E0              ldi R17,0
 0C16 F4D9              xcall _delay
 0C18                   .dbline 964
 0C18           ;                                                        uart1_send_string(motor_command,9);//下发指令
 0C18 29E0              ldi R18,9
 0C1A 8E01              movw R16,R28
 0C1C 075E              subi R16,231  ; offset = 25
 0C1E 1F4F              sbci R17,255
 0C20 23DB              xcall _uart1_send_string
 0C22                   .dbline 967
 0C22           ;                                                        
 0C22           ;                                                        //构造舵机指令
 0C22           ;                                                        motor_command[2]=0x01;//ID=1
 0C22 81E0              ldi R24,1
 0C24 8B8F              std y+27,R24
 0C26                   .dbline 968
 0C26           ;                                                        motor_command[6]=com_finger1_ratio_1_PARA2;
 0C26 2EA0              ldd R2,y+38
 0C28 2F8E              std y+31,R2
 0C2A                   .dbline 969
 0C2A           ;                                                        motor_command[7]=com_finger1_ratio_1_PARA3;
 0C2A 2FA0              ldd R2,y+39
 0C2C 28A2              std y+32,R2
 0C2E                   .dbline 970
 0C2E           ;                                                        CHECK=ratio_command_check(1,com_finger1_ratio_1_PARA2,com_finger1_ratio_1_PARA3);
 0C2E 2FA0              ldd R2,y+39
 0C30 2882              std y+0,R2
 0C32 2EA1              ldd R18,y+38
 0C34 01E0              ldi R16,1
 0C36 5DDC              xcall _ratio_command_check
 0C38 C02E              mov R12,R16
 0C3A AC2C              mov R10,R12
 0C3C                   .dbline 971
 0C3C           ;                                                        motor_command[8]=CHECK;
 0C3C A9A2              std y+33,R10
 0C3E                   .dbline 972
 0C3E           ;                                                        delay(50);
 0C3E 02E3              ldi R16,50
 0C40 10E0              ldi R17,0
 0C42 DED9              xcall _delay
 0C44                   .dbline 973
 0C44           ;                                                        uart1_send_string(motor_command,9);//下发指令
 0C44 29E0              ldi R18,9
 0C46 8E01              movw R16,R28
 0C48 075E              subi R16,231  ; offset = 25
 0C4A 1F4F              sbci R17,255
 0C4C 0DDB              xcall _uart1_send_string
 0C4E                   .dbline 975
 0C4E           ;       
 0C4E           ;                                                        approach_0=1;
 0C4E CC24              clr R12
 0C50 C394              inc R12
 0C52                   .dbline 976
 0C52           ;                                                        approach_1=1;
 0C52 EE24              clr R14
 0C54 E394              inc R14
 0C56 1CC0              xjmp L280
 0C58           L279:
 0C58                   .dbline 980
 0C58           ;                                                        
 0C58           ;                                                        //等接近开关触发，同时查询检测是否空夹
 0C58           ;                                                        while((approach_0|approach_1)&&(PINE & BIT(7)))
 0C58           ;                                                        {
 0C58                   .dbline 981
 0C58           ;                                                            if(approach_0)
 0C58 CC20              tst R12
 0C5A 61F0              breq L282
 0C5C           X71:
 0C5C                   .dbline 982
 0C5C           ;                                                                {
 0C5C                   .dbline 983
 0C5C           ;                                                                    if(!(PINE & BIT(2)))//PE2=0进入
 0C5C 0A99              sbic 0x1,2
 0C5E 0AC0              rjmp L284
 0C60           X72:
 0C60                   .dbline 984
 0C60           ;                                                                        {
 0C60                   .dbline 985
 0C60           ;                                                                    delay(50);
 0C60 02E3              ldi R16,50
 0C62 10E0              ldi R17,0
 0C64 CDD9              xcall _delay
 0C66                   .dbline 986
 0C66           ;                                                                                if(!(PINE & BIT(2)))
 0C66 0A99              sbic 0x1,2
 0C68 05C0              rjmp L286
 0C6A           X73:
 0C6A                   .dbline 987
 0C6A           ;                                                                                {
 0C6A                   .dbline 988
 0C6A           ;                                                                            uart1_send_string((uchar*)no0stop,9);
 0C6A 29E0              ldi R18,9
 0C6C 00E0              ldi R16,<_no0stop
 0C6E 10E0              ldi R17,>_no0stop
 0C70 FBDA              xcall _uart1_send_string
 0C72                   .dbline 990
 0C72           ;                                                                                        //uart0_send_string(" interrupt 5 ");
 0C72           ;                                                                                        approach_0=0;
 0C72 CC24              clr R12
 0C74                   .dbline 991
 0C74           ;                                                                        }
 0C74           L286:
 0C74                   .dbline 993
 0C74           ;                       
 0C74           ;                                                                }
 0C74           L284:
 0C74                   .dbline 994
 0C74           ;                                                                }
 0C74           L282:
 0C74                   .dbline 996
 0C74           ;               
 0C74           ;                                                        if(approach_1)
 0C74 EE20              tst R14
 0C76 61F0              breq L288
 0C78           X74:
 0C78                   .dbline 997
 0C78           ;                                                                {
 0C78                   .dbline 998
 0C78           ;                                                    if(!(PINE & BIT(3)))//PE3=0进入
 0C78 0B99              sbic 0x1,3
 0C7A 0AC0              rjmp L290
 0C7C           X75:
 0C7C                   .dbline 999
 0C7C           ;                                                                {
 0C7C                   .dbline 1000
 0C7C           ;                                                                 delay(50);
 0C7C 02E3              ldi R16,50
 0C7E 10E0              ldi R17,0
 0C80 BFD9              xcall _delay
 0C82                   .dbline 1001
 0C82           ;                                                                                 if(!(PINE & BIT(3)))
 0C82 0B99              sbic 0x1,3
 0C84 05C0              rjmp L292
 0C86           X76:
 0C86                   .dbline 1002
 0C86           ;                                                                                 {
 0C86                   .dbline 1003
 0C86           ;                                                                         uart1_send_string((uchar*)no1stop,9);
 0C86 29E0              ldi R18,9
 0C88 00E0              ldi R16,<_no1stop
 0C8A 10E0              ldi R17,>_no1stop
 0C8C EDDA              xcall _uart1_send_string
 0C8E                   .dbline 1005
 0C8E           ;                                                                                         //uart0_send_string(" interrupt 6 ");
 0C8E           ;                                                                                         approach_1=0;
 0C8E EE24              clr R14
 0C90                   .dbline 1006
 0C90           ;                                                                 }
 0C90           L292:
 0C90                   .dbline 1007
 0C90           ;                                                            }
 0C90           L290:
 0C90                   .dbline 1008
 0C90           ;                                                                }
 0C90           L288:
 0C90                   .dbline 1009
 0C90           ;                                                        }
 0C90           L280:
 0C90                   .dbline 979
 0C90 2C2C              mov R2,R12
 0C92 2E28              or R2,R14
 0C94 11F0              breq L294
 0C96           X77:
 0C96 0F99              sbic 0x1,7
 0C98 DFCF              rjmp L279
 0C9A           X78:
 0C9A           L294:
 0C9A                   .dbline 1011
 0C9A           ;                                                        
 0C9A           ;                                                        if(PINE & BIT(7))//不空夹则进行第二阶段
 0C9A 0F9B              sbis 0x1,7
 0C9C 67C0              rjmp L295
 0C9E           X79:
 0C9E                   .dbline 1012
 0C9E           ;                                                        {
 0C9E                   .dbline 1015
 0C9E           ;                                                           //第二阶段
 0C9E           ;                                                               //构造舵机指令
 0C9E           ;                                                               motor_command[2]=0x00;//ID=0
 0C9E 2224              clr R2
 0CA0 2B8E              std y+27,R2
 0CA2                   .dbline 1016
 0CA2           ;                                                               motor_command[6]=com_finger0_ratio_2_PARA2;
 0CA2 2AA4              ldd R2,y+42
 0CA4 2F8E              std y+31,R2
 0CA6                   .dbline 1017
 0CA6           ;                                                               motor_command[7]=com_finger0_ratio_2_PARA3;
 0CA6 2BA4              ldd R2,y+43
 0CA8 28A2              std y+32,R2
 0CAA                   .dbline 1018
 0CAA           ;                                                               CHECK=ratio_command_check(0,com_finger0_ratio_2_PARA2,com_finger0_ratio_2_PARA3);
 0CAA 2BA4              ldd R2,y+43
 0CAC 2882              std y+0,R2
 0CAE 2AA5              ldd R18,y+42
 0CB0 0027              clr R16
 0CB2 1FDC              xcall _ratio_command_check
 0CB4 C02E              mov R12,R16
 0CB6 AC2C              mov R10,R12
 0CB8                   .dbline 1019
 0CB8           ;                                                               motor_command[8]=CHECK;
 0CB8 A9A2              std y+33,R10
 0CBA                   .dbline 1020
 0CBA           ;                                                               delay(50);
 0CBA 02E3              ldi R16,50
 0CBC 10E0              ldi R17,0
 0CBE A0D9              xcall _delay
 0CC0                   .dbline 1021
 0CC0           ;                                                               uart1_send_string(motor_command,9);//下发指令
 0CC0 29E0              ldi R18,9
 0CC2 8E01              movw R16,R28
 0CC4 075E              subi R16,231  ; offset = 25
 0CC6 1F4F              sbci R17,255
 0CC8 CFDA              xcall _uart1_send_string
 0CCA                   .dbline 1024
 0CCA           ;                                                        
 0CCA           ;                                                               //构造舵机指令
 0CCA           ;                                                                motor_command[2]=0x01;//ID=1
 0CCA 81E0              ldi R24,1
 0CCC 8B8F              std y+27,R24
 0CCE                   .dbline 1025
 0CCE           ;                                                                motor_command[6]=com_finger1_ratio_2_PARA2;
 0CCE 2CA4              ldd R2,y+44
 0CD0 2F8E              std y+31,R2
 0CD2                   .dbline 1026
 0CD2           ;                                                                motor_command[7]=com_finger1_ratio_2_PARA3;
 0CD2 2DA4              ldd R2,y+45
 0CD4 28A2              std y+32,R2
 0CD6                   .dbline 1027
 0CD6           ;                                                                CHECK=ratio_command_check(1,com_finger1_ratio_2_PARA2,com_finger1_ratio_2_PARA3);
 0CD6 2DA4              ldd R2,y+45
 0CD8 2882              std y+0,R2
 0CDA 2CA5              ldd R18,y+44
 0CDC 01E0              ldi R16,1
 0CDE 09DC              xcall _ratio_command_check
 0CE0 C02E              mov R12,R16
 0CE2 AC2C              mov R10,R12
 0CE4                   .dbline 1028
 0CE4           ;                                                                motor_command[8]=CHECK;
 0CE4 A9A2              std y+33,R10
 0CE6                   .dbline 1029
 0CE6           ;                                                                delay(50);
 0CE6 02E3              ldi R16,50
 0CE8 10E0              ldi R17,0
 0CEA 8AD9              xcall _delay
 0CEC                   .dbline 1030
 0CEC           ;                                                                uart1_send_string(motor_command,9);//下发指令
 0CEC 29E0              ldi R18,9
 0CEE 8E01              movw R16,R28
 0CF0 075E              subi R16,231  ; offset = 25
 0CF2 1F4F              sbci R17,255
 0CF4 B9DA              xcall _uart1_send_string
 0CF6                   .dbline 1033
 0CF6           ;                                                        
 0CF6           ;                                                                //等待夹紧力达到阈值并继续判断是否空夹
 0CF6           ;                                                                force_high8=0;
 0CF6 2224              clr R2
 0CF8 20920800          sts _force_high8,R2
 0CFC                   .dbline 1034
 0CFC           ;                                                                hold_stage_2_continue=1;
 0CFC 0024              clr R0
 0CFE 0394              inc R0
 0D00 0DAA              std y+53,R0
 0D02 2FC0              xjmp L306
 0D04           L305:
 0D04                   .dbline 1036
 0D04           ;                                                                while(hold_stage_2_continue && (PINE & BIT(7)))
 0D04           ;                                                                {
 0D04                   .dbline 1037
 0D04           ;                                                                    force_ulong=ReadCount();
 0D04 40DB              xcall _ReadCount
 0D06 10930400          sts _force_ulong+1,R17
 0D0A 00930300          sts _force_ulong,R16
 0D0E 30930600          sts _force_ulong+2+1,R19
 0D12 20930500          sts _force_ulong+2,R18
 0D16                   .dbline 1038
 0D16           ;                                                                        ulong_to_uchar_array(force_ulong);//目的是获取force_high8
 0D16 0FDB              xcall _ulong_to_uchar_array
 0D18                   .dbline 1039
 0D18           ;                                                                        if(force_high8>=force_judge)
 0D18 20900700          lds R2,_force_judge
 0D1C 30900800          lds R3,_force_high8
 0D20 3214              cp R3,R2
 0D22 F8F0              brlo L308
 0D24           X80:
 0D24                   .dbline 1040
 0D24           ;                                                                        {
 0D24                   .dbline 1041
 0D24           ;                                                                            hold_stage_2_continue=0;//下次循环跳出
 0D24 0024              clr R0
 0D26 0DAA              std y+53,R0
 0D28                   .dbline 1044
 0D28           ;                                                                                
 0D28           ;                                                                                //停止舵机运行
 0D28           ;                                                                                delay(50);
 0D28 02E3              ldi R16,50
 0D2A 10E0              ldi R17,0
 0D2C 69D9              xcall _delay
 0D2E                   .dbline 1045
 0D2E           ;                                                                                uart1_send_string((uchar*)no0stop,9);
 0D2E 29E0              ldi R18,9
 0D30 00E0              ldi R16,<_no0stop
 0D32 10E0              ldi R17,>_no0stop
 0D34 99DA              xcall _uart1_send_string
 0D36                   .dbline 1046
 0D36           ;                                                                                delay(50);
 0D36 02E3              ldi R16,50
 0D38 10E0              ldi R17,0
 0D3A 62D9              xcall _delay
 0D3C                   .dbline 1047
 0D3C           ;                                                                                uart1_send_string((uchar*)no1stop,9);
 0D3C 29E0              ldi R18,9
 0D3E 00E0              ldi R16,<_no1stop
 0D40 10E0              ldi R17,>_no1stop
 0D42 92DA              xcall _uart1_send_string
 0D44                   .dbline 1049
 0D44           ;                                                        
 0D44           ;                                                                                hold_allow_motor_0=0;//禁止0号手指向端部靠近
 0D44 0024              clr R0
 0D46 09AA              std y+49,R0
 0D48                   .dbline 1050
 0D48           ;                                                                                hold_allow_motor_1=0;//禁止1号手指向端部靠近
 0D48 0AAA              std y+50,R0
 0D4A                   .dbline 1053
 0D4A           ;                                                        
 0D4A           ;                                                                                //报告上位机已经夹紧
 0D4A           ;                                                                                delay(50);
 0D4A 02E3              ldi R16,50
 0D4C 10E0              ldi R17,0
 0D4E 58D9              xcall _delay
 0D50                   .dbline 1054
 0D50           ;                                                                                uart0_send_string("zz10");
 0D50 00E0              ldi R16,<L310
 0D52 10E0              ldi R17,>L310
 0D54 1BDA              xcall _uart0_send_string
 0D56                   .dbline 1055
 0D56           ;                                                                                delay(50);
 0D56 02E3              ldi R16,50
 0D58 10E0              ldi R17,0
 0D5A 52D9              xcall _delay
 0D5C                   .dbline 1056
 0D5C           ;                                                                                uart0_send_string("zz10");
 0D5C 00E0              ldi R16,<L310
 0D5E 10E0              ldi R17,>L310
 0D60 15DA              xcall _uart0_send_string
 0D62                   .dbline 1057
 0D62           ;                                                                        }
 0D62           L308:
 0D62                   .dbline 1058
 0D62           ;                                                                }
 0D62           L306:
 0D62                   .dbline 1035
 0D62 0DA8              ldd R0,y+53
 0D64 0020              tst R0
 0D66 11F0              breq L311
 0D68           X81:
 0D68 0F99              sbic 0x1,7
 0D6A CCCF              rjmp L305
 0D6C           X82:
 0D6C           L311:
 0D6C                   .dbline 1061
 0D6C           ;                                                        
 0D6C           ;                                                                
 0D6C           ;                                                        }
 0D6C           L295:
 0D6C                   .dbline 1063
 0D6C           ;                                                        
 0D6C           ;                                                }
 0D6C           L269:
 0D6C                   .dbline 1064
 0D6C           ;                                        }
 0D6C           L266:
 0D6C                   .dbline 1066
 0D6C           ;                                        
 0D6C           ;                                        if(array_cmp(Type(uart0_instr),"13")==0)//设定手指0，Ratio 1
 0D6C 00E0              ldi R16,<_uart0_instr
 0D6E 10E0              ldi R17,>_uart0_instr
 0D70 D1DA              xcall _Type
 0D72 20E0              ldi R18,<L314
 0D74 30E0              ldi R19,>L314
 0D76 A3DA              xcall _array_cmp
 0D78 6801              movw R12,R16
 0D7A 0030              cpi R16,0
 0D7C 0107              cpc R16,R17
 0D7E 49F4              brne L312
 0D80           X83:
 0D80                   .dbline 1067
 0D80           ;                                        {
 0D80                   .dbline 1068
 0D80           ;                                            com_finger0_ratio_1_PARA2=uart0_instr[2];
 0D80 20900B00          lds R2,_uart0_instr+2
 0D84 2AA2              std y+34,R2
 0D86                   .dbline 1069
 0D86           ;                                                com_finger0_ratio_1_PARA3=uart0_instr[3];
 0D86 20900C00          lds R2,_uart0_instr+3
 0D8A 2BA2              std y+35,R2
 0D8C                   .dbline 1070
 0D8C           ;                                                command_data_save_finger_0_ratio_1(com_finger0_ratio_1_PARA2,com_finger0_ratio_1_PARA3);
 0D8C 222D              mov R18,R2
 0D8E 0AA1              ldd R16,y+34
 0D90 BBDB              xcall _command_data_save_finger_0_ratio_1
 0D92                   .dbline 1071
 0D92           ;                                        }
 0D92           L312:
 0D92                   .dbline 1073
 0D92           ;                                        
 0D92           ;                                        if(array_cmp(Type(uart0_instr),"14")==0)//设定手指0，Ratio 2
 0D92 00E0              ldi R16,<_uart0_instr
 0D94 10E0              ldi R17,>_uart0_instr
 0D96 BEDA              xcall _Type
 0D98 20E0              ldi R18,<L319
 0D9A 30E0              ldi R19,>L319
 0D9C 90DA              xcall _array_cmp
 0D9E 6801              movw R12,R16
 0DA0 0030              cpi R16,0
 0DA2 0107              cpc R16,R17
 0DA4 49F4              brne L317
 0DA6           X84:
 0DA6                   .dbline 1074
 0DA6           ;                                        {
 0DA6                   .dbline 1075
 0DA6           ;                                            com_finger0_ratio_2_PARA2=uart0_instr[2];
 0DA6 20900B00          lds R2,_uart0_instr+2
 0DAA 2AA6              std y+42,R2
 0DAC                   .dbline 1076
 0DAC           ;                                                com_finger0_ratio_2_PARA3=uart0_instr[3];
 0DAC 20900C00          lds R2,_uart0_instr+3
 0DB0 2BA6              std y+43,R2
 0DB2                   .dbline 1077
 0DB2           ;                                                command_data_save_finger_0_ratio_2(com_finger0_ratio_2_PARA2,com_finger0_ratio_2_PARA3);
 0DB2 222D              mov R18,R2
 0DB4 0AA5              ldd R16,y+42
 0DB6 BFDB              xcall _command_data_save_finger_0_ratio_2
 0DB8                   .dbline 1078
 0DB8           ;                                        }
 0DB8           L317:
 0DB8                   .dbline 1080
 0DB8           ;                                        
 0DB8           ;                                        if(array_cmp(Type(uart0_instr),"15")==0)//设定手指0，Ratio 3
 0DB8 00E0              ldi R16,<_uart0_instr
 0DBA 10E0              ldi R17,>_uart0_instr
 0DBC ABDA              xcall _Type
 0DBE 20E0              ldi R18,<L324
 0DC0 30E0              ldi R19,>L324
 0DC2 7DDA              xcall _array_cmp
 0DC4 6801              movw R12,R16
 0DC6 0030              cpi R16,0
 0DC8 0107              cpc R16,R17
 0DCA 49F4              brne L322
 0DCC           X85:
 0DCC                   .dbline 1081
 0DCC           ;                                        {
 0DCC                   .dbline 1082
 0DCC           ;                                            com_finger0_ratio_3_PARA2=uart0_instr[2];
 0DCC 20900B00          lds R2,_uart0_instr+2
 0DD0 2CA2              std y+36,R2
 0DD2                   .dbline 1083
 0DD2           ;                                                com_finger0_ratio_3_PARA3=uart0_instr[3];
 0DD2 20900C00          lds R2,_uart0_instr+3
 0DD6 2DA2              std y+37,R2
 0DD8                   .dbline 1084
 0DD8           ;                                                command_data_save_finger_0_ratio_3(com_finger0_ratio_3_PARA2,com_finger0_ratio_3_PARA3);
 0DD8 222D              mov R18,R2
 0DDA 0CA1              ldd R16,y+36
 0DDC C3DB              xcall _command_data_save_finger_0_ratio_3
 0DDE                   .dbline 1085
 0DDE           ;                                        }
 0DDE           L322:
 0DDE                   .dbline 1087
 0DDE           ;                                        
 0DDE           ;                                        if(array_cmp(Type(uart0_instr),"16")==0)//设定手指1，Ratio 1
 0DDE 00E0              ldi R16,<_uart0_instr
 0DE0 10E0              ldi R17,>_uart0_instr
 0DE2 98DA              xcall _Type
 0DE4 20E0              ldi R18,<L329
 0DE6 30E0              ldi R19,>L329
 0DE8 6ADA              xcall _array_cmp
 0DEA 6801              movw R12,R16
 0DEC 0030              cpi R16,0
 0DEE 0107              cpc R16,R17
 0DF0 49F4              brne L327
 0DF2           X86:
 0DF2                   .dbline 1088
 0DF2           ;                                        {
 0DF2                   .dbline 1089
 0DF2           ;                                            com_finger1_ratio_1_PARA2=uart0_instr[2];
 0DF2 20900B00          lds R2,_uart0_instr+2
 0DF6 2EA2              std y+38,R2
 0DF8                   .dbline 1090
 0DF8           ;                                                com_finger1_ratio_1_PARA3=uart0_instr[3];
 0DF8 20900C00          lds R2,_uart0_instr+3
 0DFC 2FA2              std y+39,R2
 0DFE                   .dbline 1091
 0DFE           ;                                                command_data_save_finger_1_ratio_1(com_finger1_ratio_1_PARA2,com_finger1_ratio_1_PARA3);
 0DFE 222D              mov R18,R2
 0E00 0EA1              ldd R16,y+38
 0E02 0CDC              xcall _command_data_save_finger_1_ratio_1
 0E04                   .dbline 1092
 0E04           ;                                        }
 0E04           L327:
 0E04                   .dbline 1094
 0E04           ;                                        
 0E04           ;                                        if(array_cmp(Type(uart0_instr),"17")==0)//设定手指1，Ratio 2
 0E04 00E0              ldi R16,<_uart0_instr
 0E06 10E0              ldi R17,>_uart0_instr
 0E08 85DA              xcall _Type
 0E0A 20E0              ldi R18,<L334
 0E0C 30E0              ldi R19,>L334
 0E0E 57DA              xcall _array_cmp
 0E10 6801              movw R12,R16
 0E12 0030              cpi R16,0
 0E14 0107              cpc R16,R17
 0E16 49F4              brne L332
 0E18           X87:
 0E18                   .dbline 1095
 0E18           ;                                        {
 0E18                   .dbline 1096
 0E18           ;                                            com_finger1_ratio_2_PARA2=uart0_instr[2];
 0E18 20900B00          lds R2,_uart0_instr+2
 0E1C 2CA6              std y+44,R2
 0E1E                   .dbline 1097
 0E1E           ;                                                com_finger1_ratio_2_PARA3=uart0_instr[3];
 0E1E 20900C00          lds R2,_uart0_instr+3
 0E22 2DA6              std y+45,R2
 0E24                   .dbline 1098
 0E24           ;                                                command_data_save_finger_1_ratio_2(com_finger1_ratio_2_PARA2,com_finger1_ratio_2_PARA3);
 0E24 222D              mov R18,R2
 0E26 0CA5              ldd R16,y+44
 0E28 10DC              xcall _command_data_save_finger_1_ratio_2
 0E2A                   .dbline 1099
 0E2A           ;                                        }
 0E2A           L332:
 0E2A                   .dbline 1101
 0E2A           ;                                        
 0E2A           ;                                        if(array_cmp(Type(uart0_instr),"18")==0)//设定手指1，Ratio 3
 0E2A 00E0              ldi R16,<_uart0_instr
 0E2C 10E0              ldi R17,>_uart0_instr
 0E2E 72DA              xcall _Type
 0E30 20E0              ldi R18,<L339
 0E32 30E0              ldi R19,>L339
 0E34 44DA              xcall _array_cmp
 0E36 6801              movw R12,R16
 0E38 0030              cpi R16,0
 0E3A 0107              cpc R16,R17
 0E3C 49F4              brne L337
 0E3E           X88:
 0E3E                   .dbline 1102
 0E3E           ;                                        {
 0E3E                   .dbline 1103
 0E3E           ;                                            com_finger1_ratio_3_PARA2=uart0_instr[2];
 0E3E 20900B00          lds R2,_uart0_instr+2
 0E42 28A6              std y+40,R2
 0E44                   .dbline 1104
 0E44           ;                                                com_finger1_ratio_3_PARA3=uart0_instr[3];
 0E44 20900C00          lds R2,_uart0_instr+3
 0E48 29A6              std y+41,R2
 0E4A                   .dbline 1105
 0E4A           ;                                                command_data_save_finger_1_ratio_3(com_finger1_ratio_3_PARA2,com_finger1_ratio_3_PARA3);
 0E4A 222D              mov R18,R2
 0E4C 08A5              ldd R16,y+40
 0E4E 14DC              xcall _command_data_save_finger_1_ratio_3
 0E50                   .dbline 1106
 0E50           ;                                        }
 0E50           L337:
 0E50                   .dbline 1108
 0E50           ;                                        
 0E50           ;                                        if(array_cmp(Type(uart0_instr),"19")==0)//设定force_judge
 0E50 00E0              ldi R16,<_uart0_instr
 0E52 10E0              ldi R17,>_uart0_instr
 0E54 5FDA              xcall _Type
 0E56 20E0              ldi R18,<L344
 0E58 30E0              ldi R19,>L344
 0E5A 31DA              xcall _array_cmp
 0E5C 6801              movw R12,R16
 0E5E 0030              cpi R16,0
 0E60 0107              cpc R16,R17
 0E62 09F0              breq X136
 0E64 9FC1              xjmp L222
 0E66           X136:
 0E66           X89:
 0E66                   .dbline 1109
 0E66           ;                                        {
 0E66                   .dbline 1110
 0E66           ;                                            force_judge=uart0_instr[2];
 0E66 20900B00          lds R2,_uart0_instr+2
 0E6A 20920700          sts _force_judge,R2
 0E6E                   .dbline 1111
 0E6E           ;                                                command_data_save_force_high8(force_judge);
 0E6E 022D              mov R16,R2
 0E70 1127              clr R17
 0E72 CFDA              xcall _command_data_save_force_high8
 0E74                   .dbline 1112
 0E74           ;                                        }
 0E74                   .dbline 1114
 0E74           ;                                
 0E74           ;                                        break;
 0E74 97C1              xjmp L222
 0E76           L346:
 0E76                   .dbline 1118
 0E76           ;                            }
 0E76           ;                        
 0E76           ;                        case 2:
 0E76           ;                            {
 0E76                   .dbline 1119
 0E76           ;                                        if(array_cmp(uart0_instr,"2100")==0)//调试模式・手指0停止
 0E76 20E0              ldi R18,<L349
 0E78 30E0              ldi R19,>L349
 0E7A 00E0              ldi R16,<_uart0_instr
 0E7C 10E0              ldi R17,>_uart0_instr
 0E7E 1FDA              xcall _array_cmp
 0E80 6801              movw R12,R16
 0E82 0030              cpi R16,0
 0E84 0107              cpc R16,R17
 0E86 39F4              brne L347
 0E88           X90:
 0E88                   .dbline 1120
 0E88           ;                                        {
 0E88                   .dbline 1121
 0E88           ;                                            TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 0E88 87B7              in R24,0x37
 0E8A 8B7F              andi R24,251
 0E8C 87BF              out 0x37,R24
 0E8E                   .dbline 1122
 0E8E           ;                                                uart1_send_string((uchar*)no0stop,9);
 0E8E 29E0              ldi R18,9
 0E90 00E0              ldi R16,<_no0stop
 0E92 10E0              ldi R17,>_no0stop
 0E94 E9D9              xcall _uart1_send_string
 0E96                   .dbline 1123
 0E96           ;                                        }
 0E96           L347:
 0E96                   .dbline 1125
 0E96           ; 
 0E96           ;                                        if(array_cmp(uart0_instr,"2101")==0)//调试模式・手指0松开方向移动
 0E96 20E0              ldi R18,<L352
 0E98 30E0              ldi R19,>L352
 0E9A 00E0              ldi R16,<_uart0_instr
 0E9C 10E0              ldi R17,>_uart0_instr
 0E9E 0FDA              xcall _array_cmp
 0EA0 6801              movw R12,R16
 0EA2 0030              cpi R16,0
 0EA4 0107              cpc R16,R17
 0EA6 01F5              brne L350
 0EA8           X91:
 0EA8                   .dbline 1126
 0EA8           ;                                        {
 0EA8                   .dbline 1127
 0EA8           ;                                            if(release_allow_motor_0)
 0EA8 0BA8              ldd R0,y+51
 0EAA 0020              tst R0
 0EAC E9F0              breq L353
 0EAE           X92:
 0EAE                   .dbline 1128
 0EAE           ;                                                {
 0EAE                   .dbline 1129
 0EAE           ;                                                    TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 0EAE 87B7              in R24,0x37
 0EB0 8B7F              andi R24,251
 0EB2 87BF              out 0x37,R24
 0EB4                   .dbline 1130
 0EB4           ;                                                        motor_command[2]=0x00;//ID=0
 0EB4 2224              clr R2
 0EB6 2B8E              std y+27,R2
 0EB8                   .dbline 1131
 0EB8           ;                                                        motor_command[6]=PARA2;
 0EB8 4F8F              std y+31,R20
 0EBA                   .dbline 1132
 0EBA           ;                                                        motor_command[7]=PARA3+0x04;//顺时针，绝对不可在此更改PARA3的值！
 0EBA 862F              mov R24,R22
 0EBC 8C5F              subi R24,252    ; addi 4
 0EBE 88A3              std y+32,R24
 0EC0                   .dbline 1133
 0EC0           ;                                                        CHECK=ratio_command_check(0,PARA2,PARA3+0x04);
 0EC0 862F              mov R24,R22
 0EC2 8C5F              subi R24,252    ; addi 4
 0EC4 8883              std y+0,R24
 0EC6 242F              mov R18,R20
 0EC8 0027              clr R16
 0ECA 13DB              xcall _ratio_command_check
 0ECC C02E              mov R12,R16
 0ECE AC2C              mov R10,R12
 0ED0                   .dbline 1134
 0ED0           ;                                                        motor_command[8]=CHECK;
 0ED0 A9A2              std y+33,R10
 0ED2                   .dbline 1135
 0ED2           ;                                                        delay(50);
 0ED2 02E3              ldi R16,50
 0ED4 10E0              ldi R17,0
 0ED6 94D8              xcall _delay
 0ED8                   .dbline 1136
 0ED8           ;                                                        uart1_send_string(motor_command,9);
 0ED8 29E0              ldi R18,9
 0EDA 8E01              movw R16,R28
 0EDC 075E              subi R16,231  ; offset = 25
 0EDE 1F4F              sbci R17,255
 0EE0 C3D9              xcall _uart1_send_string
 0EE2                   .dbline 1139
 0EE2           ;                                                        //delay(50);
 0EE2           ;                                                        //uart0_send_string_with_num(motor_command,9);
 0EE2           ;                                                        TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
 0EE2 87B7              in R24,0x37
 0EE4 8460              ori R24,4
 0EE6 87BF              out 0x37,R24
 0EE8                   .dbline 1140
 0EE8           ;                                                }
 0EE8           L353:
 0EE8                   .dbline 1141
 0EE8           ;                                        }
 0EE8           L350:
 0EE8                   .dbline 1143
 0EE8           ;                                        
 0EE8           ;                                        if(array_cmp(uart0_instr,"2102")==0)//调试模式・手指0夹紧方向移动
 0EE8 20E0              ldi R18,<L361
 0EEA 30E0              ldi R19,>L361
 0EEC 00E0              ldi R16,<_uart0_instr
 0EEE 10E0              ldi R17,>_uart0_instr
 0EF0 E6D9              xcall _array_cmp
 0EF2 6801              movw R12,R16
 0EF4 0030              cpi R16,0
 0EF6 0107              cpc R16,R17
 0EF8 E1F4              brne L359
 0EFA           X93:
 0EFA                   .dbline 1144
 0EFA           ;                                        {
 0EFA                   .dbline 1145
 0EFA           ;                                            if(hold_allow_motor_0)
 0EFA 09A8              ldd R0,y+49
 0EFC 0020              tst R0
 0EFE C9F0              breq L362
 0F00           X94:
 0F00                   .dbline 1146
 0F00           ;                                                {
 0F00                   .dbline 1147
 0F00           ;                                                    TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 0F00 87B7              in R24,0x37
 0F02 8B7F              andi R24,251
 0F04 87BF              out 0x37,R24
 0F06                   .dbline 1148
 0F06           ;                                                        motor_command[2]=0x00;//ID=0
 0F06 2224              clr R2
 0F08 2B8E              std y+27,R2
 0F0A                   .dbline 1149
 0F0A           ;                                                        motor_command[6]=PARA2;
 0F0A 4F8F              std y+31,R20
 0F0C                   .dbline 1150
 0F0C           ;                                                        motor_command[7]=PARA3;
 0F0C 68A3              std y+32,R22
 0F0E                   .dbline 1151
 0F0E           ;                                                        CHECK=ratio_command_check(0,PARA2,PARA3);
 0F0E 6883              std y+0,R22
 0F10 242F              mov R18,R20
 0F12 0027              clr R16
 0F14 EEDA              xcall _ratio_command_check
 0F16 C02E              mov R12,R16
 0F18 AC2C              mov R10,R12
 0F1A                   .dbline 1152
 0F1A           ;                                                        motor_command[8]=CHECK;
 0F1A A9A2              std y+33,R10
 0F1C                   .dbline 1153
 0F1C           ;                                                        delay(50);
 0F1C 02E3              ldi R16,50
 0F1E 10E0              ldi R17,0
 0F20 6FD8              xcall _delay
 0F22                   .dbline 1154
 0F22           ;                                                        uart1_send_string(motor_command,9);
 0F22 29E0              ldi R18,9
 0F24 8E01              movw R16,R28
 0F26 075E              subi R16,231  ; offset = 25
 0F28 1F4F              sbci R17,255
 0F2A 9ED9              xcall _uart1_send_string
 0F2C                   .dbline 1157
 0F2C           ;                                                        //delay(50);
 0F2C           ;                                                        //uart0_send_string_with_num(motor_command,9);
 0F2C           ;                                                        TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
 0F2C 87B7              in R24,0x37
 0F2E 8460              ori R24,4
 0F30 87BF              out 0x37,R24
 0F32                   .dbline 1158
 0F32           ;                                                }
 0F32           L362:
 0F32                   .dbline 1159
 0F32           ;                                        }
 0F32           L359:
 0F32                   .dbline 1161
 0F32           ; 
 0F32           ;                                        if(array_cmp(uart0_instr,"2110")==0)//调试模式・手指1停止
 0F32 20E0              ldi R18,<L370
 0F34 30E0              ldi R19,>L370
 0F36 00E0              ldi R16,<_uart0_instr
 0F38 10E0              ldi R17,>_uart0_instr
 0F3A C1D9              xcall _array_cmp
 0F3C 6801              movw R12,R16
 0F3E 0030              cpi R16,0
 0F40 0107              cpc R16,R17
 0F42 39F4              brne L368
 0F44           X95:
 0F44                   .dbline 1162
 0F44           ;                                        {
 0F44                   .dbline 1163
 0F44           ;                                            TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 0F44 87B7              in R24,0x37
 0F46 8B7F              andi R24,251
 0F48 87BF              out 0x37,R24
 0F4A                   .dbline 1164
 0F4A           ;                                                uart1_send_string((uchar*)no1stop,9);
 0F4A 29E0              ldi R18,9
 0F4C 00E0              ldi R16,<_no1stop
 0F4E 10E0              ldi R17,>_no1stop
 0F50 8BD9              xcall _uart1_send_string
 0F52                   .dbline 1165
 0F52           ;                                        }
 0F52           L368:
 0F52                   .dbline 1167
 0F52           ; 
 0F52           ;                                        if(array_cmp(uart0_instr,"2111")==0)//调试模式・手指1松开方向移动
 0F52 20E0              ldi R18,<L373
 0F54 30E0              ldi R19,>L373
 0F56 00E0              ldi R16,<_uart0_instr
 0F58 10E0              ldi R17,>_uart0_instr
 0F5A B1D9              xcall _array_cmp
 0F5C 6801              movw R12,R16
 0F5E 0030              cpi R16,0
 0F60 0107              cpc R16,R17
 0F62 01F5              brne L371
 0F64           X96:
 0F64                   .dbline 1168
 0F64           ;                                        {
 0F64                   .dbline 1169
 0F64           ;                                            if(release_allow_motor_1)
 0F64 0CA8              ldd R0,y+52
 0F66 0020              tst R0
 0F68 E9F0              breq L374
 0F6A           X97:
 0F6A                   .dbline 1170
 0F6A           ;                                                {
 0F6A                   .dbline 1171
 0F6A           ;                                                    TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 0F6A 87B7              in R24,0x37
 0F6C 8B7F              andi R24,251
 0F6E 87BF              out 0x37,R24
 0F70                   .dbline 1172
 0F70           ;                                                        motor_command[2]=0x01;//ID=1
 0F70 81E0              ldi R24,1
 0F72 8B8F              std y+27,R24
 0F74                   .dbline 1173
 0F74           ;                                                        motor_command[6]=PARA2;
 0F74 4F8F              std y+31,R20
 0F76                   .dbline 1174
 0F76           ;                                                        motor_command[7]=PARA3+0x04;//顺时针，绝对不可在此更改PARA3的值！
 0F76 862F              mov R24,R22
 0F78 8C5F              subi R24,252    ; addi 4
 0F7A 88A3              std y+32,R24
 0F7C                   .dbline 1175
 0F7C           ;                                                        CHECK=ratio_command_check(1,PARA2,PARA3+0x04);
 0F7C 862F              mov R24,R22
 0F7E 8C5F              subi R24,252    ; addi 4
 0F80 8883              std y+0,R24
 0F82 242F              mov R18,R20
 0F84 01E0              ldi R16,1
 0F86 B5DA              xcall _ratio_command_check
 0F88 C02E              mov R12,R16
 0F8A AC2C              mov R10,R12
 0F8C                   .dbline 1176
 0F8C           ;                                                        motor_command[8]=CHECK;
 0F8C A9A2              std y+33,R10
 0F8E                   .dbline 1177
 0F8E           ;                                                        delay(50);
 0F8E 02E3              ldi R16,50
 0F90 10E0              ldi R17,0
 0F92 36D8              xcall _delay
 0F94                   .dbline 1178
 0F94           ;                                                        uart1_send_string(motor_command,9);
 0F94 29E0              ldi R18,9
 0F96 8E01              movw R16,R28
 0F98 075E              subi R16,231  ; offset = 25
 0F9A 1F4F              sbci R17,255
 0F9C 65D9              xcall _uart1_send_string
 0F9E                   .dbline 1181
 0F9E           ;                                                        //delay(50);
 0F9E           ;                                                        //uart0_send_string_with_num(motor_command,9);
 0F9E           ;                                                        TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
 0F9E 87B7              in R24,0x37
 0FA0 8460              ori R24,4
 0FA2 87BF              out 0x37,R24
 0FA4                   .dbline 1182
 0FA4           ;                                                }
 0FA4           L374:
 0FA4                   .dbline 1183
 0FA4           ;                                        }
 0FA4           L371:
 0FA4                   .dbline 1185
 0FA4           ;                                        
 0FA4           ;                                        if(array_cmp(uart0_instr,"2112")==0)//调试模式・手指1夹紧方向移动
 0FA4 20E0              ldi R18,<L382
 0FA6 30E0              ldi R19,>L382
 0FA8 00E0              ldi R16,<_uart0_instr
 0FAA 10E0              ldi R17,>_uart0_instr
 0FAC 88D9              xcall _array_cmp
 0FAE 6801              movw R12,R16
 0FB0 0030              cpi R16,0
 0FB2 0107              cpc R16,R17
 0FB4 E1F4              brne L380
 0FB6           X98:
 0FB6                   .dbline 1186
 0FB6           ;                                        {
 0FB6                   .dbline 1187
 0FB6           ;                                            if(hold_allow_motor_1)
 0FB6 0AA8              ldd R0,y+50
 0FB8 0020              tst R0
 0FBA C9F0              breq L383
 0FBC           X99:
 0FBC                   .dbline 1188
 0FBC           ;                                                {
 0FBC                   .dbline 1189
 0FBC           ;                                                    TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 0FBC 87B7              in R24,0x37
 0FBE 8B7F              andi R24,251
 0FC0 87BF              out 0x37,R24
 0FC2                   .dbline 1190
 0FC2           ;                                                        motor_command[2]=0x01;//ID=1
 0FC2 81E0              ldi R24,1
 0FC4 8B8F              std y+27,R24
 0FC6                   .dbline 1191
 0FC6           ;                                                        motor_command[6]=PARA2;
 0FC6 4F8F              std y+31,R20
 0FC8                   .dbline 1192
 0FC8           ;                                                        motor_command[7]=PARA3;
 0FC8 68A3              std y+32,R22
 0FCA                   .dbline 1193
 0FCA           ;                                                        CHECK=ratio_command_check(1,PARA2,PARA3);
 0FCA 6883              std y+0,R22
 0FCC 242F              mov R18,R20
 0FCE 01E0              ldi R16,1
 0FD0 90DA              xcall _ratio_command_check
 0FD2 C02E              mov R12,R16
 0FD4 AC2C              mov R10,R12
 0FD6                   .dbline 1194
 0FD6           ;                                                        motor_command[8]=CHECK;
 0FD6 A9A2              std y+33,R10
 0FD8                   .dbline 1195
 0FD8           ;                                                        delay(50);
 0FD8 02E3              ldi R16,50
 0FDA 10E0              ldi R17,0
 0FDC 11D8              xcall _delay
 0FDE                   .dbline 1196
 0FDE           ;                                                        uart1_send_string(motor_command,9);
 0FDE 29E0              ldi R18,9
 0FE0 8E01              movw R16,R28
 0FE2 075E              subi R16,231  ; offset = 25
 0FE4 1F4F              sbci R17,255
 0FE6 40D9              xcall _uart1_send_string
 0FE8                   .dbline 1199
 0FE8           ;                                                        //delay(50);
 0FE8           ;                                                        //uart0_send_string_with_num(motor_command,9);
 0FE8           ;                                                        TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
 0FE8 87B7              in R24,0x37
 0FEA 8460              ori R24,4
 0FEC 87BF              out 0x37,R24
 0FEE                   .dbline 1200
 0FEE           ;                                                }
 0FEE           L383:
 0FEE                   .dbline 1201
 0FEE           ;                                        }
 0FEE           L380:
 0FEE                   .dbline 1203
 0FEE           ; 
 0FEE           ;                                        if(array_cmp(Type(uart0_instr),"22")==0)
 0FEE 00E0              ldi R16,<_uart0_instr
 0FF0 10E0              ldi R17,>_uart0_instr
 0FF2 90D9              xcall _Type
 0FF4 20E0              ldi R18,<L391
 0FF6 30E0              ldi R19,>L391
 0FF8 62D9              xcall _array_cmp
 0FFA 5801              movw R10,R16
 0FFC 0030              cpi R16,0
 0FFE 0107              cpc R16,R17
 1000 B9F4              brne L389
 1002           X100:
 1002                   .dbline 1204
 1002           ;                                        {
 1002                   .dbline 1205
 1002           ;                                                TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 1002 87B7              in R24,0x37
 1004 8B7F              andi R24,251
 1006 87BF              out 0x37,R24
 1008                   .dbline 1206
 1008           ;                                                delay(50);
 1008 02E3              ldi R16,50
 100A 10E0              ldi R17,0
 100C 0E940000          xcall _delay
 1010                   .dbline 1207
 1010           ;                                                uart1_send_string((uchar*)no0stop,9);
 1010 29E0              ldi R18,9
 1012 00E0              ldi R16,<_no0stop
 1014 10E0              ldi R17,>_no0stop
 1016 28D9              xcall _uart1_send_string
 1018                   .dbline 1208
 1018           ;                                                delay(50);
 1018 02E3              ldi R16,50
 101A 10E0              ldi R17,0
 101C 0E940000          xcall _delay
 1020                   .dbline 1209
 1020           ;                                                uart1_send_string((uchar*)no1stop,9);
 1020 29E0              ldi R18,9
 1022 00E0              ldi R16,<_no1stop
 1024 10E0              ldi R17,>_no1stop
 1026 20D9              xcall _uart1_send_string
 1028                   .dbline 1210
 1028           ;                                                PARA2=uart0_instr[2];
 1028 40910B00          lds R20,_uart0_instr+2
 102C                   .dbline 1211
 102C           ;                                                PARA3=uart0_instr[3];
 102C 60910C00          lds R22,_uart0_instr+3
 1030                   .dbline 1214
 1030           ;                                                //delay(50);
 1030           ;                                                //uart0_send_string("ratio changed");
 1030           ;                                        }
 1030           L389:
 1030                   .dbline 1216
 1030           ;                                        
 1030           ;                                        if(array_cmp(uart0_instr,"2301")==0)//调试模式・设置手指0速度1(两指相同)夹紧第一阶段
 1030 20E0              ldi R18,<L396
 1032 30E0              ldi R19,>L396
 1034 00E0              ldi R16,<_uart0_instr
 1036 10E0              ldi R17,>_uart0_instr
 1038 42D9              xcall _array_cmp
 103A 5801              movw R10,R16
 103C 0030              cpi R16,0
 103E 0107              cpc R16,R17
 1040 19F4              brne L394
 1042           X101:
 1042                   .dbline 1217
 1042           ;                                        {
 1042                   .dbline 1218
 1042           ;                                            command_data_save_finger_0_ratio_1(PARA2,PARA3);
 1042 262F              mov R18,R22
 1044 042F              mov R16,R20
 1046 60DA              xcall _command_data_save_finger_0_ratio_1
 1048                   .dbline 1221
 1048           ;                                                //delay(50);
 1048           ;                                                //uart0_send_string(" Finger-0 Ratio-1 Set Successfully! ");
 1048           ;                                        }
 1048           L394:
 1048                   .dbline 1223
 1048           ;                                        
 1048           ;                                        if(array_cmp(uart0_instr,"2302")==0)//调试模式・设置手指0速度2(两指相同)夹紧第二阶段
 1048 20E0              ldi R18,<L399
 104A 30E0              ldi R19,>L399
 104C 00E0              ldi R16,<_uart0_instr
 104E 10E0              ldi R17,>_uart0_instr
 1050 36D9              xcall _array_cmp
 1052 5801              movw R10,R16
 1054 0030              cpi R16,0
 1056 0107              cpc R16,R17
 1058 19F4              brne L397
 105A           X102:
 105A                   .dbline 1224
 105A           ;                                        {
 105A                   .dbline 1225
 105A           ;                                            command_data_save_finger_0_ratio_2(PARA2,PARA3);
 105A 262F              mov R18,R22
 105C 042F              mov R16,R20
 105E 6BDA              xcall _command_data_save_finger_0_ratio_2
 1060                   .dbline 1228
 1060           ;                                                //delay(50);
 1060           ;                                                //uart0_send_string(" Finger-0 Ratio-2 Set Successfully! ");
 1060           ;                                        }
 1060           L397:
 1060                   .dbline 1230
 1060           ;                                        
 1060           ;                                        if(array_cmp(uart0_instr,"2303")==0)//调试模式・设置手指0速度3(两指相同)松开阶段
 1060 20E0              ldi R18,<L402
 1062 30E0              ldi R19,>L402
 1064 00E0              ldi R16,<_uart0_instr
 1066 10E0              ldi R17,>_uart0_instr
 1068 2AD9              xcall _array_cmp
 106A 5801              movw R10,R16
 106C 0030              cpi R16,0
 106E 0107              cpc R16,R17
 1070 19F4              brne L400
 1072           X103:
 1072                   .dbline 1231
 1072           ;                                        {
 1072                   .dbline 1232
 1072           ;                                            command_data_save_finger_0_ratio_3(PARA2,PARA3);
 1072 262F              mov R18,R22
 1074 042F              mov R16,R20
 1076 76DA              xcall _command_data_save_finger_0_ratio_3
 1078                   .dbline 1235
 1078           ;                                                //delay(50);
 1078           ;                                                //uart0_send_string(" Finger-0 Ratio-3 Set Successfully! ");
 1078           ;                                        }
 1078           L400:
 1078                   .dbline 1237
 1078           ;                                        
 1078           ;                                        if(array_cmp(uart0_instr,"2311")==0)//调试模式・设置手指1速度1(两指相同)夹紧第一阶段
 1078 20E0              ldi R18,<L405
 107A 30E0              ldi R19,>L405
 107C 00E0              ldi R16,<_uart0_instr
 107E 10E0              ldi R17,>_uart0_instr
 1080 1ED9              xcall _array_cmp
 1082 5801              movw R10,R16
 1084 0030              cpi R16,0
 1086 0107              cpc R16,R17
 1088 19F4              brne L403
 108A           X104:
 108A                   .dbline 1238
 108A           ;                                        {
 108A                   .dbline 1239
 108A           ;                                            command_data_save_finger_1_ratio_1(PARA2,PARA3);
 108A 262F              mov R18,R22
 108C 042F              mov R16,R20
 108E C6DA              xcall _command_data_save_finger_1_ratio_1
 1090                   .dbline 1242
 1090           ;                                                //delay(50);
 1090           ;                                                //uart0_send_string(" Finger-1 Ratio-1 Set Successfully! ");
 1090           ;                                        }
 1090           L403:
 1090                   .dbline 1244
 1090           ;                                        
 1090           ;                                        if(array_cmp(uart0_instr,"2312")==0)//调试模式・设置手指1速度2(两指相同)夹紧第二阶段
 1090 20E0              ldi R18,<L408
 1092 30E0              ldi R19,>L408
 1094 00E0              ldi R16,<_uart0_instr
 1096 10E0              ldi R17,>_uart0_instr
 1098 12D9              xcall _array_cmp
 109A 5801              movw R10,R16
 109C 0030              cpi R16,0
 109E 0107              cpc R16,R17
 10A0 19F4              brne L406
 10A2           X105:
 10A2                   .dbline 1245
 10A2           ;                                        {
 10A2                   .dbline 1246
 10A2           ;                                            command_data_save_finger_1_ratio_2(PARA2,PARA3);
 10A2 262F              mov R18,R22
 10A4 042F              mov R16,R20
 10A6 D1DA              xcall _command_data_save_finger_1_ratio_2
 10A8                   .dbline 1249
 10A8           ;                                                //delay(50);
 10A8           ;                                                //uart0_send_string(" Finger-1 Ratio-2 Set Successfully! ");
 10A8           ;                                        }
 10A8           L406:
 10A8                   .dbline 1251
 10A8           ;                                        
 10A8           ;                                        if(array_cmp(uart0_instr,"2313")==0)//调试模式・设置手指1速度3(两指相同)松开阶段
 10A8 20E0              ldi R18,<L411
 10AA 30E0              ldi R19,>L411
 10AC 00E0              ldi R16,<_uart0_instr
 10AE 10E0              ldi R17,>_uart0_instr
 10B0 06D9              xcall _array_cmp
 10B2 5801              movw R10,R16
 10B4 0030              cpi R16,0
 10B6 0107              cpc R16,R17
 10B8 19F4              brne L409
 10BA           X106:
 10BA                   .dbline 1252
 10BA           ;                                        {
 10BA                   .dbline 1253
 10BA           ;                                            command_data_save_finger_1_ratio_3(PARA2,PARA3);
 10BA 262F              mov R18,R22
 10BC 042F              mov R16,R20
 10BE DCDA              xcall _command_data_save_finger_1_ratio_3
 10C0                   .dbline 1256
 10C0           ;                                                //delay(50);
 10C0           ;                                                //uart0_send_string(" Finger-1 Ratio-3 Set Successfully! ");
 10C0           ;                                        }
 10C0           L409:
 10C0                   .dbline 1258
 10C0           ;                                        
 10C0           ;                                        if(array_cmp(Type(uart0_instr),"24")==0)//调试模式・设置夹紧力阈值
 10C0 00E0              ldi R16,<_uart0_instr
 10C2 10E0              ldi R17,>_uart0_instr
 10C4 27D9              xcall _Type
 10C6 20E0              ldi R18,<L414
 10C8 30E0              ldi R19,>L414
 10CA F9D8              xcall _array_cmp
 10CC 5801              movw R10,R16
 10CE 0030              cpi R16,0
 10D0 0107              cpc R16,R17
 10D2 39F4              brne L412
 10D4           X107:
 10D4                   .dbline 1259
 10D4           ;                                        {
 10D4                   .dbline 1260
 10D4           ;                                            force_judge=uart0_instr[2];
 10D4 20900B00          lds R2,_uart0_instr+2
 10D8 20920700          sts _force_judge,R2
 10DC                   .dbline 1261
 10DC           ;                                                command_data_save_force_high8(force_judge);
 10DC 022D              mov R16,R2
 10DE 1127              clr R17
 10E0 98D9              xcall _command_data_save_force_high8
 10E2                   .dbline 1264
 10E2           ;                                                //delay(50);
 10E2           ;                                                //uart0_send_string(" Force Set Successfully! ");
 10E2           ;                                        }
 10E2           L412:
 10E2                   .dbline 1267
 10E2           ;                                        
 10E2           ;                                        
 10E2           ;                                        if(array_cmp(uart0_instr,"2500")==0)//调试模式・读取EEPROM中存储的RATIO和力阈值
 10E2 20E0              ldi R18,<L418
 10E4 30E0              ldi R19,>L418
 10E6 00E0              ldi R16,<_uart0_instr
 10E8 10E0              ldi R17,>_uart0_instr
 10EA E9D8              xcall _array_cmp
 10EC 5801              movw R10,R16
 10EE 0030              cpi R16,0
 10F0 0107              cpc R16,R17
 10F2 09F0              breq X137
 10F4 57C0              xjmp L222
 10F6           X137:
 10F6           X108:
 10F6                   .dbline 1268
 10F6           ;                                        {
 10F6                   .dbline 1272
 10F6           ;                                                //更新ratio变量值、力阈值和消息数组的值
 10F6           ;                                                
 10F6           ;                                                //获取EEPROM中存储的RATIO值
 10F6           ;                                        command_data_read_finger_0_ratio_1(&com_finger0_ratio_1_PARA2,&com_finger0_ratio_1_PARA3);
 10F6 9E01              movw R18,R28
 10F8 2D5D              subi R18,221  ; offset = 35
 10FA 3F4F              sbci R19,255
 10FC 8E01              movw R16,R28
 10FE 0E5D              subi R16,222  ; offset = 34
 1100 1F4F              sbci R17,255
 1102 47DA              xcall _command_data_read_finger_0_ratio_1
 1104                   .dbline 1273
 1104           ;                                                command_data_read_finger_0_ratio_2(&com_finger0_ratio_2_PARA2,&com_finger0_ratio_2_PARA3);
 1104 9E01              movw R18,R28
 1106 255D              subi R18,213  ; offset = 43
 1108 3F4F              sbci R19,255
 110A 8E01              movw R16,R28
 110C 065D              subi R16,214  ; offset = 42
 110E 1F4F              sbci R17,255
 1110 57DA              xcall _command_data_read_finger_0_ratio_2
 1112                   .dbline 1274
 1112           ;                                                command_data_read_finger_0_ratio_3(&com_finger0_ratio_3_PARA2,&com_finger0_ratio_3_PARA3);
 1112 9E01              movw R18,R28
 1114 2B5D              subi R18,219  ; offset = 37
 1116 3F4F              sbci R19,255
 1118 8E01              movw R16,R28
 111A 0C5D              subi R16,220  ; offset = 36
 111C 1F4F              sbci R17,255
 111E 67DA              xcall _command_data_read_finger_0_ratio_3
 1120                   .dbline 1275
 1120           ;                                                command_data_read_finger_1_ratio_1(&com_finger1_ratio_1_PARA2,&com_finger1_ratio_1_PARA3);
 1120 9E01              movw R18,R28
 1122 295D              subi R18,217  ; offset = 39
 1124 3F4F              sbci R19,255
 1126 8E01              movw R16,R28
 1128 0A5D              subi R16,218  ; offset = 38
 112A 1F4F              sbci R17,255
 112C BCDA              xcall _command_data_read_finger_1_ratio_1
 112E                   .dbline 1276
 112E           ;                                                command_data_read_finger_1_ratio_2(&com_finger1_ratio_2_PARA2,&com_finger1_ratio_2_PARA3);
 112E 9E01              movw R18,R28
 1130 235D              subi R18,211  ; offset = 45
 1132 3F4F              sbci R19,255
 1134 8E01              movw R16,R28
 1136 045D              subi R16,212  ; offset = 44
 1138 1F4F              sbci R17,255
 113A CCDA              xcall _command_data_read_finger_1_ratio_2
 113C                   .dbline 1277
 113C           ;                                                command_data_read_finger_1_ratio_3(&com_finger1_ratio_3_PARA2,&com_finger1_ratio_3_PARA3);
 113C 9E01              movw R18,R28
 113E 275D              subi R18,215  ; offset = 41
 1140 3F4F              sbci R19,255
 1142 8E01              movw R16,R28
 1144 085D              subi R16,216  ; offset = 40
 1146 1F4F              sbci R17,255
 1148 DCDA              xcall _command_data_read_finger_1_ratio_3
 114A                   .dbline 1279
 114A           ;       
 114A           ;                                                msg_eeprom_array[0]='z';
 114A 8AE7              ldi R24,122
 114C 8887              std y+8,R24
 114E                   .dbline 1280
 114E           ;                                                msg_eeprom_array[1]='z';
 114E 8987              std y+9,R24
 1150                   .dbline 1281
 1150           ;                                                msg_eeprom_array[2]='3';
 1150 83E3              ldi R24,51
 1152 8A87              std y+10,R24
 1154                   .dbline 1282
 1154           ;                                                msg_eeprom_array[3]='3';
 1154 8B87              std y+11,R24
 1156                   .dbline 1283
 1156           ;                                                msg_eeprom_array[4]=com_finger0_ratio_1_PARA2;
 1156 2AA0              ldd R2,y+34
 1158 2C86              std y+12,R2
 115A                   .dbline 1284
 115A           ;                                                msg_eeprom_array[5]=com_finger0_ratio_1_PARA3;
 115A 2BA0              ldd R2,y+35
 115C 2D86              std y+13,R2
 115E                   .dbline 1285
 115E           ;                                                msg_eeprom_array[6]=com_finger0_ratio_2_PARA2;
 115E 2AA4              ldd R2,y+42
 1160 2E86              std y+14,R2
 1162                   .dbline 1286
 1162           ;                                                msg_eeprom_array[7]=com_finger0_ratio_2_PARA3;
 1162 2BA4              ldd R2,y+43
 1164 2F86              std y+15,R2
 1166                   .dbline 1287
 1166           ;                                                msg_eeprom_array[8]=com_finger0_ratio_3_PARA2;
 1166 2CA0              ldd R2,y+36
 1168 288A              std y+16,R2
 116A                   .dbline 1288
 116A           ;                                                msg_eeprom_array[9]=com_finger0_ratio_3_PARA3;
 116A 2DA0              ldd R2,y+37
 116C 298A              std y+17,R2
 116E                   .dbline 1289
 116E           ;                                                msg_eeprom_array[10]=com_finger1_ratio_1_PARA2;
 116E 2EA0              ldd R2,y+38
 1170 2A8A              std y+18,R2
 1172                   .dbline 1290
 1172           ;                                                msg_eeprom_array[11]=com_finger1_ratio_1_PARA3;
 1172 2FA0              ldd R2,y+39
 1174 2B8A              std y+19,R2
 1176                   .dbline 1291
 1176           ;                                                msg_eeprom_array[12]=com_finger1_ratio_2_PARA2;
 1176 2CA4              ldd R2,y+44
 1178 2C8A              std y+20,R2
 117A                   .dbline 1292
 117A           ;                                                msg_eeprom_array[13]=com_finger1_ratio_2_PARA3;
 117A 2DA4              ldd R2,y+45
 117C 2D8A              std y+21,R2
 117E                   .dbline 1293
 117E           ;                                                msg_eeprom_array[14]=com_finger1_ratio_3_PARA2;
 117E 28A4              ldd R2,y+40
 1180 2E8A              std y+22,R2
 1182                   .dbline 1294
 1182           ;                                                msg_eeprom_array[15]=com_finger1_ratio_3_PARA3;
 1182 29A4              ldd R2,y+41
 1184 2F8A              std y+23,R2
 1186                   .dbline 1297
 1186           ;       
 1186           ;                                                //获取EEPROM中存储的夹紧力阈值有效值高八位
 1186           ;                                                command_data_read_force_high8(&force_judge);
 1186 00E0              ldi R16,<_force_judge
 1188 10E0              ldi R17,>_force_judge
 118A 50D9              xcall _command_data_read_force_high8
 118C                   .dbline 1298
 118C           ;                                                msg_eeprom_array[16]=force_judge;
 118C 20900700          lds R2,_force_judge
 1190 288E              std y+24,R2
 1192                   .dbline 1300
 1192           ;                                                
 1192           ;                                                delay(50);
 1192 02E3              ldi R16,50
 1194 10E0              ldi R17,0
 1196 0E940000          xcall _delay
 119A                   .dbline 1301
 119A           ;                                                uart0_send_string_with_num(msg_eeprom_array,17);//上传EEPROM中存储的数值
 119A 21E1              ldi R18,17
 119C 8E01              movw R16,R28
 119E 085F              subi R16,248  ; offset = 8
 11A0 1F4F              sbci R17,255
 11A2 08D8              xcall _uart0_send_string_with_num
 11A4                   .dbline 1303
 11A4           ;       
 11A4           ;                                        }
 11A4                   .dbline 1305
 11A4           ;                                        
 11A4           ;                                    break;
 11A4                   .dbline 1308
 11A4           ;                            }
 11A4           ;                        
 11A4           ;                        default:break;
 11A4           L222:
 11A4                   .dbline 1311
 11A4           ;                        }
 11A4           ;                        
 11A4           ;                        if(array_cmp(uart0_instr,"3100")==0)//恢复触碰报警 ext interrupt 0 
 11A4 20E0              ldi R18,<L437
 11A6 30E0              ldi R19,>L437
 11A8 00E0              ldi R16,<_uart0_instr
 11AA 10E0              ldi R17,>_uart0_instr
 11AC 88D8              xcall _array_cmp
 11AE 5801              movw R10,R16
 11B0 0030              cpi R16,0
 11B2 0107              cpc R16,R17
 11B4 19F4              brne L435
 11B6           X109:
 11B6                   .dbline 1312
 11B6           ;                        {
 11B6                   .dbline 1313
 11B6           ;                            ext_collision_alert_allow_int0=1;//上侧
 11B6 81E0              ldi R24,1
 11B8 80932A00          sts _ext_collision_alert_allow_int0,R24
 11BC                   .dbline 1314
 11BC           ;                        }
 11BC           L435:
 11BC                   .dbline 1316
 11BC           ;                        
 11BC           ;                        if(array_cmp(uart0_instr,"3200")==0)//恢复触碰报警 ext interrupt 1 
 11BC 20E0              ldi R18,<L440
 11BE 30E0              ldi R19,>L440
 11C0 00E0              ldi R16,<_uart0_instr
 11C2 10E0              ldi R17,>_uart0_instr
 11C4 7CD8              xcall _array_cmp
 11C6 5801              movw R10,R16
 11C8 0030              cpi R16,0
 11CA 0107              cpc R16,R17
 11CC 19F4              brne L438
 11CE           X110:
 11CE                   .dbline 1317
 11CE           ;                        {
 11CE                   .dbline 1318
 11CE           ;                            ext_collision_alert_allow_int1=1;//下侧
 11CE 81E0              ldi R24,1
 11D0 80932B00          sts _ext_collision_alert_allow_int1,R24
 11D4                   .dbline 1319
 11D4           ;                        }
 11D4           L438:
 11D4                   .dbline 1321
 11D4           ;                        
 11D4           ;                        if(array_cmp(uart0_instr,"3300")==0)//恢复触碰报警 ext interrupt 4 
 11D4 20E0              ldi R18,<L443
 11D6 30E0              ldi R19,>L443
 11D8 00E0              ldi R16,<_uart0_instr
 11DA 10E0              ldi R17,>_uart0_instr
 11DC 70D8              xcall _array_cmp
 11DE 5801              movw R10,R16
 11E0 0030              cpi R16,0
 11E2 0107              cpc R16,R17
 11E4 19F4              brne L441
 11E6           X111:
 11E6                   .dbline 1322
 11E6           ;                        {
 11E6                   .dbline 1323
 11E6           ;                            ext_collision_alert_allow_int4=1;//指尖
 11E6 81E0              ldi R24,1
 11E8 80932C00          sts _ext_collision_alert_allow_int4,R24
 11EC                   .dbline 1324
 11EC           ;                        }
 11EC           L441:
 11EC                   .dbline 1326
 11EC           ;                        
 11EC           ;                        if(array_cmp(uart0_instr,"3400")==0)//读取报警允许变量的状态
 11EC 20E0              ldi R18,<L446
 11EE 30E0              ldi R19,>L446
 11F0 00E0              ldi R16,<_uart0_instr
 11F2 10E0              ldi R17,>_uart0_instr
 11F4 64D8              xcall _array_cmp
 11F6 5801              movw R10,R16
 11F8 0030              cpi R16,0
 11FA 0107              cpc R16,R17
 11FC 79F4              brne L444
 11FE           X112:
 11FE                   .dbline 1327
 11FE           ;                        {
 11FE                   .dbline 1328
 11FE           ;                            msg_interrupt_array[4]=ext_collision_alert_allow_int0;
 11FE 20902A00          lds R2,_ext_collision_alert_allow_int0
 1202 2D82              std y+5,R2
 1204                   .dbline 1329
 1204           ;                                msg_interrupt_array[5]=ext_collision_alert_allow_int1;
 1204 20902B00          lds R2,_ext_collision_alert_allow_int1
 1208 2E82              std y+6,R2
 120A                   .dbline 1330
 120A           ;                                msg_interrupt_array[6]=ext_collision_alert_allow_int4;
 120A 20902C00          lds R2,_ext_collision_alert_allow_int4
 120E 2F82              std y+7,R2
 1210                   .dbline 1331
 1210           ;                                uart0_send_string_with_num(msg_interrupt_array,7);
 1210 27E0              ldi R18,7
 1212 8E01              movw R16,R28
 1214 0F5F              subi R16,255  ; offset = 1
 1216 1F4F              sbci R17,255
 1218 0E94DA00          xcall _uart0_send_string_with_num
 121C                   .dbline 1332
 121C           ;                        }
 121C           L444:
 121C                   .dbline 1335
 121C           ;                        
 121C           ;                        /*末尾应完成命令执行后的还原工作A-D*/
 121C           ;                        uart0_instr_flag=0; //A.命令接收标志位置0
 121C 2224              clr R2
 121E 20922900          sts _uart0_instr_flag,R2
 1222                   .dbline 1336
 1222           ;                        uart0_r_instr_chk=0;//B.命令构造字符数计数置0
 1222 20922800          sts _uart0_r_instr_chk,R2
 1226                   .dbline 1337
 1226           ;                        for(i=0;i<12;i++)//C.命令清除
 1226 AA24              clr R10
 1228 09C0              xjmp L453
 122A           L450:
 122A                   .dbline 1338
 122A           ;                        {
 122A                   .dbline 1339
 122A           ;                        uart0_instr[i]=0;
 122A 80E0              ldi R24,<_uart0_instr
 122C 90E0              ldi R25,>_uart0_instr
 122E EA2D              mov R30,R10
 1230 FF27              clr R31
 1232 E80F              add R30,R24
 1234 F91F              adc R31,R25
 1236 2224              clr R2
 1238 2082              std z+0,R2
 123A                   .dbline 1340
 123A           ;                        }
 123A           L451:
 123A                   .dbline 1337
 123A A394              inc R10
 123C           L453:
 123C                   .dbline 1337
 123C 8A2D              mov R24,R10
 123E 8C30              cpi R24,12
 1240 A0F3              brlo L450
 1242           X113:
 1242                   .dbline 1341
 1242           ;                        UCSR0B|=BIT(RXCIE0);//D.恢复UART0的接收中断                    
 1242 579A              sbi 0xa,7
 1244                   .dbline 1342
 1244           ;            }
 1244           L219:
 1244                   .dbline 1353
 1244           ;                
 1244           ; 
 1244           ;               /*
 1244           ;                   【偏向撞击保护的编程】
 1244           ;                       （1）一旦手指碰撞到限位开关产生低电平，哪怕是抖动、不稳定的低电平，
 1244           ;                       也要禁止手指继续向碰撞位置移动，此时不需要延迟防抖的处理；
 1244           ;                       （2）只有当手指真正完全地离开了碰撞地点，限位开关IO成为稳定的高电平，
 1244           ;                       才允许手指再次向碰撞的方向移动。
 1244           ;               */
 1244           ;               
 1244           ;               if(!(PINE & BIT(5)))//检测手指0是否复位
 1244 0D99              sbic 0x1,5
 1246 27C0              rjmp L454
 1248           X114:
 1248                   .dbline 1354
 1248           ;               {
 1248                   .dbline 1355
 1248           ;                       if(stop_allow_cage_0)
 1248 0EA4              ldd R0,y+46
 124A 0020              tst R0
 124C 89F1              breq L455
 124E           X115:
 124E                   .dbline 1356
 124E           ;                       {
 124E                   .dbline 1357
 124E           ;                           release_allow_motor_0=0;//禁止1号手指向端部靠近
 124E 0024              clr R0
 1250 0BAA              std y+51,R0
 1252                   .dbline 1358
 1252           ;                               hold_allow_motor_0=1;//允许1号手指向中间靠近
 1252 0024              clr R0
 1254 0394              inc R0
 1256 09AA              std y+49,R0
 1258                   .dbline 1359
 1258           ;                               TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 1258 87B7              in R24,0x37
 125A 8B7F              andi R24,251
 125C 87BF              out 0x37,R24
 125E                   .dbline 1360
 125E           ;                               delay(50);
 125E 02E3              ldi R16,50
 1260 10E0              ldi R17,0
 1262 0E940000          xcall _delay
 1266                   .dbline 1361
 1266           ;                               uart1_send_string((uchar*)no0stop,9);
 1266 29E0              ldi R18,9
 1268 00E0              ldi R16,<_no0stop
 126A 10E0              ldi R17,>_no0stop
 126C 0E943401          xcall _uart1_send_string
 1270                   .dbline 1362
 1270           ;                               delay(50);
 1270 02E3              ldi R16,50
 1272 10E0              ldi R17,0
 1274 0E940000          xcall _delay
 1278                   .dbline 1363
 1278           ;                               uart0_send_string("zz30");
 1278 00E0              ldi R16,<L458
 127A 10E0              ldi R17,>L458
 127C 0E94C600          xcall _uart0_send_string
 1280                   .dbline 1364
 1280           ;                               delay(50);
 1280 02E3              ldi R16,50
 1282 10E0              ldi R17,0
 1284 0E940000          xcall _delay
 1288                   .dbline 1365
 1288           ;                               uart0_send_string("zz30");
 1288 00E0              ldi R16,<L458
 128A 10E0              ldi R17,>L458
 128C 0E94C600          xcall _uart0_send_string
 1290                   .dbline 1366
 1290           ;                               stop_allow_cage_0=0;
 1290 0024              clr R0
 1292 0EA6              std y+46,R0
 1294                   .dbline 1367
 1294           ;                       }
 1294                   .dbline 1368
 1294           ;               }
 1294 0DC0              xjmp L455
 1296           L454:
 1296                   .dbline 1370
 1296           ;               else
 1296           ;               {
 1296                   .dbline 1371
 1296           ;                   if(!stop_allow_cage_0)
 1296 0EA4              ldd R0,y+46
 1298 0020              tst R0
 129A 51F4              brne L459
 129C           X116:
 129C                   .dbline 1372
 129C           ;                       {
 129C                   .dbline 1373
 129C           ;                           delay(500);
 129C 04EF              ldi R16,500
 129E 11E0              ldi R17,1
 12A0 0E940000          xcall _delay
 12A4                   .dbline 1374
 12A4           ;                           if(PINE & BIT(5))
 12A4 0D9B              sbis 0x1,5
 12A6 04C0              rjmp L461
 12A8           X117:
 12A8                   .dbline 1375
 12A8           ;                               {
 12A8                   .dbline 1376
 12A8           ;                                   release_allow_motor_0=1;//允许1号手指向端部靠近
 12A8 0024              clr R0
 12AA 0394              inc R0
 12AC 0BAA              std y+51,R0
 12AE                   .dbline 1377
 12AE           ;                                       stop_allow_cage_0=1;
 12AE 0EA6              std y+46,R0
 12B0                   .dbline 1378
 12B0           ;                               }
 12B0           L461:
 12B0                   .dbline 1379
 12B0           ;                       }
 12B0           L459:
 12B0                   .dbline 1380
 12B0           ;               }
 12B0           L455:
 12B0                   .dbline 1382
 12B0           ;               
 12B0           ;               if(!(PINE & BIT(6)))//检测手指1是否复位
 12B0 0E99              sbic 0x1,6
 12B2 27C0              rjmp L463
 12B4           X118:
 12B4                   .dbline 1383
 12B4           ;               {
 12B4                   .dbline 1384
 12B4           ;                       if(stop_allow_cage_1)
 12B4 0FA4              ldd R0,y+47
 12B6 0020              tst R0
 12B8 89F1              breq L464
 12BA           X119:
 12BA                   .dbline 1385
 12BA           ;                       {
 12BA                   .dbline 1386
 12BA           ;                           release_allow_motor_1=0;//禁止1号手指向端部靠近
 12BA 0024              clr R0
 12BC 0CAA              std y+52,R0
 12BE                   .dbline 1387
 12BE           ;                               hold_allow_motor_1=1;//允许1号手指向中间靠近
 12BE 0024              clr R0
 12C0 0394              inc R0
 12C2 0AAA              std y+50,R0
 12C4                   .dbline 1388
 12C4           ;                               TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 12C4 87B7              in R24,0x37
 12C6 8B7F              andi R24,251
 12C8 87BF              out 0x37,R24
 12CA                   .dbline 1389
 12CA           ;                               delay(50);
 12CA 02E3              ldi R16,50
 12CC 10E0              ldi R17,0
 12CE 0E940000          xcall _delay
 12D2                   .dbline 1390
 12D2           ;                               uart1_send_string((uchar*)no1stop,9);
 12D2 29E0              ldi R18,9
 12D4 00E0              ldi R16,<_no1stop
 12D6 10E0              ldi R17,>_no1stop
 12D8 0E943401          xcall _uart1_send_string
 12DC                   .dbline 1391
 12DC           ;                               delay(50);
 12DC 02E3              ldi R16,50
 12DE 10E0              ldi R17,0
 12E0 0E940000          xcall _delay
 12E4                   .dbline 1392
 12E4           ;                               uart0_send_string("zz31");
 12E4 00E0              ldi R16,<L467
 12E6 10E0              ldi R17,>L467
 12E8 0E94C600          xcall _uart0_send_string
 12EC                   .dbline 1393
 12EC           ;                               delay(50);
 12EC 02E3              ldi R16,50
 12EE 10E0              ldi R17,0
 12F0 0E940000          xcall _delay
 12F4                   .dbline 1394
 12F4           ;                               uart0_send_string("zz31");
 12F4 00E0              ldi R16,<L467
 12F6 10E0              ldi R17,>L467
 12F8 0E94C600          xcall _uart0_send_string
 12FC                   .dbline 1395
 12FC           ;                               stop_allow_cage_1=0;
 12FC 0024              clr R0
 12FE 0FA6              std y+47,R0
 1300                   .dbline 1396
 1300           ;                       }
 1300                   .dbline 1397
 1300           ;               }
 1300 0DC0              xjmp L464
 1302           L463:
 1302                   .dbline 1399
 1302           ;               else
 1302           ;               {
 1302                   .dbline 1400
 1302           ;                       if(!stop_allow_cage_1)
 1302 0FA4              ldd R0,y+47
 1304 0020              tst R0
 1306 51F4              brne L468
 1308           X120:
 1308                   .dbline 1401
 1308           ;                       {
 1308                   .dbline 1402
 1308           ;                           delay(500);
 1308 04EF              ldi R16,500
 130A 11E0              ldi R17,1
 130C 0E940000          xcall _delay
 1310                   .dbline 1403
 1310           ;                           if(PINE & BIT(6))
 1310 0E9B              sbis 0x1,6
 1312 04C0              rjmp L470
 1314           X121:
 1314                   .dbline 1404
 1314           ;                               {
 1314                   .dbline 1405
 1314           ;                                   release_allow_motor_1=1;//允许1号手指向端部靠近
 1314 0024              clr R0
 1316 0394              inc R0
 1318 0CAA              std y+52,R0
 131A                   .dbline 1406
 131A           ;                                       stop_allow_cage_1=1;
 131A 0FA6              std y+47,R0
 131C                   .dbline 1407
 131C           ;                               }
 131C           L470:
 131C                   .dbline 1408
 131C           ;                       }
 131C           L468:
 131C                   .dbline 1409
 131C           ;               }
 131C           L464:
 131C                   .dbline 1411
 131C           ; 
 131C           ;               if(!(PINE & BIT(7)))//检测是否空夹
 131C 0F99              sbic 0x1,7
 131E 2EC0              rjmp L472
 1320           X122:
 1320                   .dbline 1412
 1320           ;               {
 1320                   .dbline 1413
 1320           ;                       if(stop_allow_empty)
 1320 08A8              ldd R0,y+48
 1322 0020              tst R0
 1324 C9F1              breq L473
 1326           X123:
 1326                   .dbline 1414
 1326           ;                       {
 1326                   .dbline 1415
 1326           ;                           hold_allow_motor_0=0;//禁止0号手指向端部靠近
 1326 0024              clr R0
 1328 09AA              std y+49,R0
 132A                   .dbline 1416
 132A           ;                               hold_allow_motor_1=0;//禁止1号手指向端部靠近
 132A 0AAA              std y+50,R0
 132C                   .dbline 1417
 132C           ;                               TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
 132C 87B7              in R24,0x37
 132E 8B7F              andi R24,251
 1330 87BF              out 0x37,R24
 1332                   .dbline 1418
 1332           ;                               delay(50);
 1332 02E3              ldi R16,50
 1334 10E0              ldi R17,0
 1336 0E940000          xcall _delay
 133A                   .dbline 1419
 133A           ;                               uart1_send_string((uchar*)no1stop,9);
 133A 29E0              ldi R18,9
 133C 00E0              ldi R16,<_no1stop
 133E 10E0              ldi R17,>_no1stop
 1340 0E943401          xcall _uart1_send_string
 1344                   .dbline 1420
 1344           ;                               delay(50);
 1344 02E3              ldi R16,50
 1346 10E0              ldi R17,0
 1348 0E940000          xcall _delay
 134C                   .dbline 1421
 134C           ;                               uart1_send_string((uchar*)no0stop,9);
 134C 29E0              ldi R18,9
 134E 00E0              ldi R16,<_no0stop
 1350 10E0              ldi R17,>_no0stop
 1352 0E943401          xcall _uart1_send_string
 1356                   .dbline 1422
 1356           ;                               delay(50);
 1356 02E3              ldi R16,50
 1358 10E0              ldi R17,0
 135A 0E940000          xcall _delay
 135E                   .dbline 1423
 135E           ;                               uart0_send_string("zz32");
 135E 00E0              ldi R16,<L476
 1360 10E0              ldi R17,>L476
 1362 0E94C600          xcall _uart0_send_string
 1366                   .dbline 1424
 1366           ;                               delay(50);
 1366 02E3              ldi R16,50
 1368 10E0              ldi R17,0
 136A 0E940000          xcall _delay
 136E                   .dbline 1425
 136E           ;                               uart0_send_string("zz32");
 136E 00E0              ldi R16,<L476
 1370 10E0              ldi R17,>L476
 1372 0E94C600          xcall _uart0_send_string
 1376                   .dbline 1426
 1376           ;                               stop_allow_empty=0;
 1376 0024              clr R0
 1378 08AA              std y+48,R0
 137A                   .dbline 1427
 137A           ;                       }
 137A                   .dbline 1428
 137A           ;               }
 137A 0EC0              xjmp L473
 137C           L472:
 137C                   .dbline 1430
 137C           ;               else
 137C           ;               {
 137C                   .dbline 1431
 137C           ;                       if(!stop_allow_empty)
 137C 08A8              ldd R0,y+48
 137E 0020              tst R0
 1380 59F4              brne L477
 1382           X124:
 1382                   .dbline 1432
 1382           ;                       {
 1382                   .dbline 1433
 1382           ;                           delay(500);
 1382 04EF              ldi R16,500
 1384 11E0              ldi R17,1
 1386 0E940000          xcall _delay
 138A                   .dbline 1434
 138A           ;                           if(PINE & BIT(7))
 138A 0F9B              sbis 0x1,7
 138C 05C0              rjmp L479
 138E           X125:
 138E                   .dbline 1435
 138E           ;                               {
 138E                   .dbline 1436
 138E           ;                                   hold_allow_motor_0=1;//允许0号手指向中间靠近
 138E 0024              clr R0
 1390 0394              inc R0
 1392 09AA              std y+49,R0
 1394                   .dbline 1437
 1394           ;                                       hold_allow_motor_1=1;//允许1号手指向中间靠近
 1394 0AAA              std y+50,R0
 1396                   .dbline 1438
 1396           ;                                       stop_allow_empty=1;
 1396 08AA              std y+48,R0
 1398                   .dbline 1439
 1398           ;                               }
 1398           L479:
 1398                   .dbline 1440
 1398           ;                       }
 1398           L477:
 1398                   .dbline 1441
 1398           ;               }
 1398           L473:
 1398                   .dbline 1443
 1398           ;               
 1398           ;       }
 1398           L217:
 1398                   .dbline 833
 1398 12CB              xjmp L216
 139A           X126:
 139A                   .dbline -2
 139A           L197:
 139A                   .dbline 0 ; func end
 139A E696              adiw R28,54
 139C 0895              ret
 139E                   .dbsym l com_finger1_ratio_2_PARA3 45 c
 139E                   .dbsym l com_finger1_ratio_2_PARA2 44 c
 139E                   .dbsym l com_finger0_ratio_2_PARA3 43 c
 139E                   .dbsym l com_finger0_ratio_2_PARA2 42 c
 139E                   .dbsym l com_finger1_ratio_3_PARA3 41 c
 139E                   .dbsym l com_finger1_ratio_3_PARA2 40 c
 139E                   .dbsym l com_finger1_ratio_1_PARA3 39 c
 139E                   .dbsym l com_finger1_ratio_1_PARA2 38 c
 139E                   .dbsym l com_finger0_ratio_3_PARA3 37 c
 139E                   .dbsym l com_finger0_ratio_3_PARA2 36 c
 139E                   .dbsym l com_finger0_ratio_1_PARA3 35 c
 139E                   .dbsym l com_finger0_ratio_1_PARA2 34 c
 139E                   .dbsym l hold_stage_2_continue 53 c
 139E                   .dbsym r CHECK 10 c
 139E                   .dbsym r approach_1 14 c
 139E                   .dbsym r approach_0 12 c
 139E                   .dbsym r PARA3 22 c
 139E                   .dbsym r PARA2 20 c
 139E                   .dbsym l release_allow_motor_1 52 c
 139E                   .dbsym l release_allow_motor_0 51 c
 139E                   .dbsym l motor_command 25 A[9:9]c
 139E                   .dbsym l hold_allow_motor_1 50 c
 139E                   .dbsym l hold_allow_motor_0 49 c
 139E                   .dbsym l msg_eeprom_array 8 A[17:17]c
 139E                   .dbsym l msg_interrupt_array 1 A[7:7]c
 139E                   .dbsym l stop_allow_empty 48 c
 139E                   .dbsym l stop_allow_cage_1 47 c
 139E                   .dbsym l stop_allow_cage_0 46 c
 139E                   .dbsym r cage_1 12 c
 139E                   .dbsym r cage_0 10 c
 139E                   .dbsym r i 10 c
 139E                   .dbend
                        .area bss(ram, con, rel)
 0003                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0003           _force_ulong::
 0003                   .blkb 4
 0007                   .dbsym e force_ulong _force_ulong l
 0007           _force_judge::
 0007                   .blkb 1
 0008                   .dbsym e force_judge _force_judge c
 0008           _force_high8::
 0008                   .blkb 1
 0009                   .dbsym e force_high8 _force_high8 c
 0009           _uart0_instr::
 0009                   .blkb 5
 000E                   .dbsym e uart0_instr _uart0_instr A[5:5]c
 000E           _uart0_rdata_byte::
 000E                   .blkb 1
 000F                   .dbsym e uart0_rdata_byte _uart0_rdata_byte c
 000F           _cage1_state::
 000F                   .blkb 1
 0010                   .dbsym e cage1_state _cage1_state c
 0010           _cage0_state::
 0010                   .blkb 1
 0011                   .dbsym e cage0_state _cage0_state c
                        .area data(ram, con, rel)
 0043                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0043           L476:
 0043                   .blkb 5
                        .area idata
 0043 7A7A333200        .byte 'z,'z,51,50,0
                        .area data(ram, con, rel)
 0048                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0048           L467:
 0048                   .blkb 5
                        .area idata
 0048 7A7A333100        .byte 'z,'z,51,49,0
                        .area data(ram, con, rel)
 004D                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 004D           L458:
 004D                   .blkb 5
                        .area idata
 004D 7A7A333000        .byte 'z,'z,51,48,0
                        .area data(ram, con, rel)
 0052                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0052           L446:
 0052                   .blkb 5
                        .area idata
 0052 3334303000        .byte 51,52,48,48,0
                        .area data(ram, con, rel)
 0057                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0057           L443:
 0057                   .blkb 5
                        .area idata
 0057 3333303000        .byte 51,51,48,48,0
                        .area data(ram, con, rel)
 005C                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 005C           L440:
 005C                   .blkb 5
                        .area idata
 005C 3332303000        .byte 51,50,48,48,0
                        .area data(ram, con, rel)
 0061                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0061           L437:
 0061                   .blkb 5
                        .area idata
 0061 3331303000        .byte 51,49,48,48,0
                        .area data(ram, con, rel)
 0066                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0066           L418:
 0066                   .blkb 5
                        .area idata
 0066 3235303000        .byte 50,53,48,48,0
                        .area data(ram, con, rel)
 006B                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 006B           L414:
 006B                   .blkb 3
                        .area idata
 006B 323400            .byte 50,52,0
                        .area data(ram, con, rel)
 006E                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 006E           L411:
 006E                   .blkb 5
                        .area idata
 006E 3233313300        .byte 50,51,49,51,0
                        .area data(ram, con, rel)
 0073                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0073           L408:
 0073                   .blkb 5
                        .area idata
 0073 3233313200        .byte 50,51,49,50,0
                        .area data(ram, con, rel)
 0078                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0078           L405:
 0078                   .blkb 5
                        .area idata
 0078 3233313100        .byte 50,51,49,49,0
                        .area data(ram, con, rel)
 007D                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 007D           L402:
 007D                   .blkb 5
                        .area idata
 007D 3233303300        .byte 50,51,48,51,0
                        .area data(ram, con, rel)
 0082                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0082           L399:
 0082                   .blkb 5
                        .area idata
 0082 3233303200        .byte 50,51,48,50,0
                        .area data(ram, con, rel)
 0087                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0087           L396:
 0087                   .blkb 5
                        .area idata
 0087 3233303100        .byte 50,51,48,49,0
                        .area data(ram, con, rel)
 008C                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 008C           L391:
 008C                   .blkb 3
                        .area idata
 008C 323200            .byte 50,50,0
                        .area data(ram, con, rel)
 008F                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 008F           L382:
 008F                   .blkb 5
                        .area idata
 008F 3231313200        .byte 50,49,49,50,0
                        .area data(ram, con, rel)
 0094                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0094           L373:
 0094                   .blkb 5
                        .area idata
 0094 3231313100        .byte 50,49,49,49,0
                        .area data(ram, con, rel)
 0099                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 0099           L370:
 0099                   .blkb 5
                        .area idata
 0099 3231313000        .byte 50,49,49,48,0
                        .area data(ram, con, rel)
 009E                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 009E           L361:
 009E                   .blkb 5
                        .area idata
 009E 3231303200        .byte 50,49,48,50,0
                        .area data(ram, con, rel)
 00A3                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00A3           L352:
 00A3                   .blkb 5
                        .area idata
 00A3 3231303100        .byte 50,49,48,49,0
                        .area data(ram, con, rel)
 00A8                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00A8           L349:
 00A8                   .blkb 5
                        .area idata
 00A8 3231303000        .byte 50,49,48,48,0
                        .area data(ram, con, rel)
 00AD                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00AD           L344:
 00AD                   .blkb 3
                        .area idata
 00AD 313900            .byte 49,57,0
                        .area data(ram, con, rel)
 00B0                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00B0           L339:
 00B0                   .blkb 3
                        .area idata
 00B0 313800            .byte 49,56,0
                        .area data(ram, con, rel)
 00B3                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00B3           L334:
 00B3                   .blkb 3
                        .area idata
 00B3 313700            .byte 49,55,0
                        .area data(ram, con, rel)
 00B6                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00B6           L329:
 00B6                   .blkb 3
                        .area idata
 00B6 313600            .byte 49,54,0
                        .area data(ram, con, rel)
 00B9                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00B9           L324:
 00B9                   .blkb 3
                        .area idata
 00B9 313500            .byte 49,53,0
                        .area data(ram, con, rel)
 00BC                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00BC           L319:
 00BC                   .blkb 3
                        .area idata
 00BC 313400            .byte 49,52,0
                        .area data(ram, con, rel)
 00BF                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00BF           L314:
 00BF                   .blkb 3
                        .area idata
 00BF 313300            .byte 49,51,0
                        .area data(ram, con, rel)
 00C2                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00C2           L310:
 00C2                   .blkb 5
                        .area idata
 00C2 7A7A313000        .byte 'z,'z,49,48,0
                        .area data(ram, con, rel)
 00C7                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00C7           L268:
 00C7                   .blkb 5
                        .area idata
 00C7 3132303000        .byte 49,50,48,48,0
                        .area data(ram, con, rel)
 00CC                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00CC           L253:
 00CC                   .blkb 5
                        .area idata
 00CC 3131303000        .byte 49,49,48,48,0
                        .area data(ram, con, rel)
 00D1                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00D1           L234:
 00D1                   .blkb 5
                        .area idata
 00D1 3130303000        .byte 49,48,48,48,0
                        .area data(ram, con, rel)
 00D6                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00D6           L230:
 00D6                   .blkb 5
                        .area idata
 00D6 3032303000        .byte 48,50,48,48,0
                        .area data(ram, con, rel)
 00DB                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00DB           L227:
 00DB                   .blkb 5
                        .area idata
 00DB 3031303000        .byte 48,49,48,48,0
                        .area data(ram, con, rel)
 00E0                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00E0           L215:
 00E0                   .blkb 5
                        .area idata
 00E0 7A7A303000        .byte 'z,'z,48,48,0
                        .area data(ram, con, rel)
 00E5                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00E5           L196:
 00E5                   .blkb 5
                        .area idata
 00E5 7A7A343300        .byte 'z,'z,52,51,0
                        .area data(ram, con, rel)
 00EA                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00EA           L192:
 00EA                   .blkb 5
                        .area idata
 00EA 7A7A343200        .byte 'z,'z,52,50,0
                        .area data(ram, con, rel)
 00EF                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00EF           L188:
 00EF                   .blkb 5
                        .area idata
 00EF 7A7A343100        .byte 'z,'z,52,49,0
                        .area data(ram, con, rel)
 00F4                   .dbfile I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
 00F4           ; }
 00F4           ; 
 00F4           ; /*
 00F4           ; 【开发者说】
 00F4           ; 
 00F4           ; 大循环限位检测时，为了避免做必要的检测，特意使用了一些变量进行限制，这些变量
 00F4           ; 是从“何时才能”检测这个角度设置的，因此这些变量的值并不能完全表明手指运动的
 00F4           ; 状态。这样做的缺点是不可避免有人特意扰乱夹持器执行动作，例如：当夹持器手指向
 00F4           ; 中间方向移动时（即夹紧物体时），若有人故意按下两端限位开关，则夹持器会认为手
 00F4           ; 指已经移动到端部。但很明显这样是不可能的，因为舵机根本没有往端部方向移动。如
 00F4           ; 果要防止有人故意运行，则建议将那些用于对检测做限制的变量改为反映手指运行状态
 00F4           ; 的变量，根据手指动作状态来决定是否检测某些限位。
 00F4           ; 
 00F4           ; 另外，不使用中断是因为始终没有解决多次触发的问题，即使在使用软件消抖的前提下。
 00F4           ; 
 00F4           ; 调试配置模式下何时决定停止读取夹紧力值也存在bug――两指均运行，此时停止其中一
 00F4           ; 个，另外一个保持运动时，读取已经停止了。但这个bug在实际配置测量力阈值时应该不
 00F4           ; 会出现，因为我们往往先终止一个手指的运动，靠调节另一个手指的位置来设置力阈值。
 00F4           ; 
 00F4           ; */
