//----------【硬件配置说明】↓------------------------------------------------------------
//舵机：波特率19200，电源DC12V，ID：0和1
//电源线和控制线的电平互不干扰
//电源2根，RS485两根
//UART0用于MCU和PC的通信，波特率19200
//UART1用于MCU和舵机的通信，波特率19200

//----------【头文件】↓------------------------------------------------------------
#include <iom128v.h>
#include <macros.h>
#include <string.h>

//----------【宏定义】↓------------------------------------------------------------
#define  uchar unsigned char
#define  uint  unsigned int

#define  mclk   8000000 //时钟频率8.0MHz

//----------【全局变量定义】↓------------------------------------------------------------

uchar gripper_mood=0;//夹持器模式：0-未指定；1-一般工作模式；2-参数配置模式

uchar no0release[]={0xff,0xff,0x00,0x05,0x03,0x20,0xff,0x07,0xd1};//0号舵机松开（顺时针，力矩100%）
uchar no0stop[]={0xff,0xff,0x00,0x05,0x03,0x20,0x00,0x00,0xd7}; //0号舵机停止（逆时针，力矩0%）
uchar no1release[]={0xff,0xff,0x01,0x05,0x03,0x20,0xff,0x07,0xd0};//1号舵机松开（顺时针，力矩100%）
uchar no1stop[]={0xff,0xff,0x01,0x05,0x03,0x20,0x00,0x00,0xd6}; //1号舵机停止（逆时针，力矩0%）

uchar cage0_state,cage1_state;//表明夹持器两端限位情况

/*以下变量用于建立上位机指令处理机制*/
uchar uart0_rdata_byte;//UART0每次接收到的单字节信息
uchar uart0_r_instr_chk=0;//uart0接收到的字符串开头中x字符的个数
uchar uart0_instr[5];//存储PC发给MCU的指令，不包含xx，仅包含四位指令代码，最后一位为NULL
uchar uart0_instr_flag=0;//UART0中断接收到开头和长度符合要求的instr时置为1


//--------------【软件延时函数】--------------------------------------------------------------------

//延时函数，参数为要延时的毫秒数
void delay(uint ms)
{
    uint i,j;
	for(i=0;i<ms;i++)
	{
	 for(j=0;j<1141;j++);
    }
}


//----------【UART0的相关函数】↓---------------------------------------------------------------

/*UART0的串口初始化函数*/
void uart0_init(uint baud)
{
   UCSR0B=0x00; 
   UCSR0A=0x00; 		   //控制寄存器清零
   UCSR0C=(0<<UPM00)|(3<<UCSZ00); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
   
   baud=mclk/16/baud-1;    //波特率最大为65K
   UBRR0L=baud; 					     	  
   UBRR0H=baud>>8; 		   //设置波特率
   
   UCSR0B=(1<<TXEN0)|(1<<RXEN0)|(1<<RXCIE0);   //接收、发送使能，接收中断使能
   SREG=BIT(7);	           //全局中断开放
   DDRE|=BIT(1);	           //配置TX为输出（很重要），似乎对于MEGA1280来说没用
}

/*UART0的串口发送函数，每次发送一个字节（Byte）*/
void uart0_sendB(uchar data)
{
   while(!(UCSR0A&(BIT(UDRE0))));//判断准备就绪否
   UDR0=data;
   while(!(UCSR0A&(BIT(TXC0))));//判断完成发送否
   UCSR0A|=BIT(TXC0);//TXC0标志位手动清零，通过将TXC0置1实现
}

#pragma interrupt_handler uart0_rx:19

/*UART0的串口接收函数，每次接收一个字节（Byte）*/
void uart0_rx(void)
{
 	uchar uart0_r_byte;//UART0每次中断接收到的字符（1byte）
	UCSR0B&=~BIT(RXCIE0);//关闭RXCIE1，其余位保持不变
	uart0_r_byte=UDR0;
	if(uart0_instr_make(uart0_r_byte)==0)//通过接受字符串，产生符合要求的instr
	    {UCSR0B|=BIT(RXCIE0);}//使能RXCIE1，其余位保持不变
}

//UART0的指令识别函数，从接收到的字符中提取出以xx开头的指令字符串
uchar uart0_instr_make(uchar r_byte)
{
    uchar instr_num;//instr中已有的字符数
	uchar fun_ret;//存储本函数返回值 
    switch(uart0_r_instr_chk)//根据已有x的个数进行操作
	{
	    case 0:
			 {
			 if(r_byte=='x')
			     {				 
				 uart0_r_instr_chk=1;
				 }
			 fun_ret=0;
			 break;
			 }
		case 1:
			 {
			 if(r_byte=='x')
			     {uart0_r_instr_chk=2;}
			 else
			 	 {uart0_r_instr_chk=0;}
			 fun_ret=0;
			 break;
			 }
		case 2:
			 {
			 instr_num=strlen(uart0_instr);
			 if(instr_num==3)
			 {
			     uart0_instr[instr_num]=r_byte;
				 uart0_instr_flag=1;//instr已经满足开头xx和长度要求，flag置1，进行命令处理
			     fun_ret=1;				 
			 }
			 else
			 {
			     uart0_instr[instr_num]=r_byte;
				 fun_ret=0;
			 }
			 break;
			 }
		default:break;
	}
	return fun_ret;
}

/*UART0字符串发送函数*/
void uart0_send_string(uchar *str_send)//形参：待发送字符串
{
 	 uchar str_send_num=strlen(str_send);//待发送字符串包含的字符数，
	 	   								//数组str_send最后一位值为NULL
	 uchar i=0;
	 while(i<str_send_num)
	 {
	   uart0_sendB(*(str_send+i));
	   i+=1;
	 }
}


//------------【UART1的相关函数】↓-------------------------------------------------------------

/*UART1的串口初始化函数*/
void uart1_init(uint baud)
{
   UCSR1B=0x00; 
   UCSR1A=0x00; 		   //控制寄存器清零
   UCSR1C=(0<<UPM10)|(3<<UCSZ10); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
   
   baud=mclk/16/baud-1;    //波特率最大为65K
   UBRR1L=baud; 					     	  
   UBRR1H=baud>>8; 		   //设置波特率
   
   UCSR1B=(1<<TXEN1)|(1<<RXEN1)|(1<<RXCIE1);   //接收、发送使能，接收中断使能
   SREG=BIT(7);	           //全局中断开放
   DDRD|=BIT(3);	           //配置TX为输出（很重要），似乎对于MEGA1280来说没用
}


/*UART1的串口发送函数，每次发送一个字节（Byte）*/
void uart1_sendB(uchar data)
{
   while(!(UCSR1A&(BIT(UDRE1))));//判断准备就绪否
   UDR1=data;
   while(!(UCSR1A&(BIT(TXC1))));//判断完成发送否
   UCSR1A|=BIT(TXC1);//TXC1标志位手动清零，通过将TXC1置1实现
}

/*UART1字符串发送函数*/
void uart1_send_string(uchar *str_send,uchar str_num)//形参：待发送字符串
{
	 uchar i=0;
	 while(i<str_num)
	 {
	   uart1_sendB(*(str_send+i));
	   i+=1;
	   //delay(10);
	 }
}

//#pragma interrupt_handler uart1_rx:31

/*
void uart1_rx(void)
{	
    UCSR1B&=~BIT(RXCIE1);
	//rdata=UDR1;
	//flag=1;
	UCSR1B|=BIT(RXCIE1);
}
*/


//------------------【字符串处理函数】↓-------------------------------------------------------

//数组元素拷贝函数
void array_copy(uchar *array1,uchar start_index,uchar *array2,uchar copy_num)
//将array1中自第start_index位起的copy_num个元素拷贝到array2的第0到copy_num-1位
//array1的元素数目不应小于start_index+copy_num+1个，array2的元素数目不应小于copy_num个
{
    uchar i;
	for(i=0;i<copy_num;i++)
	{
	    array2[i]=array1[start_index+i];
	}
}

//字符数组或字符串比较函数：若返回0，则表示相等，否则不等
//*str0或*str1可以使数组(例如array_eg[])，也可以是字符串常量(例如"abcd")
int array_cmp(char * str0, char * str1)
{
    int i;
    for(i=0;str0[i]!=0 && str1[i]!=0 && str0[i]==str1[i];i++);
    return str0[i]-str1[i];
}



//----------------【应变片数据读取函数】↓--------------------------------
unsigned long ReadCount(void)
{
    unsigned long Count;
    unsigned char i;
    PORTA&=(~BIT(1));//ADSK=PORTA1=0
    Count=0;
    while(PINA&BIT(0));//读取PINA0=ADDO
    for(i=0;i<24;i++)
    {
        PORTA|=BIT(1);//ADSK=PORTA1=1
        Count=Count<<1;
        PORTA&=(~BIT(1));//ADSK=PORTA1=0
        if(PINA&BIT(0)) Count++;
		uart0_sendB(i);
    }
    PORTA|=BIT(1);//ADSK=PORTA1=1
    Count=Count^0x800000;
    PORTA&=(~BIT(1));//ADSK=PORTA1=0
    return(Count);
}

//unsigned long型数字转成字符串，用于将应变片采集回的数据上传
uchar* ulong_to_uchar_array(unsigned long data_num)
{
 	//long型在内存中的存储 0x12345678 →低地址78+56+34+12高地址
	uchar* pNum;
	uchar force_data[5];
	pNum=(uchar *)&data_num;
	force_data[3]=*pNum;
	force_data[2]=*(++pNum);
	force_data[1]=*(++pNum);
	force_data[0]=*(++pNum);
	force_data[4]=0;
	return force_data;
}

//----------------【外部中断向量定义与外部中断处理函数】↓--------------------------------

//限位0（INT5）中断向量定义 //int5-cage1
#pragma interrupt_handler cage0_interrupt_handler:7

//限位0（INT5）中断处理函数
void cage0_interrupt_handler(void)
{
    uart1_send_string(no0stop,9);//0号舵机停止
    cage0_state=1;//全局变量
}

//限位1（INT6）中断向量定义 //int6-cage2
#pragma interrupt_handler cage1_interrupt_handler:8

//限位1（INT6）中断处理函数
void cage1_interrupt_handler(void)
{
     uart1_send_string(no1stop,9);//1号舵机停止
     cage1_state=1;//全局变量
}


//---------------------------【主函数】↓-----------------------------------------------------------
void main(void)
{

 	//.....................[函数体内变量声明]...............................

 	uchar i;//清空指令存储变量时所用循环的计数变量
	unsigned long force_ulong;

	
	//........................[串口通信配置].........................
	//波特率均设为19200
    uart0_init(19200);
    uart1_init(19200);
	
	//RS485芯片设置为发送，DE=PD5=1
	//注意！该芯片为半双工通信，不可同时收和发，配置引脚时应注意这一点
	DDRD|=BIT(5);
    PORTD|=BIT(5);

	DDRD|=BIT(4);
    PORTD|=BIT(4);
	
	//delay(500);
	
	//................[应变片读取配置]....................................
	/*A0-DT ADDO：单片机从DT读取数据;A1-SCK ADSK：单片机输出高低电平到SCK*/
	//PA0配置成高阻态输入
	DDRA&=(~BIT(0));//DDRA0=0
	PORTA&=(~BIT(0));//PORTA0=0

	//PA1配置成输出
	DDRA|=BIT(1);//DDRA1=1
	
	
	//................[功能：上电后手指复位]....................................
	
	//两端限位的配置
	
    //PE5=INT5=限位0，带上拉电阻输入
    DDRE&=(~BIT(5));//意思是DDRE5=0，其余位不变。但注意不可按注释的方式写！
    PORTE|=BIT(5);//意思是PORTE5=1，其余位不变。但注意不可按注释的方式写！

    //PE6=INT6=限位1，带上拉电阻输入
    DDRE&=(~BIT(6));
    PORTE|=BIT(6);

    //INT5和INT6的外部中断寄存器配置
    EICRB|=(0<<ISC51)|(0<<ISC50)|(0<<ISC61)|(0<<ISC60);//中断触发方式：低电平触发
    EIMSK|=(1<<INT5)|(1<<INT6);//中断使能

    SREG |= 0X80;//打开全局中断
    
    //相关变量初始化
    cage0_state=0;
    cage1_state=0;

    //命令舵机停止转动
    uart1_send_string(no0stop,9);
	delay(50);
	uart1_send_string(no1stop,9);
    delay(50);
	
    //使手爪松开
    uart1_send_string(no0release,9);
	delay(50);
    uart1_send_string(no1release,9);

    //等待两端限位中断的触发
    while(!(cage0_state & cage1_state));
    //cage0_state和cage1_state均为True时，跳出while循环
    
    uart0_send_string("Get ready! ");//向上位机报告准备就绪

    //恢复全局变量，方便以后使用
    cage0_state=0;
    cage1_state=0;
	
//........................[while(1)大循环]............................................
	
    while(1)
	{
	 	 if(uart0_instr_flag==1)
		 {
	         switch(gripper_mood)
		     {
	             case 0:
			     {
			         if(array_cmp(uart0_instr,"0100")==0)
				     {
				         uart0_send_string(" mood 0: enter 1-regular working mood! ");
					 	 gripper_mood=1;
				     }
				 
				 	 if(array_cmp(uart0_instr,"0200")==0)
				 	 {
				         uart0_send_string(" mood 0: enter 2-configuration mood! ");
					 	 gripper_mood=2;
				 	 }
				 
				 	 break;
			     }
			 
		         case 1:
			     {
			     	 if(array_cmp(uart0_instr,"1100")==0)
				 	 {
				         uart0_send_string(" mood 1: run! ");
					 	 uart1_send_string(no1release,9);
				 	 }
				 
				 	 if(array_cmp(uart0_instr,"1200")==0)
				 	 {
				         uart0_send_string("mood 1: stop! ");
					 	 uart1_send_string(no1stop,9);
				 	 }
				 
				 	 break;
			     }
			 
		         case 2:
			     {
			     	 if(array_cmp(uart0_instr,"2100")==0)
				 	 {
				         uart0_send_string(" mood 2: run! ");
					     uart1_send_string(no1release,9);
				 	 }
				 
				 	 if(array_cmp(uart0_instr,"2200")==0)
				 	 {
				         uart0_send_string("mood 2: stop! ");
					 	 uart1_send_string(no1stop,9);
				 	 }

				 	 if(array_cmp(uart0_instr,"2500")==0)
				 	 {
					     force_ulong=ReadCount();
						 uart0_send_string(ulong_to_uchar_array(force_ulong));
				 	 }
				 			     
				     break;
			     }
			 
		         default:break;
			 }
			 
			 /*末尾应完成命令执行后的还原工作A-D*/
			 uart0_instr_flag=0; //A.命令接收标志位置0
			 uart0_r_instr_chk=0;//B.命令构造字符数计数置0
			 for(i=0;i<12;i++)//C.命令清除
			 {
		         uart0_instr[i]=0;
			 }
			 UCSR0B|=BIT(RXCIE0);//D.恢复UART0的接收中断			
	     }
	}
}
