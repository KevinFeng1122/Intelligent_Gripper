//波特率19200，电源DC12V，ID：0和1
//电源线和控制线的电平互不干扰
//电源2根，RS485两根
//UART0用于MCU和PC的通信
//UART1用于MCU和舵机的通信

#include <iom128v.h>
#include <macros.h>
#include <string.h>

#define  uchar unsigned char
#define  uint  unsigned int

#define  mclk   8000000 //时钟频率8.0MHz
#pragma interrupt_handler uart0_rx:19
//#pragma interrupt_handler uart1_rx:31

uchar rdata,flag=0;
uchar no1release[]={0xff,0xff,0x01,0x05,0x03,0x20,0xff,0x07,0xd0};//1号舵机松开（顺时针，力矩100%）
uchar no1stop[]={0xff,0xff,0x01,0x05,0x03,0x20,0x00,0x00,0xd6}; //1号舵机停止（逆时针，力矩0%）

uchar cage1_state,cage2_state;


//延时函数，参数为要延时的毫秒数
void delay(uint ms)
{
    uint i,j;
	for(i=0;i<ms;i++)
	{
	 for(j=0;j<1141;j++);
    }
}

/*UART0的串口初始化函数*/
void uart0_init(uint baud)
{
   UCSR0B=0x00; 
   UCSR0A=0x00; 		   //控制寄存器清零
   UCSR0C=(0<<UPM00)|(3<<UCSZ00); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
   
   baud=mclk/16/baud-1;    //波特率最大为65K
   UBRR0L=baud; 					     	  
   UBRR0H=baud>>8; 		   //设置波特率
   
   UCSR0B=(1<<TXEN0)|(1<<RXEN0)|(1<<RXCIE0);   //接收、发送使能，接收中断使能
   SREG=BIT(7);	           //全局中断开放
   DDRE|=BIT(1);	           //配置TX为输出（很重要），似乎对于MEGA1280来说没用
   
}

/*UART1的串口初始化函数*/
void uart1_init(uint baud)
{
   UCSR1B=0x00; 
   UCSR1A=0x00; 		   //控制寄存器清零
   UCSR1C=(0<<UPM10)|(3<<UCSZ10); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
   
   baud=mclk/16/baud-1;    //波特率最大为65K
   UBRR1L=baud; 					     	  
   UBRR1H=baud>>8; 		   //设置波特率
   
   UCSR1B=(1<<TXEN1)|(1<<RXEN1)|(1<<RXCIE1);   //接收、发送使能，接收中断使能
   SREG=BIT(7);	           //全局中断开放
   DDRD|=BIT(3);	           //配置TX为输出（很重要），似乎对于MEGA1280来说没用
}

/*UART0的串口发送函数，每次发送一个字节（Byte）*/
void uart0_sendB(uchar data)
{
   while(!(UCSR0A&(BIT(UDRE0))));//判断准备就绪否
   UDR0=data;
   while(!(UCSR0A&(BIT(TXC0))));//判断完成发送否
   UCSR0A|=BIT(TXC0);//TXC0标志位手动清零，通过将TXC0置1实现
}

/*UART1的串口发送函数，每次发送一个字节（Byte）*/
void uart1_sendB(uchar data)
{
   while(!(UCSR1A&(BIT(UDRE1))));//判断准备就绪否
   UDR1=data;
   while(!(UCSR1A&(BIT(TXC1))));//判断完成发送否
   UCSR1A|=BIT(TXC1);//TXC1标志位手动清零，通过将TXC1置1实现
}

void uart0_rx(void)
{	
    UCSR0B&=~BIT(RXCIE0);
	rdata=UDR0;
	flag=1;
	UCSR0B|=BIT(RXCIE0);
}
/*
void uart1_rx(void)
{	
    UCSR1B&=~BIT(RXCIE1);
	//rdata=UDR1;
	//flag=1;
	UCSR1B|=BIT(RXCIE1);
}
*/

/*UART0的串口接收函数，每次接收一个字节（Byte）
void uart0_rx(void)
{
 	
    uchar uart0_r_byte;//UART1每次中断接收到的字符（1byte）

	UCSR0B&=~BIT(RXCIE0);//关闭RXCIE1，其余位保持不变
	uart0_r_byte=UDR0;
	if(uart0_instr_make(uart0_r_byte)==0)//通过接受字符串，产生符合要求的instr
	    {UCSR0B|=BIT(RXCIE0);}//使能RXCIE1，其余位保持不变
}
*/

/*UART1的串口接收函数，每次接收一个字节（Byte）
void uart1_rx(void)
{
 	
    uchar uart1_r_byte;//UART1每次中断接收到的字符（1byte）

	UCSR1B&=~BIT(RXCIE1);//关闭RXCIE1，其余位保持不变
	uart1_r_byte=UDR1;
	if(uart1_instr_make(uart1_r_byte)==0)//通过接受字符串，产生符合要求的instr
	    {UCSR1B|=BIT(RXCIE1);}//使能RXCIE1，其余位保持不变
}
*/

/*UART0字符串发送函数*/
void uart0_send_string(uchar *str_send)//形参：待发送字符串
{
 	 uchar str_send_num=strlen(str_send);//待发送字符串包含的字符数，
	 	   								//数组str_send最后一位值为NULL
	 uchar i=0;
	 while(i<str_send_num)
	 {
	   uart0_sendB(*(str_send+i));
	   i+=1;
	 }
}

/*UART1字符串发送函数*/
void uart1_send_string(uchar *str_send,uchar str_num)//形参：待发送字符串
{
	 uchar i=0;
	 while(i<str_num)
	 {
	   uart1_sendB(*(str_send+i));
	   i+=1;
	   //delay(10);
	 }
	 /* changed
	 uchar i=0;
	 for(;i<str_send_num;i++){
	 uart1_sendB(*(str_send));
	 str_send+=1;
	 }
	 */
}

//限位1（INT5）中断向量定义 //int5-cage1
#pragma interrupt_handler cage1_interrupt_handler:7

//限位1（INT5）中断处理函数
void cage1_interrupt_handler(void)
{
     uart1_send_string(no1stop,9);//1号舵机停止
     cage1_state=1;//全局变量
}

//限位2（INT6）中断向量定义 //int6-cage2
#pragma interrupt_handler cage2_interrupt_handler:8

//限位2（INT6）中断处理函数
void cage2_interrupt_handler(void)
{
     uart1_send_string(no1stop,9);//1号舵机停止
     cage2_state=1;//全局变量
}

void main(void)
{
    //uchar test_array[]={0xf1,0xf2,0xf3,0xf4,0};
	//串口通信的配置
    uart0_init(19200);
    uart1_init(19200);
	
	//RS485芯片设置为发送，DE=PD5=1
	//注意！该芯片为半双工通信，不可同时收和发，配置引脚时应注意这一点
	DDRD|=BIT(5);
    PORTD|=BIT(5);

	DDRD|=BIT(4);
    PORTD|=BIT(4);
	
	delay(500);
	
//-----------------------【功能区域分割线】------------------------------------
	
	//两端限位的配置
	
    //PE5=INT5=限位1，带上拉电阻输入
    DDRE&=(~BIT(5));
    PORTE|=BIT(5);

    //PE6=INT6=限位2，带上拉电阻输入
    DDRE&=(~BIT(6));
    PORTE|=BIT(6);

    //INT5和INT6的外部中断寄存器配置
    EICRB|=(0<<ISC51)|(0<<ISC50)|(0<<ISC61)|(0<<ISC60);//中断触发方式：低电平触发
    EIMSK|=(1<<INT5)|(1<<INT6);//中断使能

    SREG |= 0X80;//打开全局中断
    
    //相关变量初始化
    cage1_state=0;
    cage2_state=0;

    //命令舵机停止转动
    uart1_send_string(no1stop,9);
    delay(50);
//    uart1_send_string();
//    delay(50);

    //使手爪松开
    uart1_send_string(no1release,9);
//    uart1_send_string();

    //等待两端限位中断的触发
    while(!(cage1_state & cage2_state));
    //cage1_state和cage2_state均为True时，跳出while循环
    
    uart0_send_string("Get ready! ");//向上位机报告准备就绪

    //恢复全局变量，方便以后使用
    cage1_state=0;
    cage2_state=0;
	
//-----------------------【功能区域分割线】------------------------------------
	
    while(1)
	{
	    
		if(flag)
		{
		    uart0_sendB(rdata);
			if(rdata=='a')
			{
				uart1_send_string(no1release,9);
				uart0_send_string(" motor 1 run! ");
			}
			
			if(rdata=='b')
			{
				uart1_send_string(no1stop,9);
				uart0_send_string(" motor 1 stop! ");
			}
			
			flag=0;
		}
		
		/*
		uchar i='a';
		uart1_sendB(i);
		delay(500);
		i='b';
		uart1_sendB(i);
		delay(500);
		
	
		
		
		uart1_send_string(no1release,9);
		delay(4500);
		uart1_send_string(no1stop,9);
		delay(4500);
				
		
		uart1_send_string(no1release);
		delay(2500);
		uart1_send_string(no1stop);
		delay(2500);
		*/
	}
}
