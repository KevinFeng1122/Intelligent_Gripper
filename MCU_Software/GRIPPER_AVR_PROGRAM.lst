Interrupt Vectors
    00000 940C 00C0 JMP	__start|__text_start
    00002 940C 0490 JMP	_interrupt_0_handler
    00004 940C 04CA JMP	_interrupt_1_handler
    0000A 940C 0504 JMP	_interrupt_4_handler
    0001C 940C 030F JMP	_timer1_interrupt_handler
    00024 940C 012D JMP	_uart0_rx

Program Code (text area)
__start|__text_start:
    000C0 EFCF      LDI	R28,0xFF
    000C1 E1D0      LDI	R29,0x10
    000C2 BFCD      OUT	0x3D,R28
    000C3 BFDE      OUT	0x3E,R29
    000C4 51CE      SUBI	R28,0x1E
    000C5 40D0      SBCI	R29,0
    000C6 EA0A      LDI	R16,0xAA
    000C7 8308      ST	Y,R16
    000C8 2400      CLR	R0
    000C9 EFE4      LDI	R30,0xF4
    000CA E0F1      LDI	R31,1
    000CB E012      LDI	R17,2
    000CC 30E5      CPI	R30,5
    000CD 07F1      CPC	R31,R17
    000CE F011      BEQ	0x00D1
    000CF 9201      ST	Z+,R0
    000D0 CFFB      RJMP	0x00CC
    000D1 8300      ST	Z,R16
    000D2 E8EC      LDI	R30,0x8C
    000D3 E0F0      LDI	R31,0
    000D4 E0A0      LDI	R26,0
    000D5 E0B1      LDI	R27,1
    000D6 E011      LDI	R17,1
    000D7 E000      LDI	R16,0
    000D8 BF0B      OUT	0x3B,R16
    000D9 38E0      CPI	R30,0x80
    000DA 07F1      CPC	R31,R17
    000DB F021      BEQ	0x00E0
    000DC 95C8      LPM
    000DD 9631      ADIW	R30,1
    000DE 920D      ST	X+,R0
    000DF CFF9      RJMP	0x00D9
    000E0 940E 053E CALL	_main
_exit:
    000E2 CFFF      RJMP	_exit
_delay:
  i                    --> R20
  j                    --> R22
  ms                   --> R16
    000E3 940E 0B3F CALL	push_xgsetF000
FILE: I:\专业资料\项目\飞行器在轨更换\下位机程序\Gripper_AVR_program.c
(0001) //----------【硬件配置说明】↓------------------------------------------------------------
(0002) //舵机：波特率19200，电源DC12V，ID：0和1
(0003) //电源线和控制线的电平互不干扰
(0004) //电源2根，RS485两根
(0005) //UART0用于MCU和PC的通信，波特率19200
(0006) //UART1用于MCU和舵机的通信，波特率19200
(0007) 
(0008) //----------【头文件】↓------------------------------------------------------------
(0009) #include <iom128v.h>
(0010) #include <macros.h>
(0011) #include <string.h>
(0012) 
(0013) //----------【宏定义】↓------------------------------------------------------------
(0014) #define  uchar unsigned char
(0015) #define  uint  unsigned int
(0016) 
(0017) #define  mclk   8000000 //时钟频率8.0MHz
(0018) 
(0019) //----------【常量】↓------------------------------------------------------------
(0020) const uchar Ratio1=1;
(0021) const uchar Ratio2=2;
(0022) const uchar Force=3;
(0023) 
(0024) 
(0025) const uchar no0release[]={0xff,0xff,0x00,0x05,0x03,0x20,0xff,0x07,0xd1};//0号舵机松开（顺时针，力矩100%）
(0026) const uchar no0stop[]={0xff,0xff,0x00,0x05,0x03,0x20,0x00,0x00,0xd7}; //0号舵机停止（逆时针，力矩0%）
(0027) const uchar no1release[]={0xff,0xff,0x01,0x05,0x03,0x20,0xff,0x07,0xd0};//1号舵机松开（顺时针，力矩100%）
(0028) const uchar no1stop[]={0xff,0xff,0x01,0x05,0x03,0x20,0x00,0x00,0xd6}; //1号舵机停止（逆时针，力矩0%）
(0029) 
(0030) //----------【全局变量定义】↓------------------------------------------------------------
(0031) 
(0032) uchar gripper_mood=0;//夹持器模式：0-未指定；1-一般工作模式；2-参数配置模式
(0033) 
(0034) uchar cage0_state,cage1_state;//表明夹持器两端限位情况
(0035) 
(0036) /*以下变量用于建立上位机指令处理机制*/
(0037) uchar uart0_rdata_byte;//UART0每次接收到的单字节信息
(0038) uchar uart0_r_instr_chk=0;//uart0接收到的字符串开头中x字符的个数
(0039) uchar uart0_instr[5];//存储PC发给MCU的指令，不包含xx，仅包含四位指令代码，最后一位为NULL
(0040) uchar uart0_instr_flag=0;//UART0中断接收到开头和长度符合要求的instr时置为1
(0041) 
(0042) //夹持器与外部碰撞报警（中断）允许变量
(0043) uchar ext_collision_alert_allow_int0=0;//上侧
(0044) uchar ext_collision_alert_allow_int1=0;//下侧
(0045) uchar ext_collision_alert_allow_int4=0;//指尖
(0046) 
(0047) uchar force_high8;//应变片返回值高8位aa，long型 00 aa bb cc
(0048) uchar force_judge;//保存存在EEPROM中的应变片的有效值高八位，用于判断夹紧力是否到达要求
(0049) unsigned long force_ulong;//当前应变片测出的数值（占用4 byte，实际有效值3 byte）
(0050) 
(0051) 
(0052) //--------------【软件延时函数】--------------------------------------------------------------------
(0053) 
(0054) //延时函数，参数为要延时的毫秒数
(0055) void delay(uint ms)
(0056) {
(0057)     uint i,j;
(0058) 	for(i=0;i<ms;i++)
    000E5 2744      CLR	R20
    000E6 2755      CLR	R21
    000E7 C00B      RJMP	0x00F3
(0059) 	{
(0060) 	 for(j=0;j<1141;j++);
    000E8 2766      CLR	R22
    000E9 2777      CLR	R23
    000EA C002      RJMP	0x00ED
    000EB 5F6F      SUBI	R22,0xFF
    000EC 4F7F      SBCI	R23,0xFF
    000ED 3765      CPI	R22,0x75
    000EE E0E4      LDI	R30,4
    000EF 077E      CPC	R23,R30
    000F0 F3D0      BCS	0x00EB
    000F1 5F4F      SUBI	R20,0xFF
    000F2 4F5F      SBCI	R21,0xFF
    000F3 1740      CP	R20,R16
    000F4 0751      CPC	R21,R17
    000F5 F390      BCS	0x00E8
    000F6 940C 0B44 JMP	pop_xgsetF000
_uart0_init:
  baud                 --> R10
    000F8 940E 0B49 CALL	push_xgsetF00C
    000FA 0158      MOVW	R10,R16
(0061)     }
(0062) }
(0063) 
(0064) 
(0065) //----------【UART0的相关函数】↓---------------------------------------------------------------
(0066) 
(0067) /*UART0的串口初始化函数*/
(0068) void uart0_init(uint baud)
(0069) {
(0070)    UCSR0B=0x00; 
    000FB 2422      CLR	R2
    000FC B82A      OUT	0x0A,R2
(0071)    UCSR0A=0x00; 		   //控制寄存器清零
    000FD B82B      OUT	0x0B,R2
(0072)    UCSR0C=(0<<UPM00)|(3<<UCSZ00); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
    000FE E086      LDI	R24,6
    000FF 9380 0095 STS	0x95,R24
(0073)    
(0074)    baud=mclk/16/baud-1;    //波特率最大为65K
    00101 0115      MOVW	R2,R10
    00102 2444      CLR	R4
    00103 2455      CLR	R5
    00104 E240      LDI	R20,0x20
    00105 EA51      LDI	R21,0xA1
    00106 E067      LDI	R22,7
    00107 E070      LDI	R23,0
    00108 925A      ST	-Y,R5
    00109 924A      ST	-Y,R4
    0010A 923A      ST	-Y,R3
    0010B 922A      ST	-Y,R2
    0010C 018A      MOVW	R16,R20
    0010D 019B      MOVW	R18,R22
    0010E 940E 0AC9 CALL	div32s
    00110 E041      LDI	R20,1
    00111 E050      LDI	R21,0
    00112 E060      LDI	R22,0
    00113 E070      LDI	R23,0
    00114 0118      MOVW	R2,R16
    00115 0129      MOVW	R4,R18
    00116 1A24      SUB	R2,R20
    00117 0A35      SBC	R3,R21
    00118 0A46      SBC	R4,R22
    00119 0A57      SBC	R5,R23
    0011A 0151      MOVW	R10,R2
(0075)    UBRR0L=baud; 					     	  
    0011B B829      OUT	0x09,R2
(0076)    UBRR0H=baud>>8; 		   //设置波特率
    0011C 2C23      MOV	R2,R3
    0011D 2433      CLR	R3
    0011E 9220 0090 STS	0x90,R2
(0077) 
(0078)    UCSR0B|=(1<<TXEN0);   //UART0发送使能
    00120 9A53      SBI	0x0A,3
(0079)    SREG=BIT(7);	           //全局中断开放
    00121 E880      LDI	R24,0x80
    00122 BF8F      OUT	0x3F,R24
(0080)    DDRE|=BIT(1);	           //配置TX为输出（很重要），似乎对于MEGA1280来说没用
    00123 9A11      SBI	0x02,1
    00124 940C 0B50 JMP	pop_xgsetF00C
(0081) }
(0082) 
(0083) /*UART0的串口发送函数，每次发送一个字节（Byte）*/
(0084) void uart0_sendB(uchar data)
(0085) {
(0086)    while(!(UCSR0A&(BIT(UDRE0))));//判断准备就绪否
_uart0_sendB:
  data                 --> R16
    00126 9B5D      SBIS	0x0B,5
    00127 CFFE      RJMP	_uart0_sendB
(0087)    UDR0=data;
    00128 B90C      OUT	0x0C,R16
(0088)    while(!(UCSR0A&(BIT(TXC0))));//判断完成发送否
    00129 9B5E      SBIS	0x0B,6
    0012A CFFE      RJMP	0x0129
(0089)    UCSR0A|=BIT(TXC0);//TXC0标志位手动清零，通过将TXC0置1实现
    0012B 9A5E      SBI	0x0B,6
    0012C 9508      RET
_uart0_rx:
  uart0_r_byte         --> R10
    0012D 920A      ST	-Y,R0
    0012E 921A      ST	-Y,R1
    0012F 922A      ST	-Y,R2
    00130 923A      ST	-Y,R3
    00131 924A      ST	-Y,R4
    00132 925A      ST	-Y,R5
    00133 926A      ST	-Y,R6
    00134 927A      ST	-Y,R7
    00135 928A      ST	-Y,R8
    00136 929A      ST	-Y,R9
    00137 930A      ST	-Y,R16
    00138 931A      ST	-Y,R17
    00139 932A      ST	-Y,R18
    0013A 933A      ST	-Y,R19
    0013B 938A      ST	-Y,R24
    0013C 939A      ST	-Y,R25
    0013D 93AA      ST	-Y,R26
    0013E 93BA      ST	-Y,R27
    0013F 93EA      ST	-Y,R30
    00140 93FA      ST	-Y,R31
    00141 B60F      IN	R0,0x3F
    00142 920A      ST	-Y,R0
    00143 92AA      ST	-Y,R10
(0090) }
(0091) 
(0092) #pragma interrupt_handler uart0_rx:19
(0093) 
(0094) /*UART0的串口接收函数，每次接收一个字节（Byte）*/
(0095) void uart0_rx(void)
(0096) {
(0097)  	uchar uart0_r_byte;//UART0每次中断接收到的字符（1byte）
(0098) 	UCSR0B&=~BIT(RXCIE0);//关闭RXCIE1，其余位保持不变
    00144 9857      CBI	0x0A,7
(0099) 	uart0_r_byte=UDR0;
    00145 B0AC      IN	R10,0x0C
(0100) 	if(uart0_instr_make(uart0_r_byte)==0)//通过接受字符串，产生符合要求的instr
    00146 2D0A      MOV	R16,R10
    00147 2711      CLR	R17
    00148 D01C      RCALL	_uart0_instr_make
    00149 3000      CPI	R16,0
    0014A 0701      CPC	R16,R17
    0014B F409      BNE	0x014D
(0101) 	    {UCSR0B|=BIT(RXCIE0);}//使能RXCIE1，其余位保持不变
    0014C 9A57      SBI	0x0A,7
    0014D 90A9      LD	R10,Y+
    0014E 9009      LD	R0,Y+
    0014F BE0F      OUT	0x3F,R0
    00150 91F9      LD	R31,Y+
    00151 91E9      LD	R30,Y+
    00152 91B9      LD	R27,Y+
    00153 91A9      LD	R26,Y+
    00154 9199      LD	R25,Y+
    00155 9189      LD	R24,Y+
    00156 9139      LD	R19,Y+
    00157 9129      LD	R18,Y+
    00158 9119      LD	R17,Y+
    00159 9109      LD	R16,Y+
    0015A 9099      LD	R9,Y+
    0015B 9089      LD	R8,Y+
    0015C 9079      LD	R7,Y+
    0015D 9069      LD	R6,Y+
    0015E 9059      LD	R5,Y+
    0015F 9049      LD	R4,Y+
    00160 9039      LD	R3,Y+
    00161 9029      LD	R2,Y+
    00162 9019      LD	R1,Y+
    00163 9009      LD	R0,Y+
    00164 9518      RETI
_uart0_instr_make:
  instr_num            --> R10
  fun_ret              --> R20
  r_byte               --> R22
    00165 940E 0B49 CALL	push_xgsetF00C
    00167 2F60      MOV	R22,R16
(0102) }
(0103) 
(0104) //UART0的指令识别函数，从接收到的字符中提取出以xx开头的指令字符串
(0105) uchar uart0_instr_make(uchar r_byte)
(0106) {
(0107)     uchar instr_num;//instr中已有的字符数
(0108) 	uchar fun_ret;//存储本函数返回值 
(0109)     switch(uart0_r_instr_chk)//根据已有x的个数进行操作
    00168 90A0 0128 LDS	R10,uart0_r_instr_chk
    0016A 24BB      CLR	R11
    0016B 20AA      TST	R10
    0016C F411      BNE	0x016F
    0016D 20BB      TST	R11
    0016E F051      BEQ	0x0179
    0016F 01C5      MOVW	R24,R10
    00170 3081      CPI	R24,1
    00171 E0E0      LDI	R30,0
    00172 079E      CPC	R25,R30
    00173 F061      BEQ	0x0180
    00174 3082      CPI	R24,2
    00175 E0E0      LDI	R30,0
    00176 079E      CPC	R25,R30
    00177 F099      BEQ	0x018B
    00178 C02D      RJMP	0x01A6
(0110) 	{
(0111) 	    case 0:
(0112) 			 {
(0113) 			 if(r_byte=='x')
    00179 3768      CPI	R22,0x78
    0017A F419      BNE	0x017E
(0114) 			     {				 
(0115) 				 uart0_r_instr_chk=1;
    0017B E081      LDI	R24,1
    0017C 9380 0128 STS	uart0_r_instr_chk,R24
(0116) 				 }
(0117) 			 fun_ret=0;
    0017E 2744      CLR	R20
(0118) 			 break;
    0017F C026      RJMP	0x01A6
(0119) 			 }
(0120) 		case 1:
(0121) 			 {
(0122) 			 if(r_byte=='x')
    00180 3768      CPI	R22,0x78
    00181 F421      BNE	0x0186
(0123) 			     {uart0_r_instr_chk=2;}
    00182 E082      LDI	R24,2
    00183 9380 0128 STS	uart0_r_instr_chk,R24
    00185 C003      RJMP	0x0189
(0124) 			 else
(0125) 			 	 {uart0_r_instr_chk=0;}
    00186 2422      CLR	R2
    00187 9220 0128 STS	uart0_r_instr_chk,R2
(0126) 			 fun_ret=0;
    00189 2744      CLR	R20
(0127) 			 break;
    0018A C01B      RJMP	0x01A6
(0128) 			 }
(0129) 		case 2:
(0130) 			 {
(0131) 			 instr_num=strlen(uart0_instr);
    0018B EF0D      LDI	R16,0xFD
    0018C E011      LDI	R17,1
    0018D 940E 0AB2 CALL	_strlen
    0018F 2EA0      MOV	R10,R16
(0132) 			 if(instr_num==3)
    00190 3003      CPI	R16,3
    00191 F461      BNE	0x019E
(0133) 			 {
(0134) 			     uart0_instr[instr_num]=r_byte;
    00192 EF8D      LDI	R24,0xFD
    00193 E091      LDI	R25,1
    00194 2DEA      MOV	R30,R10
    00195 27FF      CLR	R31
    00196 0FE8      ADD	R30,R24
    00197 1FF9      ADC	R31,R25
    00198 8360      ST	Z,R22
(0135) 				 uart0_instr_flag=1;//instr已经满足开头xx和长度要求，flag置1，进行命令处理
    00199 E081      LDI	R24,1
    0019A 9380 0129 STS	uart0_instr_flag,R24
(0136) 			     fun_ret=1;				 
    0019C E041      LDI	R20,1
(0137) 			 }
    0019D C008      RJMP	0x01A6
(0138) 			 else
(0139) 			 {
(0140) 			     uart0_instr[instr_num]=r_byte;
    0019E EF8D      LDI	R24,0xFD
    0019F E091      LDI	R25,1
    001A0 2DEA      MOV	R30,R10
    001A1 27FF      CLR	R31
    001A2 0FE8      ADD	R30,R24
    001A3 1FF9      ADC	R31,R25
    001A4 8360      ST	Z,R22
(0141) 				 fun_ret=0;
    001A5 2744      CLR	R20
(0142) 			 }
(0143) 			 break;
(0144) 			 }
(0145) 		default:break;
(0146) 	}
(0147) 	return fun_ret;
    001A6 2F04      MOV	R16,R20
    001A7 940C 0B50 JMP	pop_xgsetF00C
_uart0_send_string:
  str_send_num         --> R14
  i                    --> R10
  str_send             --> R12
    001A9 940E 0B38 CALL	push_xgset00FC
    001AB 0168      MOVW	R12,R16
(0148) }
(0149) 
(0150) /*UART0字符串发送函数*/
(0151) void uart0_send_string(uchar *str_send)//形参：待发送字符串
(0152) {
(0153)  	 uchar str_send_num=strlen(str_send);//待发送字符串包含的字符数，
    001AC 0186      MOVW	R16,R12
    001AD 940E 0AB2 CALL	_strlen
    001AF 2EE0      MOV	R14,R16
(0154) 	 	   								//数组str_send最后一位值为NULL
(0155) 	 uchar i=0;
    001B0 24AA      CLR	R10
    001B1 C007      RJMP	0x01B9
(0156) 	 while(i<str_send_num)
(0157) 	 {
(0158) 	   uart0_sendB(*(str_send+i));
    001B2 2DEA      MOV	R30,R10
    001B3 27FF      CLR	R31
    001B4 0DEC      ADD	R30,R12
    001B5 1DFD      ADC	R31,R13
    001B6 8100      LD	R16,Z
    001B7 DF6E      RCALL	_uart0_sendB
(0159) 	   i+=1;
    001B8 94A3      INC	R10
    001B9 14AE      CP	R10,R14
    001BA F3B8      BCS	0x01B2
    001BB 940C 0B2D JMP	pop_xgset00FC
_uart0_send_string_with_num:
  i                    --> R10
  char_num             --> R12
  str_send             --> R14
    001BD 940E 0B38 CALL	push_xgset00FC
    001BF 2EC2      MOV	R12,R18
    001C0 0178      MOVW	R14,R16
(0160) 	 }
(0161) }
(0162) 
(0163) void uart0_send_string_with_num(uchar *str_send,uchar char_num)//形参：待发送字符串，字符串字符数
(0164) {
(0165) 	 uchar i=0;
    001C1 24AA      CLR	R10
    001C2 C007      RJMP	0x01CA
(0166) 	 while(i<char_num)
(0167) 	 {
(0168) 	   uart0_sendB(*(str_send+i));
    001C3 2DEA      MOV	R30,R10
    001C4 27FF      CLR	R31
    001C5 0DEE      ADD	R30,R14
    001C6 1DFF      ADC	R31,R15
    001C7 8100      LD	R16,Z
    001C8 DF5D      RCALL	_uart0_sendB
(0169) 	   i+=1;
    001C9 94A3      INC	R10
    001CA 14AC      CP	R10,R12
    001CB F3B8      BCS	0x01C3
    001CC 940C 0B2D JMP	pop_xgset00FC
_uart1_init:
  baud                 --> R10
    001CE 940E 0B49 CALL	push_xgsetF00C
    001D0 0158      MOVW	R10,R16
(0170) 	 }
(0171) }
(0172) 
(0173) //------------【UART1的相关函数】↓-------------------------------------------------------------
(0174) 
(0175) /*UART1的串口初始化函数*/
(0176) void uart1_init(uint baud)
(0177) {
(0178)     UCSR1B=0x00; 
    001D1 2422      CLR	R2
    001D2 9220 009A STS	0x9A,R2
(0179)     UCSR1A=0x00; 		   //控制寄存器清零
    001D4 9220 009B STS	0x9B,R2
(0180)     UCSR1C=(0<<UPM10)|(3<<UCSZ10); //选择UCSRC，异步模式，禁止校验，1位停止位，8位数据位                       
    001D6 E086      LDI	R24,6
    001D7 9380 009D STS	0x9D,R24
(0181)    
(0182)     baud=mclk/16/baud-1;    //波特率最大为65K
    001D9 0115      MOVW	R2,R10
    001DA 2444      CLR	R4
    001DB 2455      CLR	R5
    001DC E240      LDI	R20,0x20
    001DD EA51      LDI	R21,0xA1
    001DE E067      LDI	R22,7
    001DF E070      LDI	R23,0
    001E0 925A      ST	-Y,R5
    001E1 924A      ST	-Y,R4
    001E2 923A      ST	-Y,R3
    001E3 922A      ST	-Y,R2
    001E4 018A      MOVW	R16,R20
    001E5 019B      MOVW	R18,R22
    001E6 940E 0AC9 CALL	div32s
    001E8 E041      LDI	R20,1
    001E9 E050      LDI	R21,0
    001EA E060      LDI	R22,0
    001EB E070      LDI	R23,0
    001EC 0118      MOVW	R2,R16
    001ED 0129      MOVW	R4,R18
    001EE 1A24      SUB	R2,R20
    001EF 0A35      SBC	R3,R21
    001F0 0A46      SBC	R4,R22
    001F1 0A57      SBC	R5,R23
    001F2 0151      MOVW	R10,R2
(0183)     UBRR1L=baud; 					     	  
    001F3 92A0 0099 STS	0x99,R10
(0184)     UBRR1H=baud>>8; 		   //设置波特率
    001F5 2C23      MOV	R2,R3
    001F6 2433      CLR	R3
    001F7 9220 0098 STS	0x98,R2
(0185)    
(0186)     UCSR1B|=(1<<TXEN1)|(1<<RXEN1)|(1<<RXCIE1);   //接收、发送使能，接收中断使能
    001F9 9180 009A LDS	R24,0x9A
    001FB 6988      ORI	R24,0x98
    001FC 9380 009A STS	0x9A,R24
(0187)     SREG=BIT(7);	           //全局中断开放
    001FE E880      LDI	R24,0x80
    001FF BF8F      OUT	0x3F,R24
(0188)     DDRD|=BIT(3);	           //配置TX为输出（很重要），似乎对于MEGA1280来说没用
    00200 9A8B      SBI	0x11,3
(0189)    
(0190)    	//RS485芯片设置为发送，DE=PD5=1
(0191) 	//注意！该芯片为半双工通信，不可同时收和发，配置引脚时应注意这一点
(0192)     DDRD|=BIT(5);
    00201 9A8D      SBI	0x11,5
(0193)     PORTD|=BIT(5);
    00202 9A95      SBI	0x12,5
(0194) 
(0195) 	DDRD|=BIT(4);
    00203 9A8C      SBI	0x11,4
(0196)     PORTD|=BIT(4);
    00204 9A94      SBI	0x12,4
    00205 940C 0B50 JMP	pop_xgsetF00C
(0197) }
(0198) 
(0199) 
(0200) /*UART1的串口发送函数，每次发送一个字节（Byte）*/
(0201) void uart1_sendB(uchar data)
(0202) {
(0203)    while(!(UCSR1A&(BIT(UDRE1))));//判断准备就绪否
_uart1_sendB:
  data                 --> R16
    00207 9020 009B LDS	R2,0x9B
    00209 FE25      SBRS	R2,5
    0020A CFFC      RJMP	_uart1_sendB
(0204)    UDR1=data;
    0020B 9300 009C STS	0x9C,R16
(0205)    while(!(UCSR1A&(BIT(TXC1))));//判断完成发送否
    0020D 9020 009B LDS	R2,0x9B
    0020F FE26      SBRS	R2,6
    00210 CFFC      RJMP	0x020D
(0206)    UCSR1A|=BIT(TXC1);//TXC1标志位手动清零，通过将TXC1置1实现
    00211 9180 009B LDS	R24,0x9B
    00213 6480      ORI	R24,0x40
    00214 9380 009B STS	0x9B,R24
    00216 9508      RET
_uart1_send_string:
  i                    --> R10
  str_num              --> R12
  str_send             --> R14
    00217 940E 0B38 CALL	push_xgset00FC
    00219 2EC2      MOV	R12,R18
    0021A 0178      MOVW	R14,R16
(0207) }
(0208) 
(0209) /*UART1字符串发送函数*/
(0210) void uart1_send_string(uchar *str_send,uchar str_num)//形参：待发送字符串
(0211) {
(0212) 	 uchar i=0;
    0021B 24AA      CLR	R10
    0021C C007      RJMP	0x0224
(0213) 	 while(i<str_num)
(0214) 	 {
(0215) 	   uart1_sendB(*(str_send+i));
    0021D 2DEA      MOV	R30,R10
    0021E 27FF      CLR	R31
    0021F 0DEE      ADD	R30,R14
    00220 1DFF      ADC	R31,R15
    00221 8100      LD	R16,Z
    00222 DFE4      RCALL	_uart1_sendB
(0216) 	   i+=1;
    00223 94A3      INC	R10
    00224 14AC      CP	R10,R12
    00225 F3B8      BCS	0x021D
    00226 940C 0B2D JMP	pop_xgset00FC
_array_copy:
  i                    --> R10
  copy_num             --> R12
  array2               --> R14
  start_index          --> R18
  array1               --> R16
    00228 940E 0B38 CALL	push_xgset00FC
    0022A 80EE      LDD	R14,Y+6
    0022B 80FF      LDD	R15,Y+7
    0022C 84C8      LDD	R12,Y+8
(0217) 	   //delay(10);
(0218) 	 }
(0219) }
(0220) 
(0221) //#pragma interrupt_handler uart1_rx:31
(0222) 
(0223) /*
(0224) void uart1_rx(void)
(0225) {	
(0226)     UCSR1B&=~BIT(RXCIE1);
(0227) 	//rdata=UDR1;
(0228) 	//flag=1;
(0229) 	UCSR1B|=BIT(RXCIE1);
(0230) }
(0231) */
(0232) 
(0233) 
(0234) //------------------【字符串处理函数】↓-------------------------------------------------------
(0235) 
(0236) //数组元素拷贝函数
(0237) void array_copy(uchar *array1,uchar start_index,uchar *array2,uchar copy_num)
(0238) //将array1中自第start_index位起的copy_num个元素拷贝到array2的第0到copy_num-1位
(0239) //array1的元素数目不应小于start_index+copy_num+1个，array2的元素数目不应小于copy_num个
(0240) {
(0241)     uchar i;
(0242) 	for(i=0;i<copy_num;i++)
    0022D 24AA      CLR	R10
    0022E C00F      RJMP	0x023E
(0243) 	{
(0244) 	    array2[i]=array1[start_index+i];
    0022F 2C2A      MOV	R2,R10
    00230 2433      CLR	R3
    00231 2FE2      MOV	R30,R18
    00232 27FF      CLR	R31
    00233 0DE2      ADD	R30,R2
    00234 1DF3      ADC	R31,R3
    00235 0FE0      ADD	R30,R16
    00236 1FF1      ADC	R31,R17
    00237 8020      LD	R2,Z
    00238 2DEA      MOV	R30,R10
    00239 27FF      CLR	R31
    0023A 0DEE      ADD	R30,R14
    0023B 1DFF      ADC	R31,R15
    0023C 8220      ST	Z,R2
    0023D 94A3      INC	R10
    0023E 14AC      CP	R10,R12
    0023F F378      BCS	0x022F
    00240 940C 0B2D JMP	pop_xgset00FC
_array_cmp:
  i                    --> R20
  str1                 --> R18
  str0                 --> R16
    00242 934A      ST	-Y,R20
    00243 935A      ST	-Y,R21
(0245) 	}
(0246) }
(0247) 
(0248) //字符数组或字符串比较函数：若返回0，则表示相等，否则不等
(0249) //*str0或*str1可以使数组(例如array_eg[])，也可以是字符串常量(例如"abcd")
(0250) int array_cmp(char * str0, char * str1)
(0251) {
(0252)     int i;
(0253)     for(i=0;str0[i]!=0 && str1[i]!=0 && str0[i]==str1[i];i++);
    00244 2744      CLR	R20
    00245 2755      CLR	R21
    00246 C002      RJMP	0x0249
    00247 5F4F      SUBI	R20,0xFF
    00248 4F5F      SBCI	R21,0xFF
    00249 01FA      MOVW	R30,R20
    0024A 0FE0      ADD	R30,R16
    0024B 1FF1      ADC	R31,R17
    0024C 8020      LD	R2,Z
    0024D 2433      CLR	R3
    0024E 0121      MOVW	R4,R2
    0024F 2022      TST	R2
    00250 F069      BEQ	0x025E
    00251 01FA      MOVW	R30,R20
    00252 0FE2      ADD	R30,R18
    00253 1FF3      ADC	R31,R19
    00254 8020      LD	R2,Z
    00255 2433      CLR	R3
    00256 0131      MOVW	R6,R2
    00257 2022      TST	R2
    00258 F029      BEQ	0x025E
    00259 2C24      MOV	R2,R4
    0025A 2433      CLR	R3
    0025B 1426      CP	R2,R6
    0025C 0437      CPC	R3,R7
    0025D F349      BEQ	0x0247
(0254)     return str0[i]-str1[i];
    0025E 01FA      MOVW	R30,R20
    0025F 0FE2      ADD	R30,R18
    00260 1FF3      ADC	R31,R19
    00261 8020      LD	R2,Z
    00262 2433      CLR	R3
    00263 01FA      MOVW	R30,R20
    00264 0FE0      ADD	R30,R16
    00265 1FF1      ADC	R31,R17
    00266 8100      LD	R16,Z
    00267 2711      CLR	R17
    00268 1902      SUB	R16,R2
    00269 0913      SBC	R17,R3
    0026A 9159      LD	R21,Y+
    0026B 9149      LD	R20,Y+
    0026C 9508      RET
(0255) }
(0256) 
(0257) uchar* Type(uchar* Instruction)
(0258) {
(0259)     static uchar type_name[3];//static关键词很重要！否则子程序调用完成后，数组内容消失
(0260) 	type_name[0]=Instruction[0];
_Type:
  Instruction          --> R16
    0026D 01F8      MOVW	R30,R16
    0026E 8020      LD	R2,Z
    0026F 9220 01F4 STS	Gripper_AVR_program.c:type_name,R2
(0261) 	type_name[1]=Instruction[1];
    00271 8021      LDD	R2,Z+1
    00272 9220 01F5 STS	Gripper_AVR_program.c:type_name+1,R2
(0262) 	type_name[2]=0;
    00274 2422      CLR	R2
    00275 9220 01F6 STS	Gripper_AVR_program.c:type_name+2,R2
(0263) 	return type_name;
    00277 EF04      LDI	R16,0xF4
    00278 E011      LDI	R17,1
    00279 9508      RET
(0264) }
(0265) 
(0266) //----------------【应变片相关函数】↓--------------------------------
(0267) 
(0268) //应变片读取配置
(0269) void force_data_init(void)
(0270) {
(0271) 	/*A0-DT ADDO：单片机从DT读取数据;A1-SCK ADSK：单片机输出高低电平到SCK*/
(0272) 	//PA0配置成高阻态输入
(0273) 	DDRA&=(~BIT(0));//DDRA0=0
_force_data_init:
    0027A 98D0      CBI	0x1A,0
(0274) 	PORTA&=(~BIT(0));//PORTA0=0
    0027B 98D8      CBI	0x1B,0
(0275) 
(0276) 	//PA1配置成输出
(0277) 	DDRA|=BIT(1);//DDRA1=1
    0027C 9AD1      SBI	0x1A,1
    0027D 9508      RET
_ulong_to_uchar_array:
  pNum                 --> R22
  force_data           --> Y,+0
  data_num             --> Y,+9
    0027E 940E 0ABE CALL	push_arg4
    00280 940E 0B3F CALL	push_xgsetF000
    00282 9725      SBIW	R28,5
(0278) }
(0279) 
(0280) //unsigned long型数字转成字符串，用于将应变片采集回的数据上传
(0281) uchar* ulong_to_uchar_array(unsigned long data_num)
(0282) {
(0283)  	//long型在内存中的存储 0x12345678 →低地址78+56+34+12高地址
(0284) 	uchar* pNum;
(0285) 	uchar force_data[5];
(0286) 	pNum=(uchar *)&data_num;
    00283 01BE      MOVW	R22,R28
    00284 5F67      SUBI	R22,0xF7
    00285 4F7F      SBCI	R23,0xFF
(0287) 	force_data[3]=*pNum;
    00286 01FB      MOVW	R30,R22
    00287 8020      LD	R2,Z
    00288 822B      STD	Y+3,R2
(0288) 	force_data[2]=*(++pNum);
    00289 01CF      MOVW	R24,R30
    0028A 9601      ADIW	R24,1
    0028B 01FC      MOVW	R30,R24
    0028C 8020      LD	R2,Z
    0028D 822A      STD	Y+2,R2
(0289) 	force_data[1]=*(++pNum);
    0028E 9601      ADIW	R24,1
    0028F 01FC      MOVW	R30,R24
    00290 8020      LD	R2,Z
    00291 8229      STD	Y+1,R2
(0290) 	force_data[0]=*(++pNum);
    00292 01AC      MOVW	R20,R24
    00293 5F4F      SUBI	R20,0xFF
    00294 4F5F      SBCI	R21,0xFF
    00295 01BA      MOVW	R22,R20
    00296 01FA      MOVW	R30,R20
    00297 8020      LD	R2,Z
    00298 8228      ST	Y,R2
(0291) 	force_data[4]=0;
    00299 2422      CLR	R2
    0029A 822C      STD	Y+4,R2
(0292) 	force_high8=0x7f-force_data[1];//有效值高八位存入全局变量中
    0029B 8029      LDD	R2,Y+1
    0029C E78F      LDI	R24,0x7F
    0029D 1982      SUB	R24,R2
    0029E 9380 01FC STS	force_high8,R24
(0293) 	//注意根据应变片情况调整force_high8的值，即是否用0x7f减去有效值高八位
(0294) 	
(0295) 	return force_data;
    002A0 018E      MOVW	R16,R28
    002A1 9625      ADIW	R28,5
    002A2 940E 0B44 CALL	pop_xgsetF000
    002A4 9624      ADIW	R28,4
    002A5 9508      RET
_ReadCount:
  ptr_count            --> Y,+1
  i                    --> R16
  Count                --> Y,+0
    002A6 9724      SBIW	R28,4
(0296) }
(0297) 
(0298) //应变采集模块数据读取程序，参照卖方示例编写
(0299) unsigned long ReadCount(void)
(0300) {
(0301)     unsigned long Count;
(0302)     unsigned char i;
(0303) 	uchar* ptr_count;
(0304) 	PORTA&=(~BIT(1));//ADSK=PORTA1=0
    002A7 98D9      CBI	0x1B,1
(0305)     Count=0;
    002A8 E080      LDI	R24,0
    002A9 8388      ST	Y,R24
    002AA 8389      STD	Y+1,R24
    002AB 838A      STD	Y+2,R24
    002AC 838B      STD	Y+3,R24
(0306)     while(PINA&BIT(0));//读取PINA0=ADDO
    002AD 99C8      SBIC	0x19,0
    002AE CFFE      RJMP	0x02AD
(0307)     for(i=0;i<24;i++)
    002AF 2700      CLR	R16
    002B0 C021      RJMP	0x02D2
(0308)     {
(0309)         PORTA|=BIT(1);//ADSK=PORTA1=1
    002B1 9AD9      SBI	0x1B,1
(0310)         Count=Count<<1;
    002B2 8028      LD	R2,Y
    002B3 8039      LDD	R3,Y+1
    002B4 804A      LDD	R4,Y+2
    002B5 805B      LDD	R5,Y+3
    002B6 0C22      LSL	R2
    002B7 1C33      ROL	R3
    002B8 1C44      ROL	R4
    002B9 1C55      ROL	R5
    002BA 8228      ST	Y,R2
    002BB 8239      STD	Y+1,R3
    002BC 824A      STD	Y+2,R4
    002BD 825B      STD	Y+3,R5
(0311)         PORTA&=(~BIT(1));//ADSK=PORTA1=0
    002BE 98D9      CBI	0x1B,1
(0312)         if(PINA&BIT(0)) Count++;
    002BF 9BC8      SBIS	0x19,0
    002C0 C010      RJMP	0x02D1
    002C1 E081      LDI	R24,1
    002C2 E090      LDI	R25,0
    002C3 E0A0      LDI	R26,0
    002C4 E0B0      LDI	R27,0
    002C5 8028      LD	R2,Y
    002C6 8039      LDD	R3,Y+1
    002C7 804A      LDD	R4,Y+2
    002C8 805B      LDD	R5,Y+3
    002C9 0E28      ADD	R2,R24
    002CA 1E39      ADC	R3,R25
    002CB 1E4A      ADC	R4,R26
    002CC 1E5B      ADC	R5,R27
    002CD 8228      ST	Y,R2
    002CE 8239      STD	Y+1,R3
    002CF 824A      STD	Y+2,R4
    002D0 825B      STD	Y+3,R5
    002D1 9503      INC	R16
    002D2 3108      CPI	R16,0x18
    002D3 F2E8      BCS	0x02B1
(0313)     }
(0314)     PORTA|=BIT(1);//ADSK=PORTA1=1
    002D4 9AD9      SBI	0x1B,1
(0315)     Count=Count^0x800000;
    002D5 E080      LDI	R24,0
    002D6 E090      LDI	R25,0
    002D7 E8A0      LDI	R26,0x80
    002D8 E0B0      LDI	R27,0
    002D9 8028      LD	R2,Y
    002DA 8039      LDD	R3,Y+1
    002DB 804A      LDD	R4,Y+2
    002DC 805B      LDD	R5,Y+3
    002DD 2628      EOR	R2,R24
    002DE 2639      EOR	R3,R25
    002DF 264A      EOR	R4,R26
    002E0 265B      EOR	R5,R27
    002E1 8228      ST	Y,R2
    002E2 8239      STD	Y+1,R3
    002E3 824A      STD	Y+2,R4
    002E4 825B      STD	Y+3,R5
(0316)     PORTA&=(~BIT(1));//ADSK=PORTA1=0
    002E5 98D9      CBI	0x1B,1
(0317)     return(Count);
    002E6 8108      LD	R16,Y
    002E7 8119      LDD	R17,Y+1
    002E8 812A      LDD	R18,Y+2
    002E9 813B      LDD	R19,Y+3
    002EA 9624      ADIW	R28,4
    002EB 9508      RET
(0318) }
(0319) 
(0320) //保存应变片数据有效值的高八位
(0321) void command_data_save_force_high8(force_save)
(0322) {
(0323)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_force_high8:
  force_save           --> R16
    002EC 94B8      BCLR	3
(0324) 	
(0325) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    002ED 99E1      SBIC	0x1C,1
    002EE CFFE      RJMP	0x02ED
(0326) 	EEAR=0x0030;//写地址
    002EF E380      LDI	R24,0x30
    002F0 E090      LDI	R25,0
    002F1 BB9F      OUT	0x1F,R25
    002F2 BB8E      OUT	0x1E,R24
(0327) 	EEDR=force_save;//写数据
    002F3 BB0D      OUT	0x1D,R16
(0328) 	EECR|=BIT(EEMWE);//EEMWE置1
    002F4 9AE2      SBI	0x1C,2
(0329) 	EECR&=(~BIT(EEWE));//EEWE置0
    002F5 98E1      CBI	0x1C,1
(0330) 	EECR|=BIT(EEWE);//EEWE置1
    002F6 9AE1      SBI	0x1C,1
(0331) 	
(0332) 	SREG |= BIT(3);//打开全局中断
    002F7 9438      BSET	3
    002F8 9508      RET
(0333) }
(0334) 
(0335) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动第一阶段
(0336) void command_data_read_force_high8(uchar* PARA)
(0337) {
(0338)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_force_high8:
  PARA                 --> R16
    002F9 94B8      BCLR	3
(0339) 	
(0340) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    002FA 99E1      SBIC	0x1C,1
    002FB CFFE      RJMP	0x02FA
(0341) 	EEAR=0x0030;//写地址
    002FC E380      LDI	R24,0x30
    002FD E090      LDI	R25,0
    002FE BB9F      OUT	0x1F,R25
    002FF BB8E      OUT	0x1E,R24
(0342) 	EECR|=BIT(EERE);//读允许位置1
    00300 9AE0      SBI	0x1C,0
(0343) 	*PARA=EEDR;//读出EEDR中的数据
    00301 B22D      IN	R2,0x1D
    00302 01F8      MOVW	R30,R16
    00303 8220      ST	Z,R2
(0344) 
(0345) 	SREG |= BIT(3);//打开全局中断
    00304 9438      BSET	3
    00305 9508      RET
(0346) }
(0347) 
(0348) //定时计数器初始化函数
(0349) void timer1_init(void)
(0350) {
(0351)     TCCR1B=0X04;//256内部分频
_timer1_init:
    00306 E084      LDI	R24,4
    00307 BD8E      OUT	0x2E,R24
(0352) 	TCNT1=0xC2F6;//定时周期500ms，计算方法见开发文档
    00308 EF86      LDI	R24,0xF6
    00309 EC92      LDI	R25,0xC2
    0030A BD9D      OUT	0x2D,R25
    0030B BD8C      OUT	0x2C,R24
(0353) 	TIFR=0x04;//定时计数器1溢出标志位清除，置1清除，上电默认为0
    0030C E084      LDI	R24,4
    0030D BF86      OUT	0x36,R24
    0030E 9508      RET
_timer1_interrupt_handler:
  msg_force_array      --> Y,+0
    0030F 920A      ST	-Y,R0
    00310 921A      ST	-Y,R1
    00311 922A      ST	-Y,R2
    00312 923A      ST	-Y,R3
    00313 924A      ST	-Y,R4
    00314 925A      ST	-Y,R5
    00315 926A      ST	-Y,R6
    00316 927A      ST	-Y,R7
    00317 928A      ST	-Y,R8
    00318 929A      ST	-Y,R9
    00319 930A      ST	-Y,R16
    0031A 931A      ST	-Y,R17
    0031B 932A      ST	-Y,R18
    0031C 933A      ST	-Y,R19
    0031D 938A      ST	-Y,R24
    0031E 939A      ST	-Y,R25
    0031F 93AA      ST	-Y,R26
    00320 93BA      ST	-Y,R27
    00321 93EA      ST	-Y,R30
    00322 93FA      ST	-Y,R31
    00323 B60F      IN	R0,0x3F
    00324 920A      ST	-Y,R0
    00325 9726      SBIW	R28,6
(0354) }
(0355) 
(0356) //声明中断函数
(0357) #pragma interrupt_handler timer1_interrupt_handler:15
(0358) 
(0359) //定时计数器1中断处理函数
(0360) void timer1_interrupt_handler(void)
(0361) {
(0362)     uchar msg_force_array[]="zz21w";
    00326 E28D      LDI	R24,0x2D
    00327 E091      LDI	R25,1
    00328 01FE      MOVW	R30,R28
    00329 E006      LDI	R16,6
    0032A E010      LDI	R17,0
    0032B 93FA      ST	-Y,R31
    0032C 93EA      ST	-Y,R30
    0032D 939A      ST	-Y,R25
    0032E 938A      ST	-Y,R24
    0032F 940E 0B60 CALL	asgnblk
(0363) 	force_ulong=ReadCount();//读取数据放入全局变量
    00331 DF74      RCALL	_ReadCount
    00332 9310 01F8 STS	force_ulong+1,R17
    00334 9300 01F7 STS	force_ulong,R16
    00336 9330 01FA STS	force_ulong+3,R19
    00338 9320 01F9 STS	force_ulong+2,R18
(0364) 	ulong_to_uchar_array(force_ulong);//数据类型转换
    0033A DF43      RCALL	_ulong_to_uchar_array
(0365) 	msg_force_array[4]=force_high8;
    0033B 9020 01FC LDS	R2,force_high8
    0033D 822C      STD	Y+4,R2
(0366) 	uart0_send_string(msg_force_array);//向上位机发送夹紧力实时数值（仅有效值高八位）
    0033E 018E      MOVW	R16,R28
    0033F DE69      RCALL	_uart0_send_string
(0367) 	TCNT1=0xC2F6;//需要重新设定周期500ms
    00340 EF86      LDI	R24,0xF6
    00341 EC92      LDI	R25,0xC2
    00342 BD9D      OUT	0x2D,R25
    00343 BD8C      OUT	0x2C,R24
    00344 9626      ADIW	R28,6
    00345 9009      LD	R0,Y+
    00346 BE0F      OUT	0x3F,R0
    00347 91F9      LD	R31,Y+
    00348 91E9      LD	R30,Y+
    00349 91B9      LD	R27,Y+
    0034A 91A9      LD	R26,Y+
    0034B 9199      LD	R25,Y+
    0034C 9189      LD	R24,Y+
    0034D 9139      LD	R19,Y+
    0034E 9129      LD	R18,Y+
    0034F 9119      LD	R17,Y+
    00350 9109      LD	R16,Y+
    00351 9099      LD	R9,Y+
    00352 9089      LD	R8,Y+
    00353 9079      LD	R7,Y+
    00354 9069      LD	R6,Y+
    00355 9059      LD	R5,Y+
    00356 9049      LD	R4,Y+
    00357 9039      LD	R3,Y+
    00358 9029      LD	R2,Y+
    00359 9019      LD	R1,Y+
    0035A 9009      LD	R0,Y+
    0035B 9518      RETI
_ratio_command_check:
  check_sum            --> R10
  PARA3                --> R10
  PARA2                --> R18
  ID                   --> R16
    0035C 92AA      ST	-Y,R10
    0035D 80A9      LDD	R10,Y+1
(0368) }
(0369) 
(0370) //----------------【舵机控制相关函数】↓---------------------------------------------
(0371) 
(0372) //指令校验码生成函数，公式由舵机使用说明书指定
(0373) uchar ratio_command_check(uchar ID,uchar PARA2,uchar PARA3)
(0374) {
(0375)     uchar check_sum;
(0376) 	check_sum=0x05+0x03+0x20+ID+PARA2+PARA3;
    0035E 2F80      MOV	R24,R16
    0035F 5D88      SUBI	R24,0xD8
    00360 0F82      ADD	R24,R18
    00361 0D8A      ADD	R24,R10
    00362 2EA8      MOV	R10,R24
(0377) 	return ~check_sum;
    00363 2F08      MOV	R16,R24
    00364 9500      COM	R16
    00365 90A9      LD	R10,Y+
    00366 9508      RET
(0378) }
(0379) 
(0380) //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指移动0第一阶段
(0381) void command_data_save_finger_0_ratio_1(uchar PARA2,uchar PARA3)
(0382) {
(0383)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_finger_0_ratio_1:
  PARA3                --> R18
  PARA2                --> R16
    00367 94B8      BCLR	3
(0384) 	
(0385) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00368 99E1      SBIC	0x1C,1
    00369 CFFE      RJMP	0x0368
(0386) 	EEAR=0x0000;//写地址
    0036A 2422      CLR	R2
    0036B 2433      CLR	R3
    0036C BA3F      OUT	0x1F,R3
    0036D BA2E      OUT	0x1E,R2
(0387) 	EEDR=PARA2;//写数据
    0036E BB0D      OUT	0x1D,R16
(0388) 	EECR|=BIT(EEMWE);//EEMWE置1
    0036F 9AE2      SBI	0x1C,2
(0389) 	EECR&=(~BIT(EEWE));//EEWE置0
    00370 98E1      CBI	0x1C,1
(0390) 	EECR|=BIT(EEWE);//EEWE置1
    00371 9AE1      SBI	0x1C,1
(0391) 	
(0392) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00372 99E1      SBIC	0x1C,1
    00373 CFFE      RJMP	0x0372
(0393) 	EEAR=0x0001;//写地址
    00374 E081      LDI	R24,1
    00375 E090      LDI	R25,0
    00376 BB9F      OUT	0x1F,R25
    00377 BB8E      OUT	0x1E,R24
(0394) 	EEDR=PARA3;//写数据
    00378 BB2D      OUT	0x1D,R18
(0395) 	EECR|=BIT(EEMWE);//EEMWE置1
    00379 9AE2      SBI	0x1C,2
(0396) 	EECR&=(~BIT(EEWE));//EEWE置0
    0037A 98E1      CBI	0x1C,1
(0397) 	EECR|=BIT(EEWE);//EEWE置1
    0037B 9AE1      SBI	0x1C,1
(0398) 	
(0399) 	SREG |= BIT(3);//打开全局中断
    0037C 9438      BSET	3
    0037D 9508      RET
(0400) }
(0401) 
(0402) //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指0移动第二阶段
(0403) void command_data_save_finger_0_ratio_2(uchar PARA2,uchar PARA3)
(0404) {
(0405)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_finger_0_ratio_2:
  PARA3                --> R18
  PARA2                --> R16
    0037E 94B8      BCLR	3
(0406) 	
(0407) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    0037F 99E1      SBIC	0x1C,1
    00380 CFFE      RJMP	0x037F
(0408) 	EEAR=0x0002;//写地址
    00381 E082      LDI	R24,2
    00382 E090      LDI	R25,0
    00383 BB9F      OUT	0x1F,R25
    00384 BB8E      OUT	0x1E,R24
(0409) 	EEDR=PARA2;//写数据
    00385 BB0D      OUT	0x1D,R16
(0410) 	EECR|=BIT(EEMWE);//EEMWE置1
    00386 9AE2      SBI	0x1C,2
(0411) 	EECR&=(~BIT(EEWE));//EEWE置0
    00387 98E1      CBI	0x1C,1
(0412) 	EECR|=BIT(EEWE);//EEWE置1
    00388 9AE1      SBI	0x1C,1
(0413) 	
(0414) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00389 99E1      SBIC	0x1C,1
    0038A CFFE      RJMP	0x0389
(0415) 	EEAR=0x0003;//写地址
    0038B E083      LDI	R24,3
    0038C E090      LDI	R25,0
    0038D BB9F      OUT	0x1F,R25
    0038E BB8E      OUT	0x1E,R24
(0416) 	EEDR=PARA3;//写数据
    0038F BB2D      OUT	0x1D,R18
(0417) 	EECR|=BIT(EEMWE);//EEMWE置1
    00390 9AE2      SBI	0x1C,2
(0418) 	EECR&=(~BIT(EEWE));//EEWE置0
    00391 98E1      CBI	0x1C,1
(0419) 	EECR|=BIT(EEWE);//EEWE置1
    00392 9AE1      SBI	0x1C,1
(0420) 	
(0421) 	SREG |= BIT(3);//打开全局中断
    00393 9438      BSET	3
    00394 9508      RET
(0422) }
(0423) 
(0424) //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指0移动松开阶段
(0425) void command_data_save_finger_0_ratio_3(uchar PARA2,uchar PARA3)
(0426) {
(0427)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_finger_0_ratio_3:
  PARA3                --> R18
  PARA2                --> R16
    00395 94B8      BCLR	3
(0428) 	
(0429) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00396 99E1      SBIC	0x1C,1
    00397 CFFE      RJMP	0x0396
(0430) 	EEAR=0x0004;//写地址
    00398 E084      LDI	R24,4
    00399 E090      LDI	R25,0
    0039A BB9F      OUT	0x1F,R25
    0039B BB8E      OUT	0x1E,R24
(0431) 	EEDR=PARA2;//写数据
    0039C BB0D      OUT	0x1D,R16
(0432) 	EECR|=BIT(EEMWE);//EEMWE置1
    0039D 9AE2      SBI	0x1C,2
(0433) 	EECR&=(~BIT(EEWE));//EEWE置0
    0039E 98E1      CBI	0x1C,1
(0434) 	EECR|=BIT(EEWE);//EEWE置1
    0039F 9AE1      SBI	0x1C,1
(0435) 	
(0436) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    003A0 99E1      SBIC	0x1C,1
    003A1 CFFE      RJMP	0x03A0
(0437) 	EEAR=0x0005;//写地址
    003A2 E085      LDI	R24,5
    003A3 E090      LDI	R25,0
    003A4 BB9F      OUT	0x1F,R25
    003A5 BB8E      OUT	0x1E,R24
(0438) 	EEDR=PARA3;//写数据
    003A6 BB2D      OUT	0x1D,R18
(0439) 	EECR|=BIT(EEMWE);//EEMWE置1
    003A7 9AE2      SBI	0x1C,2
(0440) 	EECR&=(~BIT(EEWE));//EEWE置0
    003A8 98E1      CBI	0x1C,1
(0441) 	EECR|=BIT(EEWE);//EEWE置1
    003A9 9AE1      SBI	0x1C,1
(0442) 	
(0443) 	SREG |= BIT(3);//打开全局中断
    003AA 9438      BSET	3
    003AB 9508      RET
(0444) }
(0445) 
(0446) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指0移动第一阶段
(0447) void command_data_read_finger_0_ratio_1(uchar* PARA2,uchar* PARA3)
(0448) {
(0449)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_finger_0_ratio_1:
  PARA3                --> R18
  PARA2                --> R16
    003AC 94B8      BCLR	3
(0450) 	
(0451) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    003AD 99E1      SBIC	0x1C,1
    003AE CFFE      RJMP	0x03AD
(0452) 	EEAR=0x0000;//写地址
    003AF 2422      CLR	R2
    003B0 2433      CLR	R3
    003B1 BA3F      OUT	0x1F,R3
    003B2 BA2E      OUT	0x1E,R2
(0453) 	EECR|=BIT(EERE);//读允许位置1
    003B3 9AE0      SBI	0x1C,0
(0454) 	*PARA2=EEDR;//读出EEDR中的数据
    003B4 B22D      IN	R2,0x1D
    003B5 01F8      MOVW	R30,R16
    003B6 8220      ST	Z,R2
(0455) 
(0456) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    003B7 99E1      SBIC	0x1C,1
    003B8 CFFE      RJMP	0x03B7
(0457) 	EEAR=0x0001;//写地址
    003B9 E081      LDI	R24,1
    003BA E090      LDI	R25,0
    003BB BB9F      OUT	0x1F,R25
    003BC BB8E      OUT	0x1E,R24
(0458) 	EECR|=BIT(EERE);//读允许位置1
    003BD 9AE0      SBI	0x1C,0
(0459) 	*PARA3=EEDR;//读出EEDR中的数据
    003BE B22D      IN	R2,0x1D
    003BF 01F9      MOVW	R30,R18
    003C0 8220      ST	Z,R2
(0460) 	
(0461) 	SREG |= BIT(3);//打开全局中断
    003C1 9438      BSET	3
    003C2 9508      RET
(0462) }
(0463) 
(0464) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指0移动第二阶段
(0465) void command_data_read_finger_0_ratio_2(uchar* PARA2,uchar* PARA3)
(0466) {
(0467)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_finger_0_ratio_2:
  PARA3                --> R18
  PARA2                --> R16
    003C3 94B8      BCLR	3
(0468) 	
(0469) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    003C4 99E1      SBIC	0x1C,1
    003C5 CFFE      RJMP	0x03C4
(0470) 	EEAR=0x0002;//写地址
    003C6 E082      LDI	R24,2
    003C7 E090      LDI	R25,0
    003C8 BB9F      OUT	0x1F,R25
    003C9 BB8E      OUT	0x1E,R24
(0471) 	EECR|=BIT(EERE);//读允许位置1
    003CA 9AE0      SBI	0x1C,0
(0472) 	*PARA2=EEDR;//读出EEDR中的数据
    003CB B22D      IN	R2,0x1D
    003CC 01F8      MOVW	R30,R16
    003CD 8220      ST	Z,R2
(0473) 
(0474) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    003CE 99E1      SBIC	0x1C,1
    003CF CFFE      RJMP	0x03CE
(0475) 	EEAR=0x0003;//写地址
    003D0 E083      LDI	R24,3
    003D1 E090      LDI	R25,0
    003D2 BB9F      OUT	0x1F,R25
    003D3 BB8E      OUT	0x1E,R24
(0476) 	EECR|=BIT(EERE);//读允许位置1
    003D4 9AE0      SBI	0x1C,0
(0477) 	*PARA3=EEDR;//读出EEDR中的数据
    003D5 B22D      IN	R2,0x1D
    003D6 01F9      MOVW	R30,R18
    003D7 8220      ST	Z,R2
(0478) 	
(0479) 	SREG |= BIT(3);//打开全局中断
    003D8 9438      BSET	3
    003D9 9508      RET
(0480) }
(0481) 
(0482) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指0移动移动阶段
(0483) void command_data_read_finger_0_ratio_3(uchar* PARA2,uchar* PARA3)
(0484) {
(0485)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_finger_0_ratio_3:
  PARA3                --> R18
  PARA2                --> R16
    003DA 94B8      BCLR	3
(0486) 	
(0487) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    003DB 99E1      SBIC	0x1C,1
    003DC CFFE      RJMP	0x03DB
(0488) 	EEAR=0x0004;//写地址
    003DD E084      LDI	R24,4
    003DE E090      LDI	R25,0
    003DF BB9F      OUT	0x1F,R25
    003E0 BB8E      OUT	0x1E,R24
(0489) 	EECR|=BIT(EERE);//读允许位置1
    003E1 9AE0      SBI	0x1C,0
(0490) 	*PARA2=EEDR;//读出EEDR中的数据
    003E2 B22D      IN	R2,0x1D
    003E3 01F8      MOVW	R30,R16
    003E4 8220      ST	Z,R2
(0491) 
(0492) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    003E5 99E1      SBIC	0x1C,1
    003E6 CFFE      RJMP	0x03E5
(0493) 	EEAR=0x0005;//写地址
    003E7 E085      LDI	R24,5
    003E8 E090      LDI	R25,0
    003E9 BB9F      OUT	0x1F,R25
    003EA BB8E      OUT	0x1E,R24
(0494) 	EECR|=BIT(EERE);//读允许位置1
    003EB 9AE0      SBI	0x1C,0
(0495) 	*PARA3=EEDR;//读出EEDR中的数据
    003EC B22D      IN	R2,0x1D
    003ED 01F9      MOVW	R30,R18
    003EE 8220      ST	Z,R2
(0496) 	
(0497) 	SREG |= BIT(3);//打开全局中断
    003EF 9438      BSET	3
    003F0 9508      RET
(0498) }
(0499) 
(0500) //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指1移动第一阶段
(0501) void command_data_save_finger_1_ratio_1(uchar PARA2,uchar PARA3)
(0502) {
(0503)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_finger_1_ratio_1:
  PARA3                --> R18
  PARA2                --> R16
    003F1 94B8      BCLR	3
(0504) 	
(0505) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    003F2 99E1      SBIC	0x1C,1
    003F3 CFFE      RJMP	0x03F2
(0506) 	EEAR=0x0010;//写地址
    003F4 E180      LDI	R24,0x10
    003F5 E090      LDI	R25,0
    003F6 BB9F      OUT	0x1F,R25
    003F7 BB8E      OUT	0x1E,R24
(0507) 	EEDR=PARA2;//写数据
    003F8 BB0D      OUT	0x1D,R16
(0508) 	EECR|=BIT(EEMWE);//EEMWE置1
    003F9 9AE2      SBI	0x1C,2
(0509) 	EECR&=(~BIT(EEWE));//EEWE置0
    003FA 98E1      CBI	0x1C,1
(0510) 	EECR|=BIT(EEWE);//EEWE置1
    003FB 9AE1      SBI	0x1C,1
(0511) 	
(0512) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    003FC 99E1      SBIC	0x1C,1
    003FD CFFE      RJMP	0x03FC
(0513) 	EEAR=0x0011;//写地址
    003FE E181      LDI	R24,0x11
    003FF E090      LDI	R25,0
    00400 BB9F      OUT	0x1F,R25
    00401 BB8E      OUT	0x1E,R24
(0514) 	EEDR=PARA3;//写数据
    00402 BB2D      OUT	0x1D,R18
(0515) 	EECR|=BIT(EEMWE);//EEMWE置1
    00403 9AE2      SBI	0x1C,2
(0516) 	EECR&=(~BIT(EEWE));//EEWE置0
    00404 98E1      CBI	0x1C,1
(0517) 	EECR|=BIT(EEWE);//EEWE置1
    00405 9AE1      SBI	0x1C,1
(0518) 	
(0519) 	SREG |= BIT(3);//打开全局中断
    00406 9438      BSET	3
    00407 9508      RET
(0520) }
(0521) 
(0522) //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指1移动第二阶段
(0523) void command_data_save_finger_1_ratio_2(uchar PARA2,uchar PARA3)
(0524) {
(0525)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_finger_1_ratio_2:
  PARA3                --> R18
  PARA2                --> R16
    00408 94B8      BCLR	3
(0526) 	
(0527) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00409 99E1      SBIC	0x1C,1
    0040A CFFE      RJMP	0x0409
(0528) 	EEAR=0x0012;//写地址
    0040B E182      LDI	R24,0x12
    0040C E090      LDI	R25,0
    0040D BB9F      OUT	0x1F,R25
    0040E BB8E      OUT	0x1E,R24
(0529) 	EEDR=PARA2;//写数据
    0040F BB0D      OUT	0x1D,R16
(0530) 	EECR|=BIT(EEMWE);//EEMWE置1
    00410 9AE2      SBI	0x1C,2
(0531) 	EECR&=(~BIT(EEWE));//EEWE置0
    00411 98E1      CBI	0x1C,1
(0532) 	EECR|=BIT(EEWE);//EEWE置1
    00412 9AE1      SBI	0x1C,1
(0533) 	
(0534) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00413 99E1      SBIC	0x1C,1
    00414 CFFE      RJMP	0x0413
(0535) 	EEAR=0x0013;//写地址
    00415 E183      LDI	R24,0x13
    00416 E090      LDI	R25,0
    00417 BB9F      OUT	0x1F,R25
    00418 BB8E      OUT	0x1E,R24
(0536) 	EEDR=PARA3;//写数据
    00419 BB2D      OUT	0x1D,R18
(0537) 	EECR|=BIT(EEMWE);//EEMWE置1
    0041A 9AE2      SBI	0x1C,2
(0538) 	EECR&=(~BIT(EEWE));//EEWE置0
    0041B 98E1      CBI	0x1C,1
(0539) 	EECR|=BIT(EEWE);//EEWE置1
    0041C 9AE1      SBI	0x1C,1
(0540) 	
(0541) 	SREG |= BIT(3);//打开全局中断
    0041D 9438      BSET	3
    0041E 9508      RET
(0542) }
(0543) 
(0544) //舵机控制指令数据存储函数，舵机ENDLESS TURN模式下PARA2和PARA3存放到EEPROM中，手指1移动松开阶段
(0545) void command_data_save_finger_1_ratio_3(uchar PARA2,uchar PARA3)
(0546) {
(0547)     SREG &=(~BIT(3));//关闭全局中断
_command_data_save_finger_1_ratio_3:
  PARA3                --> R18
  PARA2                --> R16
    0041F 94B8      BCLR	3
(0548) 	
(0549) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    00420 99E1      SBIC	0x1C,1
    00421 CFFE      RJMP	0x0420
(0550) 	EEAR=0x0014;//写地址
    00422 E184      LDI	R24,0x14
    00423 E090      LDI	R25,0
    00424 BB9F      OUT	0x1F,R25
    00425 BB8E      OUT	0x1E,R24
(0551) 	EEDR=PARA2;//写数据
    00426 BB0D      OUT	0x1D,R16
(0552) 	EECR|=BIT(EEMWE);//EEMWE置1
    00427 9AE2      SBI	0x1C,2
(0553) 	EECR&=(~BIT(EEWE));//EEWE置0
    00428 98E1      CBI	0x1C,1
(0554) 	EECR|=BIT(EEWE);//EEWE置1
    00429 9AE1      SBI	0x1C,1
(0555) 	
(0556) 	while(EECR & BIT(EEWE));//判断EEWE是否为0
    0042A 99E1      SBIC	0x1C,1
    0042B CFFE      RJMP	0x042A
(0557) 	EEAR=0x0015;//写地址
    0042C E185      LDI	R24,0x15
    0042D E090      LDI	R25,0
    0042E BB9F      OUT	0x1F,R25
    0042F BB8E      OUT	0x1E,R24
(0558) 	EEDR=PARA3;//写数据
    00430 BB2D      OUT	0x1D,R18
(0559) 	EECR|=BIT(EEMWE);//EEMWE置1
    00431 9AE2      SBI	0x1C,2
(0560) 	EECR&=(~BIT(EEWE));//EEWE置0
    00432 98E1      CBI	0x1C,1
(0561) 	EECR|=BIT(EEWE);//EEWE置1
    00433 9AE1      SBI	0x1C,1
(0562) 	
(0563) 	SREG |= BIT(3);//打开全局中断
    00434 9438      BSET	3
    00435 9508      RET
(0564) }
(0565) 
(0566) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动第一阶段
(0567) void command_data_read_finger_1_ratio_1(uchar* PARA2,uchar* PARA3)
(0568) {
(0569)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_finger_1_ratio_1:
  PARA3                --> R18
  PARA2                --> R16
    00436 94B8      BCLR	3
(0570) 	
(0571) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    00437 99E1      SBIC	0x1C,1
    00438 CFFE      RJMP	0x0437
(0572) 	EEAR=0x0010;//写地址
    00439 E180      LDI	R24,0x10
    0043A E090      LDI	R25,0
    0043B BB9F      OUT	0x1F,R25
    0043C BB8E      OUT	0x1E,R24
(0573) 	EECR|=BIT(EERE);//读允许位置1
    0043D 9AE0      SBI	0x1C,0
(0574) 	*PARA2=EEDR;//读出EEDR中的数据
    0043E B22D      IN	R2,0x1D
    0043F 01F8      MOVW	R30,R16
    00440 8220      ST	Z,R2
(0575) 
(0576) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    00441 99E1      SBIC	0x1C,1
    00442 CFFE      RJMP	0x0441
(0577) 	EEAR=0x0011;//写地址
    00443 E181      LDI	R24,0x11
    00444 E090      LDI	R25,0
    00445 BB9F      OUT	0x1F,R25
    00446 BB8E      OUT	0x1E,R24
(0578) 	EECR|=BIT(EERE);//读允许位置1
    00447 9AE0      SBI	0x1C,0
(0579) 	*PARA3=EEDR;//读出EEDR中的数据
    00448 B22D      IN	R2,0x1D
    00449 01F9      MOVW	R30,R18
    0044A 8220      ST	Z,R2
(0580) 	
(0581) 	SREG |= BIT(3);//打开全局中断
    0044B 9438      BSET	3
    0044C 9508      RET
(0582) }
(0583) 
(0584) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动第二阶段
(0585) void command_data_read_finger_1_ratio_2(uchar* PARA2,uchar* PARA3)
(0586) {
(0587)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_finger_1_ratio_2:
  PARA3                --> R18
  PARA2                --> R16
    0044D 94B8      BCLR	3
(0588) 	
(0589) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    0044E 99E1      SBIC	0x1C,1
    0044F CFFE      RJMP	0x044E
(0590) 	EEAR=0x0012;//写地址
    00450 E182      LDI	R24,0x12
    00451 E090      LDI	R25,0
    00452 BB9F      OUT	0x1F,R25
    00453 BB8E      OUT	0x1E,R24
(0591) 	EECR|=BIT(EERE);//读允许位置1
    00454 9AE0      SBI	0x1C,0
(0592) 	*PARA2=EEDR;//读出EEDR中的数据
    00455 B22D      IN	R2,0x1D
    00456 01F8      MOVW	R30,R16
    00457 8220      ST	Z,R2
(0593) 
(0594) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    00458 99E1      SBIC	0x1C,1
    00459 CFFE      RJMP	0x0458
(0595) 	EEAR=0x0013;//写地址
    0045A E183      LDI	R24,0x13
    0045B E090      LDI	R25,0
    0045C BB9F      OUT	0x1F,R25
    0045D BB8E      OUT	0x1E,R24
(0596) 	EECR|=BIT(EERE);//读允许位置1
    0045E 9AE0      SBI	0x1C,0
(0597) 	*PARA3=EEDR;//读出EEDR中的数据
    0045F B22D      IN	R2,0x1D
    00460 01F9      MOVW	R30,R18
    00461 8220      ST	Z,R2
(0598) 	
(0599) 	SREG |= BIT(3);//打开全局中断
    00462 9438      BSET	3
    00463 9508      RET
(0600) }
(0601) 
(0602) //舵机控制指令数据读取函数，从EEPROM中读取控制舵机所需的PARA2和PARA3，手指1移动移动阶段
(0603) void command_data_read_finger_1_ratio_3(uchar* PARA2,uchar* PARA3)
(0604) {
(0605)     SREG &=(~BIT(3));//关闭全局中断
_command_data_read_finger_1_ratio_3:
  PARA3                --> R18
  PARA2                --> R16
    00464 94B8      BCLR	3
(0606) 	
(0607) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    00465 99E1      SBIC	0x1C,1
    00466 CFFE      RJMP	0x0465
(0608) 	EEAR=0x0014;//写地址
    00467 E184      LDI	R24,0x14
    00468 E090      LDI	R25,0
    00469 BB9F      OUT	0x1F,R25
    0046A BB8E      OUT	0x1E,R24
(0609) 	EECR|=BIT(EERE);//读允许位置1
    0046B 9AE0      SBI	0x1C,0
(0610) 	*PARA2=EEDR;//读出EEDR中的数据
    0046C B22D      IN	R2,0x1D
    0046D 01F8      MOVW	R30,R16
    0046E 8220      ST	Z,R2
(0611) 
(0612) 	while(EECR & BIT(EEWE));//等待前面的“写”操作完成
    0046F 99E1      SBIC	0x1C,1
    00470 CFFE      RJMP	0x046F
(0613) 	EEAR=0x0015;//写地址
    00471 E185      LDI	R24,0x15
    00472 E090      LDI	R25,0
    00473 BB9F      OUT	0x1F,R25
    00474 BB8E      OUT	0x1E,R24
(0614) 	EECR|=BIT(EERE);//读允许位置1
    00475 9AE0      SBI	0x1C,0
(0615) 	*PARA3=EEDR;//读出EEDR中的数据
    00476 B22D      IN	R2,0x1D
    00477 01F9      MOVW	R30,R18
    00478 8220      ST	Z,R2
(0616) 	
(0617) 	SREG |= BIT(3);//打开全局中断
    00479 9438      BSET	3
    0047A 9508      RET
(0618) }
(0619) 
(0620) 
(0621) //----------------【外部中断向量定义与外部中断处理函数】↓--------------------------------
(0622) 
(0623) void ext_interrupt_init(void)
(0624) {
(0625)     //PD0=INT0=夹持器上方触碰，带上拉电阻输入
(0626)     DDRD&=(~BIT(0));//意思是DDRD0=0，其余位不变。但注意不可按注释的方式写！
_ext_interrupt_init:
    0047B 9888      CBI	0x11,0
(0627)     PORTD|=BIT(0);//意思是PORTD0=1，其余位不变。但注意不可按注释的方式写！
    0047C 9A90      SBI	0x12,0
(0628) 	
(0629)     //PD1=INT1=夹持器下方触碰，带上拉电阻输入
(0630)     DDRD&=(~BIT(1));
    0047D 9889      CBI	0x11,1
(0631)     PORTD|=BIT(1);
    0047E 9A91      SBI	0x12,1
(0632) 
(0633) 	//PE4=INT4=夹持器前方触碰，带上拉电阻输入
(0634)     DDRE&=(~BIT(4));
    0047F 9814      CBI	0x02,4
(0635)     PORTE|=BIT(4);
    00480 9A1C      SBI	0x03,4
(0636) 	
(0637) 	//INT0和INT1的外部中断寄存器配置
(0638)     EICRA|=BIT(ISC01)|BIT(ISC11);//中断触发方式：下降沿触发
    00481 9180 006A LDS	R24,0x6A
    00483 608A      ORI	R24,0xA
    00484 9380 006A STS	0x6A,R24
(0639)     EIMSK|=BIT(0)|BIT(1);//中断使能	
    00486 B789      IN	R24,0x39
    00487 6083      ORI	R24,3
    00488 BF89      OUT	0x39,R24
(0640) 
(0641)     //INT4的外部中断寄存器配置
(0642)     EICRB|=BIT(ISC41);//中断触发方式：下降沿触发
    00489 B78A      IN	R24,0x3A
    0048A 6082      ORI	R24,2
    0048B BF8A      OUT	0x3A,R24
(0643)     EIMSK|=BIT(4);//中断使能
    0048C B789      IN	R24,0x39
    0048D 6180      ORI	R24,0x10
    0048E BF89      OUT	0x39,R24
    0048F 9508      RET
_interrupt_0_handler:
    00490 920A      ST	-Y,R0
    00491 921A      ST	-Y,R1
    00492 922A      ST	-Y,R2
    00493 923A      ST	-Y,R3
    00494 924A      ST	-Y,R4
    00495 925A      ST	-Y,R5
    00496 926A      ST	-Y,R6
    00497 927A      ST	-Y,R7
    00498 928A      ST	-Y,R8
    00499 929A      ST	-Y,R9
    0049A 930A      ST	-Y,R16
    0049B 931A      ST	-Y,R17
    0049C 932A      ST	-Y,R18
    0049D 933A      ST	-Y,R19
    0049E 938A      ST	-Y,R24
    0049F 939A      ST	-Y,R25
    004A0 93AA      ST	-Y,R26
    004A1 93BA      ST	-Y,R27
    004A2 93EA      ST	-Y,R30
    004A3 93FA      ST	-Y,R31
    004A4 B60F      IN	R0,0x3F
    004A5 920A      ST	-Y,R0
(0644) }
(0645) 
(0646) //夹持器上方触碰（INT0）中断向量定义 
(0647) #pragma interrupt_handler interrupt_0_handler:2
(0648) 
(0649) //夹持器上方触碰（INT0）中断处理函数
(0650) void interrupt_0_handler(void)
(0651) {
(0652) 	if(ext_collision_alert_allow_int0)
    004A6 9020 012A LDS	R2,ext_collision_alert_allow_int0
    004A8 2022      TST	R2
    004A9 F049      BEQ	0x04B3
(0653) 	{
(0654) 	    delay(50);
    004AA E302      LDI	R16,0x32
    004AB E010      LDI	R17,0
    004AC DC36      RCALL	_delay
(0655) 		uart0_send_string("zz41");
    004AD EE0F      LDI	R16,0xEF
    004AE E011      LDI	R17,1
    004AF DCF9      RCALL	_uart0_send_string
(0656)         ext_collision_alert_allow_int0=0;//全局变量
    004B0 2422      CLR	R2
    004B1 9220 012A STS	ext_collision_alert_allow_int0,R2
(0657) 	}
    004B3 9009      LD	R0,Y+
    004B4 BE0F      OUT	0x3F,R0
    004B5 91F9      LD	R31,Y+
    004B6 91E9      LD	R30,Y+
    004B7 91B9      LD	R27,Y+
    004B8 91A9      LD	R26,Y+
    004B9 9199      LD	R25,Y+
    004BA 9189      LD	R24,Y+
    004BB 9139      LD	R19,Y+
    004BC 9129      LD	R18,Y+
    004BD 9119      LD	R17,Y+
    004BE 9109      LD	R16,Y+
    004BF 9099      LD	R9,Y+
    004C0 9089      LD	R8,Y+
    004C1 9079      LD	R7,Y+
    004C2 9069      LD	R6,Y+
    004C3 9059      LD	R5,Y+
    004C4 9049      LD	R4,Y+
    004C5 9039      LD	R3,Y+
    004C6 9029      LD	R2,Y+
    004C7 9019      LD	R1,Y+
    004C8 9009      LD	R0,Y+
    004C9 9518      RETI
_interrupt_1_handler:
    004CA 920A      ST	-Y,R0
    004CB 921A      ST	-Y,R1
    004CC 922A      ST	-Y,R2
    004CD 923A      ST	-Y,R3
    004CE 924A      ST	-Y,R4
    004CF 925A      ST	-Y,R5
    004D0 926A      ST	-Y,R6
    004D1 927A      ST	-Y,R7
    004D2 928A      ST	-Y,R8
    004D3 929A      ST	-Y,R9
    004D4 930A      ST	-Y,R16
    004D5 931A      ST	-Y,R17
    004D6 932A      ST	-Y,R18
    004D7 933A      ST	-Y,R19
    004D8 938A      ST	-Y,R24
    004D9 939A      ST	-Y,R25
    004DA 93AA      ST	-Y,R26
    004DB 93BA      ST	-Y,R27
    004DC 93EA      ST	-Y,R30
    004DD 93FA      ST	-Y,R31
    004DE B60F      IN	R0,0x3F
    004DF 920A      ST	-Y,R0
(0658) }
(0659) 
(0660) //夹持器下方触碰（INT1）中断向量定义 
(0661) #pragma interrupt_handler interrupt_1_handler:3
(0662) 
(0663) //夹持器下方触碰（INT1）中断处理函数
(0664) void interrupt_1_handler(void)
(0665) {
(0666) 	if(ext_collision_alert_allow_int1)
    004E0 9020 012B LDS	R2,ext_collision_alert_allow_int1
    004E2 2022      TST	R2
    004E3 F049      BEQ	0x04ED
(0667) 	{
(0668) 	    delay(50);
    004E4 E302      LDI	R16,0x32
    004E5 E010      LDI	R17,0
    004E6 DBFC      RCALL	_delay
(0669) 		uart0_send_string("zz42");
    004E7 EE0A      LDI	R16,0xEA
    004E8 E011      LDI	R17,1
    004E9 DCBF      RCALL	_uart0_send_string
(0670)         ext_collision_alert_allow_int1=0;//全局变量
    004EA 2422      CLR	R2
    004EB 9220 012B STS	ext_collision_alert_allow_int1,R2
(0671) 	}
    004ED 9009      LD	R0,Y+
    004EE BE0F      OUT	0x3F,R0
    004EF 91F9      LD	R31,Y+
    004F0 91E9      LD	R30,Y+
    004F1 91B9      LD	R27,Y+
    004F2 91A9      LD	R26,Y+
    004F3 9199      LD	R25,Y+
    004F4 9189      LD	R24,Y+
    004F5 9139      LD	R19,Y+
    004F6 9129      LD	R18,Y+
    004F7 9119      LD	R17,Y+
    004F8 9109      LD	R16,Y+
    004F9 9099      LD	R9,Y+
    004FA 9089      LD	R8,Y+
    004FB 9079      LD	R7,Y+
    004FC 9069      LD	R6,Y+
    004FD 9059      LD	R5,Y+
    004FE 9049      LD	R4,Y+
    004FF 9039      LD	R3,Y+
    00500 9029      LD	R2,Y+
    00501 9019      LD	R1,Y+
    00502 9009      LD	R0,Y+
    00503 9518      RETI
_interrupt_4_handler:
    00504 920A      ST	-Y,R0
    00505 921A      ST	-Y,R1
    00506 922A      ST	-Y,R2
    00507 923A      ST	-Y,R3
    00508 924A      ST	-Y,R4
    00509 925A      ST	-Y,R5
    0050A 926A      ST	-Y,R6
    0050B 927A      ST	-Y,R7
    0050C 928A      ST	-Y,R8
    0050D 929A      ST	-Y,R9
    0050E 930A      ST	-Y,R16
    0050F 931A      ST	-Y,R17
    00510 932A      ST	-Y,R18
    00511 933A      ST	-Y,R19
    00512 938A      ST	-Y,R24
    00513 939A      ST	-Y,R25
    00514 93AA      ST	-Y,R26
    00515 93BA      ST	-Y,R27
    00516 93EA      ST	-Y,R30
    00517 93FA      ST	-Y,R31
    00518 B60F      IN	R0,0x3F
    00519 920A      ST	-Y,R0
(0672) }
(0673) 
(0674) //夹持器指尖触碰（INT4）中断向量定义 
(0675) #pragma interrupt_handler interrupt_4_handler:6
(0676) 
(0677) //夹持器指尖触碰（INT4）中断处理函数
(0678) void interrupt_4_handler(void)
(0679) {
(0680) 	if(ext_collision_alert_allow_int4)
    0051A 9020 012C LDS	R2,ext_collision_alert_allow_int4
    0051C 2022      TST	R2
    0051D F049      BEQ	0x0527
(0681) 	{
(0682) 	    delay(50);
    0051E E302      LDI	R16,0x32
    0051F E010      LDI	R17,0
    00520 DBC2      RCALL	_delay
(0683) 		uart0_send_string("zz43");
    00521 EE05      LDI	R16,0xE5
    00522 E011      LDI	R17,1
    00523 DC85      RCALL	_uart0_send_string
(0684)         ext_collision_alert_allow_int4=0;//全局变量
    00524 2422      CLR	R2
    00525 9220 012C STS	ext_collision_alert_allow_int4,R2
(0685) 	}
    00527 9009      LD	R0,Y+
    00528 BE0F      OUT	0x3F,R0
    00529 91F9      LD	R31,Y+
    0052A 91E9      LD	R30,Y+
    0052B 91B9      LD	R27,Y+
    0052C 91A9      LD	R26,Y+
    0052D 9199      LD	R25,Y+
    0052E 9189      LD	R24,Y+
    0052F 9139      LD	R19,Y+
    00530 9129      LD	R18,Y+
    00531 9119      LD	R17,Y+
    00532 9109      LD	R16,Y+
    00533 9099      LD	R9,Y+
    00534 9089      LD	R8,Y+
    00535 9079      LD	R7,Y+
    00536 9069      LD	R6,Y+
    00537 9059      LD	R5,Y+
    00538 9049      LD	R4,Y+
    00539 9039      LD	R3,Y+
    0053A 9029      LD	R2,Y+
    0053B 9019      LD	R1,Y+
    0053C 9009      LD	R0,Y+
    0053D 9518      RETI
_main:
  com_finger1_ratio_2_PARA3 --> Y,+45
  com_finger1_ratio_2_PARA2 --> Y,+44
  com_finger0_ratio_2_PARA3 --> Y,+43
  com_finger0_ratio_2_PARA2 --> Y,+42
  com_finger1_ratio_3_PARA3 --> Y,+41
  com_finger1_ratio_3_PARA2 --> Y,+40
  com_finger1_ratio_1_PARA3 --> Y,+39
  com_finger1_ratio_1_PARA2 --> Y,+38
  com_finger0_ratio_3_PARA3 --> Y,+37
  com_finger0_ratio_3_PARA2 --> Y,+36
  com_finger0_ratio_1_PARA3 --> Y,+35
  com_finger0_ratio_1_PARA2 --> Y,+34
  hold_stage_2_continue --> Y,+53
  CHECK                --> R10
  approach_1           --> R14
  approach_0           --> R12
  PARA3                --> R22
  PARA2                --> R20
  release_allow_motor_1 --> Y,+52
  release_allow_motor_0 --> Y,+51
  motor_command        --> Y,+25
  hold_allow_motor_1   --> Y,+50
  hold_allow_motor_0   --> Y,+49
  msg_eeprom_array     --> Y,+8
  msg_interrupt_array  --> Y,+1
  stop_allow_empty     --> Y,+48
  stop_allow_cage_1    --> Y,+47
  stop_allow_cage_0    --> Y,+46
  cage_1               --> R12
  cage_0               --> R10
  i                    --> R10
    0053E 97E6      SBIW	R28,0x36
(0686) }
(0687) 
(0688) 
(0689) 
(0690) //---------------------------【主函数】↓-----------------------------------------------------------
(0691) void main(void)
(0692) {
(0693) 
(0694)  	//.....................[函数体内变量声明]...............................
(0695) 
(0696)  	uchar i;//清空指令存储变量时所用循环的计数变量
(0697) 	
(0698) 	//向舵机发送移动命令时所用的变量（下面2个）↓
(0699) 	uchar motor_command[9]={0xff,0xff,0x00,0x05,0x03,0x20,0x00,0x00,0x00};//
    0053F E383      LDI	R24,0x33
    00540 E091      LDI	R25,1
    00541 01FE      MOVW	R30,R28
    00542 9679      ADIW	R30,0x19
    00543 E009      LDI	R16,0x9
    00544 E010      LDI	R17,0
    00545 93FA      ST	-Y,R31
    00546 93EA      ST	-Y,R30
    00547 939A      ST	-Y,R25
    00548 938A      ST	-Y,R24
    00549 940E 0B60 CALL	asgnblk
(0700) 	uchar CHECK;//舵机指令最后一位校验码
(0701) 	
(0702) 	//上电手指复位阶段用到的变量（下面2个）↓
(0703) 	//保证舵机停止命令只进行一次
(0704) 	uchar cage_0=1;
    0054B 24AA      CLR	R10
    0054C 94A3      INC	R10
(0705) 	uchar cage_1=1;
    0054D 24CC      CLR	R12
    0054E 94C3      INC	R12
(0706) 	
(0707) 	//正常工作模式（模式一）手指松开阶段用到的变量（下面2个）↓
(0708) 	//保证每次夹紧操作时舵机停止命令只进行一次	
(0709) 	uchar approach_0;
(0710) 	uchar approach_1;
(0711) 	
(0712) 	//夹紧第二阶段的while循环跳出指示
(0713) 	uchar hold_stage_2_continue=1;
    0054F 2400      CLR	R0
    00550 9403      INC	R0
    00551 AA0D      STD	Y+53,R0
(0714) 	
(0715) 	//大循环中查询两端限位和空夹所用到的变量（下面7个）↓
(0716) 	//while大循环从两端限位后开始，因此不允许再次发送舵机停止命令，而是等待限位结束
(0717) 	uchar stop_allow_cage_0=0;
    00552 2400      CLR	R0
    00553 A60E      STD	Y+46,R0
(0718) 	uchar stop_allow_cage_1=0;
    00554 A60F      STD	Y+47,R0
(0719) 	//不允许手指向端部移动，允许手指向中间移动，设置四个变量是因为考虑到两端限位跟空夹
(0720) 	uchar release_allow_motor_0=0;
    00555 AA0B      STD	Y+51,R0
(0721) 	uchar release_allow_motor_1=0;
    00556 AA0C      STD	Y+52,R0
(0722) 	uchar hold_allow_motor_0=1;
    00557 2400      CLR	R0
    00558 9403      INC	R0
    00559 AA09      STD	Y+49,R0
(0723) 	uchar hold_allow_motor_1=1;
    0055A AA0A      STD	Y+50,R0
(0724) 	//允许上电复位后就开始检测是否空夹
(0725) 	uchar stop_allow_empty=1;
    0055B AA08      STD	Y+48,R0
(0726) 	
(0727) 	//调试模式手指移动速度，初始值为通过串口设定前的默认值
(0728) 	uchar PARA2=0x10,PARA3=0x01;//保证低速，仅允许通过串口命令更改其值！
    0055C E140      LDI	R20,0x10
    0055D E061      LDI	R22,1
(0729) 	
(0730) 	//一般模式手指移动速度，仅允从EEPROM中获取数值
(0731) 	uchar com_finger0_ratio_1_PARA2,com_finger0_ratio_1_PARA3;//手指0，Ratio 1
(0732) 	uchar com_finger0_ratio_2_PARA2,com_finger0_ratio_2_PARA3;//手指0，Ratio 2
(0733) 	uchar com_finger0_ratio_3_PARA2,com_finger0_ratio_3_PARA3;//手指0，Ratio 3
(0734) 	uchar com_finger1_ratio_1_PARA2,com_finger1_ratio_1_PARA3;//手指1，Ratio 1
(0735) 	uchar com_finger1_ratio_2_PARA2,com_finger1_ratio_2_PARA3;//手指1，Ratio 2
(0736) 	uchar com_finger1_ratio_3_PARA2,com_finger1_ratio_3_PARA3;//手指1，Ratio 3
(0737) 	
(0738) 	uchar msg_eeprom_array[17];//向上位机返回EEPROM中数值
(0739) 	uchar msg_interrupt_array[7]={'z','z','4','4','0','0','0'};//向上位机返回夹持器与外部碰撞报警（中断）允许变量的值
    0055E E38C      LDI	R24,0x3C
    0055F E091      LDI	R25,1
    00560 01FE      MOVW	R30,R28
    00561 9631      ADIW	R30,1
    00562 E007      LDI	R16,7
    00563 E010      LDI	R17,0
    00564 93FA      ST	-Y,R31
    00565 93EA      ST	-Y,R30
    00566 939A      ST	-Y,R25
    00567 938A      ST	-Y,R24
    00568 940E 0B60 CALL	asgnblk
(0740) 	
(0741) 	
(0742) 	//.......................[初始化配置].........................
(0743) 	
(0744)     uart0_init(19200);//串口0（与上位机通信）初始化，波特率均为19200
    0056A E000      LDI	R16,0
    0056B E41B      LDI	R17,0x4B
    0056C DB8B      RCALL	_uart0_init
(0745)     uart1_init(19200);//串口1（与舵机通信）初始化，波特率均为19200
    0056D E000      LDI	R16,0
    0056E E41B      LDI	R17,0x4B
    0056F DC5E      RCALL	_uart1_init
(0746) 	timer1_init();//定时计数器1初始化
    00570 DD95      RCALL	_timer1_init
(0747) 	force_data_init();//应变片读取初始化
    00571 DD08      RCALL	_force_data_init
(0748) 	
(0749) 	
(0750) 	//限位的配置
(0751) 	
(0752) 	//PE2=接近开关0，高阻态输入
(0753) 	DDRE&=(~BIT(2));//DDRE2=0
    00572 9812      CBI	0x02,2
(0754) 	PORTE&=(~BIT(2));//PORTE2=0
    00573 981A      CBI	0x03,2
(0755) 	
(0756) 	//PE3=接近开关1，高阻态输入
(0757) 	DDRE&=(~BIT(3));//DDRE2=0
    00574 9813      CBI	0x02,3
(0758) 	PORTE&=(~BIT(3));//PORTE2=0
    00575 981B      CBI	0x03,3
(0759) 	
(0760)     //PE5=INT5=限位0，带上拉电阻输入
(0761)     DDRE&=(~BIT(5));//意思是DDRE5=0，其余位不变。但注意不可按注释的方式写！
    00576 9815      CBI	0x02,5
(0762)     PORTE|=BIT(5);//意思是PORTE5=1，其余位不变。但注意不可按注释的方式写！
    00577 9A1D      SBI	0x03,5
(0763) 	
(0764)     //PE6=INT6=限位1，带上拉电阻输入
(0765)     DDRE&=(~BIT(6));
    00578 9816      CBI	0x02,6
(0766)     PORTE|=BIT(6);
    00579 9A1E      SBI	0x03,6
(0767) 
(0768) 	//PE7=空夹，带上拉电阻输入
(0769)     DDRE&=(~BIT(7));
    0057A 9817      CBI	0x02,7
(0770)     PORTE|=BIT(7);
    0057B 9A1F      SBI	0x03,7
(0771) 	
(0772) 	
(0773) 	//................[功能：上电后手指复位]....................................
(0774) 
(0775)     SREG |= 0X80;//打开全局中断
    0057C 9478      BSET	7
(0776)     
(0777)     //相关变量初始化
(0778)     cage0_state=0;
    0057D 2422      CLR	R2
    0057E 9220 0204 STS	cage0_state,R2
(0779)     cage1_state=0;
    00580 9220 0203 STS	cage1_state,R2
(0780) 
(0781)     //命令舵机停止转动
(0782)     uart1_send_string((uchar*)no0stop,9);
    00582 E029      LDI	R18,0x9
    00583 E00C      LDI	R16,0xC
    00584 E011      LDI	R17,1
    00585 DC91      RCALL	_uart1_send_string
(0783) 	delay(50);
    00586 E302      LDI	R16,0x32
    00587 E010      LDI	R17,0
    00588 DB5A      RCALL	_delay
(0784) 	uart1_send_string((uchar*)no1stop,9);
    00589 E029      LDI	R18,0x9
    0058A E10E      LDI	R16,0x1E
    0058B E011      LDI	R17,1
    0058C DC8A      RCALL	_uart1_send_string
(0785)     delay(50);
    0058D E302      LDI	R16,0x32
    0058E E010      LDI	R17,0
    0058F DB53      RCALL	_delay
(0786) 	
(0787)     //使手爪松开
(0788)     uart1_send_string((uchar*)no0release,9);
    00590 E029      LDI	R18,0x9
    00591 E003      LDI	R16,3
    00592 E011      LDI	R17,1
    00593 DC83      RCALL	_uart1_send_string
(0789) 	delay(50);
    00594 E302      LDI	R16,0x32
    00595 E010      LDI	R17,0
    00596 DB4C      RCALL	_delay
(0790)     uart1_send_string((uchar*)no1release,9);
    00597 E029      LDI	R18,0x9
    00598 E105      LDI	R16,0x15
    00599 E011      LDI	R17,1
    0059A DC7C      RCALL	_uart1_send_string
    0059B C01C      RJMP	0x05B8
(0791) 
(0792)     //等待两端限位触发	
(0793) 	while(cage_0|cage_1)
(0794) 	{
(0795) 	    if(cage_0)
    0059C 20AA      TST	R10
    0059D F061      BEQ	0x05AA
(0796) 		{
(0797)     	    if(!(PINE & BIT(5)))//PE5=0进入
    0059E 990D      SBIC	0x01,5
    0059F C00A      RJMP	0x05AA
(0798) 	    	{
(0799) 		        delay(50);
    005A0 E302      LDI	R16,0x32
    005A1 E010      LDI	R17,0
    005A2 DB40      RCALL	_delay
(0800) 				if(!(PINE & BIT(5)))
    005A3 990D      SBIC	0x01,5
    005A4 C005      RJMP	0x05AA
(0801) 				{
(0802) 			        uart1_send_string((uchar*)no0stop,9);
    005A5 E029      LDI	R18,0x9
    005A6 E00C      LDI	R16,0xC
    005A7 E011      LDI	R17,1
    005A8 DC6E      RCALL	_uart1_send_string
(0803) 					//uart0_send_string("zz30");
(0804) 					cage_0=0;
    005A9 24AA      CLR	R10
(0805) 			    }
(0806) 			
(0807) 		    }
(0808) 		}
(0809) 		
(0810) 	    if(cage_1)
    005AA 20CC      TST	R12
    005AB F061      BEQ	0x05B8
(0811) 		{
(0812)     	    if(!(PINE & BIT(6)))//PE6=0进入
    005AC 990E      SBIC	0x01,6
    005AD C00A      RJMP	0x05B8
(0813) 	    	{
(0814) 		        delay(50);
    005AE E302      LDI	R16,0x32
    005AF E010      LDI	R17,0
    005B0 DB32      RCALL	_delay
(0815) 				if(!(PINE & BIT(6)))
    005B1 990E      SBIC	0x01,6
    005B2 C005      RJMP	0x05B8
(0816) 				{
(0817) 			        uart1_send_string((uchar*)no1stop,9);
    005B3 E029      LDI	R18,0x9
    005B4 E10E      LDI	R16,0x1E
    005B5 E011      LDI	R17,1
    005B6 DC60      RCALL	_uart1_send_string
(0818) 					//uart0_send_string("zz31");
(0819) 					cage_1=0;
    005B7 24CC      CLR	R12
    005B8 2C2A      MOV	R2,R10
    005B9 282C      OR	R2,R12
    005BA F709      BNE	0x059C
(0820) 			    }
(0821) 			
(0822) 		    }
(0823) 		}
(0824) 	}
(0825) 	
(0826)     uart0_send_string("zz00");//向上位机报告准备就绪
    005BB EE00      LDI	R16,0xE0
    005BC E011      LDI	R17,1
    005BD DBEB      RCALL	_uart0_send_string
(0827) 	
(0828) 	UCSR0B|=(1<<RXEN0)|(1<<RXCIE0);   //UART0接收使能，接收中断使能
    005BE B18A      IN	R24,0x0A
    005BF 6980      ORI	R24,0x90
    005C0 B98A      OUT	0x0A,R24
    005C1 C4ED      RJMP	0x0AAF
(0829) 	
(0830) 	
(0831) //........................[while(1)大循环]............................................
(0832) 	
(0833)     while(1)
(0834) 	{
(0835) 	 	 if(uart0_instr_flag==1)
    005C2 9180 0129 LDS	R24,uart0_instr_flag
    005C4 3081      CPI	R24,1
    005C5 F009      BEQ	0x05C7
    005C6 C43E      RJMP	0x0A05
(0836) 		 {
(0837) 	         switch(gripper_mood)
    005C7 90A0 0127 LDS	R10,gripper_mood
    005C9 24BB      CLR	R11
    005CA 20AA      TST	R10
    005CB F411      BNE	0x05CE
    005CC 20BB      TST	R11
    005CD F061      BEQ	0x05DA
    005CE 01C5      MOVW	R24,R10
    005CF 3081      CPI	R24,1
    005D0 E0E0      LDI	R30,0
    005D1 079E      CPC	R25,R30
    005D2 F409      BNE	0x05D4
    005D3 C05C      RJMP	0x0630
    005D4 3082      CPI	R24,2
    005D5 E0E0      LDI	R30,0
    005D6 079E      CPC	R25,R30
    005D7 F409      BNE	0x05D9
    005D8 C245      RJMP	0x081E
    005D9 C3DB      RJMP	0x09B5
(0838) 		     {
(0839) 	             case 0:
(0840) 			     {
(0841) 			         if(array_cmp(uart0_instr,"0100")==0)
    005DA ED2B      LDI	R18,0xDB
    005DB E031      LDI	R19,1
    005DC EF0D      LDI	R16,0xFD
    005DD E011      LDI	R17,1
    005DE DC63      RCALL	_array_cmp
    005DF 3000      CPI	R16,0
    005E0 0701      CPC	R16,R17
    005E1 F009      BEQ	0x05E3
    005E2 C038      RJMP	0x061B
(0842) 				     {
(0843) 				         //uart0_send_string(" mood 0: enter 1-regular working mood! ");
(0844) 					 	 gripper_mood=1;
    005E3 E081      LDI	R24,1
    005E4 9380 0127 STS	gripper_mood,R24
(0845) 						 ext_interrupt_init();//外部中断（夹持器与外部环境碰撞）初始化
    005E6 DE94      RCALL	_ext_interrupt_init
(0846) 						 //初始化后会立即出发一次INT0和INT1，所以报警允许变量需要先置0再置1
(0847) 						 
(0848) 						 //夹持器与外部碰撞报警（中断）允许变量
(0849) 						 ext_collision_alert_allow_int0=1;//上侧
    005E7 E081      LDI	R24,1
    005E8 9380 012A STS	ext_collision_alert_allow_int0,R24
(0850) 						 ext_collision_alert_allow_int1=1;//下侧
    005EA 9380 012B STS	ext_collision_alert_allow_int1,R24
(0851) 						 ext_collision_alert_allow_int4=1;//指尖
    005EC 9380 012C STS	ext_collision_alert_allow_int4,R24
(0852) 
(0853) 						 
(0854) 						 //获取EEPROM中存储的RATIO值
(0855)     					 command_data_read_finger_0_ratio_1(&com_finger0_ratio_1_PARA2,&com_finger0_ratio_1_PARA3);
    005EE 019E      MOVW	R18,R28
    005EF 5D2D      SUBI	R18,0xDD
    005F0 4F3F      SBCI	R19,0xFF
    005F1 018E      MOVW	R16,R28
    005F2 5D0E      SUBI	R16,0xDE
    005F3 4F1F      SBCI	R17,0xFF
    005F4 DDB7      RCALL	_command_data_read_finger_0_ratio_1
(0856) 						 command_data_read_finger_0_ratio_2(&com_finger0_ratio_2_PARA2,&com_finger0_ratio_2_PARA3);
    005F5 019E      MOVW	R18,R28
    005F6 5D25      SUBI	R18,0xD5
    005F7 4F3F      SBCI	R19,0xFF
    005F8 018E      MOVW	R16,R28
    005F9 5D06      SUBI	R16,0xD6
    005FA 4F1F      SBCI	R17,0xFF
    005FB DDC7      RCALL	_command_data_read_finger_0_ratio_2
(0857) 						 command_data_read_finger_0_ratio_3(&com_finger0_ratio_3_PARA2,&com_finger0_ratio_3_PARA3);
    005FC 019E      MOVW	R18,R28
    005FD 5D2B      SUBI	R18,0xDB
    005FE 4F3F      SBCI	R19,0xFF
    005FF 018E      MOVW	R16,R28
    00600 5D0C      SUBI	R16,0xDC
    00601 4F1F      SBCI	R17,0xFF
    00602 DDD7      RCALL	_command_data_read_finger_0_ratio_3
(0858) 						 command_data_read_finger_1_ratio_1(&com_finger1_ratio_1_PARA2,&com_finger1_ratio_1_PARA3);
    00603 019E      MOVW	R18,R28
    00604 5D29      SUBI	R18,0xD9
    00605 4F3F      SBCI	R19,0xFF
    00606 018E      MOVW	R16,R28
    00607 5D0A      SUBI	R16,0xDA
    00608 4F1F      SBCI	R17,0xFF
    00609 DE2C      RCALL	_command_data_read_finger_1_ratio_1
(0859) 						 command_data_read_finger_1_ratio_2(&com_finger1_ratio_2_PARA2,&com_finger1_ratio_2_PARA3);
    0060A 019E      MOVW	R18,R28
    0060B 5D23      SUBI	R18,0xD3
    0060C 4F3F      SBCI	R19,0xFF
    0060D 018E      MOVW	R16,R28
    0060E 5D04      SUBI	R16,0xD4
    0060F 4F1F      SBCI	R17,0xFF
    00610 DE3C      RCALL	_command_data_read_finger_1_ratio_2
(0860) 						 command_data_read_finger_1_ratio_3(&com_finger1_ratio_3_PARA2,&com_finger1_ratio_3_PARA3);
    00611 019E      MOVW	R18,R28
    00612 5D27      SUBI	R18,0xD7
    00613 4F3F      SBCI	R19,0xFF
    00614 018E      MOVW	R16,R28
    00615 5D08      SUBI	R16,0xD8
    00616 4F1F      SBCI	R17,0xFF
    00617 DE4C      RCALL	_command_data_read_finger_1_ratio_3
(0861) 	
(0862) 						 //获取EEPROM中存储的夹紧力阈值有效值高八位
(0863) 						 command_data_read_force_high8(&force_judge);
    00618 EF0B      LDI	R16,0xFB
    00619 E011      LDI	R17,1
    0061A DCDE      RCALL	_command_data_read_force_high8
(0864) 						 
(0865) 	
(0866) 				     }
(0867) 				 
(0868) 				 	 if(array_cmp(uart0_instr,"0200")==0)
    0061B ED26      LDI	R18,0xD6
    0061C E031      LDI	R19,1
    0061D EF0D      LDI	R16,0xFD
    0061E E011      LDI	R17,1
    0061F DC22      RCALL	_array_cmp
    00620 3000      CPI	R16,0
    00621 0701      CPC	R16,R17
    00622 F009      BEQ	0x0624
    00623 C391      RJMP	0x09B5
(0869) 				 	 {
(0870) 				         //uart0_send_string(" mood 0: enter 2-configuration mood! ");
(0871) 					 	 gripper_mood=2;
    00624 E082      LDI	R24,2
    00625 9380 0127 STS	gripper_mood,R24
(0872) 						 ext_interrupt_init();//外部中断（夹持器与外部环境碰撞）初始化
    00627 DE53      RCALL	_ext_interrupt_init
(0873) 						 //初始化后会立即出发一次INT0和INT1，所以报警允许变量需要先置0再置1
(0874) 						 
(0875) 						 //夹持器与外部碰撞报警（中断）允许变量
(0876) 						 ext_collision_alert_allow_int0=1;//上侧
    00628 E081      LDI	R24,1
    00629 9380 012A STS	ext_collision_alert_allow_int0,R24
(0877) 						 ext_collision_alert_allow_int1=1;//下侧
    0062B 9380 012B STS	ext_collision_alert_allow_int1,R24
(0878) 						 ext_collision_alert_allow_int4=1;//指尖
    0062D 9380 012C STS	ext_collision_alert_allow_int4,R24
(0879) 				 	 }
(0880) 				 
(0881) 				 	 break;
    0062F C385      RJMP	0x09B5
(0882) 			     }
(0883) 			 
(0884) 		         case 1:
(0885) 			     {
(0886) 			     	 if(array_cmp(uart0_instr,"1000")==0)//调试模式・读取EEPROM中存储的RATIO和力阈值
    00630 ED21      LDI	R18,0xD1
    00631 E031      LDI	R19,1
    00632 EF0D      LDI	R16,0xFD
    00633 E011      LDI	R17,1
    00634 DC0D      RCALL	_array_cmp
    00635 0158      MOVW	R10,R16
    00636 3000      CPI	R16,0
    00637 0701      CPC	R16,R17
    00638 F009      BEQ	0x063A
    00639 C056      RJMP	0x0690
(0887) 				 	 {
(0888) 						 //更新ratio变量值、力阈值和消息数组的值
(0889) 						 
(0890) 						 //获取EEPROM中存储的RATIO值
(0891)     					 command_data_read_finger_0_ratio_1(&com_finger0_ratio_1_PARA2,&com_finger0_ratio_1_PARA3);
    0063A 019E      MOVW	R18,R28
    0063B 5D2D      SUBI	R18,0xDD
    0063C 4F3F      SBCI	R19,0xFF
    0063D 018E      MOVW	R16,R28
    0063E 5D0E      SUBI	R16,0xDE
    0063F 4F1F      SBCI	R17,0xFF
    00640 DD6B      RCALL	_command_data_read_finger_0_ratio_1
(0892) 						 command_data_read_finger_0_ratio_2(&com_finger0_ratio_2_PARA2,&com_finger0_ratio_2_PARA3);
    00641 019E      MOVW	R18,R28
    00642 5D25      SUBI	R18,0xD5
    00643 4F3F      SBCI	R19,0xFF
    00644 018E      MOVW	R16,R28
    00645 5D06      SUBI	R16,0xD6
    00646 4F1F      SBCI	R17,0xFF
    00647 DD7B      RCALL	_command_data_read_finger_0_ratio_2
(0893) 						 command_data_read_finger_0_ratio_3(&com_finger0_ratio_3_PARA2,&com_finger0_ratio_3_PARA3);
    00648 019E      MOVW	R18,R28
    00649 5D2B      SUBI	R18,0xDB
    0064A 4F3F      SBCI	R19,0xFF
    0064B 018E      MOVW	R16,R28
    0064C 5D0C      SUBI	R16,0xDC
    0064D 4F1F      SBCI	R17,0xFF
    0064E DD8B      RCALL	_command_data_read_finger_0_ratio_3
(0894) 						 command_data_read_finger_1_ratio_1(&com_finger1_ratio_1_PARA2,&com_finger1_ratio_1_PARA3);
    0064F 019E      MOVW	R18,R28
    00650 5D29      SUBI	R18,0xD9
    00651 4F3F      SBCI	R19,0xFF
    00652 018E      MOVW	R16,R28
    00653 5D0A      SUBI	R16,0xDA
    00654 4F1F      SBCI	R17,0xFF
    00655 DDE0      RCALL	_command_data_read_finger_1_ratio_1
(0895) 						 command_data_read_finger_1_ratio_2(&com_finger1_ratio_2_PARA2,&com_finger1_ratio_2_PARA3);
    00656 019E      MOVW	R18,R28
    00657 5D23      SUBI	R18,0xD3
    00658 4F3F      SBCI	R19,0xFF
    00659 018E      MOVW	R16,R28
    0065A 5D04      SUBI	R16,0xD4
    0065B 4F1F      SBCI	R17,0xFF
    0065C DDF0      RCALL	_command_data_read_finger_1_ratio_2
(0896) 						 command_data_read_finger_1_ratio_3(&com_finger1_ratio_3_PARA2,&com_finger1_ratio_3_PARA3);
    0065D 019E      MOVW	R18,R28
    0065E 5D27      SUBI	R18,0xD7
    0065F 4F3F      SBCI	R19,0xFF
    00660 018E      MOVW	R16,R28
    00661 5D08      SUBI	R16,0xD8
    00662 4F1F      SBCI	R17,0xFF
    00663 DE00      RCALL	_command_data_read_finger_1_ratio_3
(0897) 	
(0898) 						 msg_eeprom_array[0]='z';
    00664 E78A      LDI	R24,0x7A
    00665 8788      STD	Y+8,R24
(0899) 						 msg_eeprom_array[1]='z';
    00666 8789      STD	Y+9,R24
(0900) 						 msg_eeprom_array[2]='3';
    00667 E383      LDI	R24,0x33
    00668 878A      STD	Y+10,R24
(0901) 						 msg_eeprom_array[3]='3';
    00669 878B      STD	Y+11,R24
(0902) 						 msg_eeprom_array[4]=com_finger0_ratio_1_PARA2;
    0066A A02A      LDD	R2,Y+34
    0066B 862C      STD	Y+12,R2
(0903) 						 msg_eeprom_array[5]=com_finger0_ratio_1_PARA3;
    0066C A02B      LDD	R2,Y+35
    0066D 862D      STD	Y+13,R2
(0904) 						 msg_eeprom_array[6]=com_finger0_ratio_2_PARA2;
    0066E A42A      LDD	R2,Y+42
    0066F 862E      STD	Y+14,R2
(0905) 						 msg_eeprom_array[7]=com_finger0_ratio_2_PARA3;
    00670 A42B      LDD	R2,Y+43
    00671 862F      STD	Y+15,R2
(0906) 						 msg_eeprom_array[8]=com_finger0_ratio_3_PARA2;
    00672 A02C      LDD	R2,Y+36
    00673 8A28      STD	Y+16,R2
(0907) 						 msg_eeprom_array[9]=com_finger0_ratio_3_PARA3;
    00674 A02D      LDD	R2,Y+37
    00675 8A29      STD	Y+17,R2
(0908) 						 msg_eeprom_array[10]=com_finger1_ratio_1_PARA2;
    00676 A02E      LDD	R2,Y+38
    00677 8A2A      STD	Y+18,R2
(0909) 						 msg_eeprom_array[11]=com_finger1_ratio_1_PARA3;
    00678 A02F      LDD	R2,Y+39
    00679 8A2B      STD	Y+19,R2
(0910) 						 msg_eeprom_array[12]=com_finger1_ratio_2_PARA2;
    0067A A42C      LDD	R2,Y+44
    0067B 8A2C      STD	Y+20,R2
(0911) 						 msg_eeprom_array[13]=com_finger1_ratio_2_PARA3;
    0067C A42D      LDD	R2,Y+45
    0067D 8A2D      STD	Y+21,R2
(0912) 						 msg_eeprom_array[14]=com_finger1_ratio_3_PARA2;
    0067E A428      LDD	R2,Y+40
    0067F 8A2E      STD	Y+22,R2
(0913) 						 msg_eeprom_array[15]=com_finger1_ratio_3_PARA3;
    00680 A429      LDD	R2,Y+41
    00681 8A2F      STD	Y+23,R2
(0914) 	
(0915) 						 //获取EEPROM中存储的夹紧力阈值有效值高八位
(0916) 						 command_data_read_force_high8(&force_judge);
    00682 EF0B      LDI	R16,0xFB
    00683 E011      LDI	R17,1
    00684 DC74      RCALL	_command_data_read_force_high8
(0917) 						 msg_eeprom_array[16]=force_judge;
    00685 9020 01FB LDS	R2,force_judge
    00687 8E28      STD	Y+24,R2
(0918) 						 
(0919) 						 delay(50);
    00688 E302      LDI	R16,0x32
    00689 E010      LDI	R17,0
    0068A DA58      RCALL	_delay
(0920) 						 uart0_send_string_with_num(msg_eeprom_array,17);//上传EEPROM中存储的数值
    0068B E121      LDI	R18,0x11
    0068C 018E      MOVW	R16,R28
    0068D 5F08      SUBI	R16,0xF8
    0068E 4F1F      SBCI	R17,0xFF
    0068F DB2D      RCALL	_uart0_send_string_with_num
(0921) 	
(0922) 					 }
(0923) 	
(0924) 					 
(0925) 					 if(array_cmp(uart0_instr,"1100")==0)//松开
    00690 EC2C      LDI	R18,0xCC
    00691 E031      LDI	R19,1
    00692 EF0D      LDI	R16,0xFD
    00693 E011      LDI	R17,1
    00694 DBAD      RCALL	_array_cmp
    00695 0158      MOVW	R10,R16
    00696 3000      CPI	R16,0
    00697 0701      CPC	R16,R17
    00698 F009      BEQ	0x069A
    00699 C035      RJMP	0x06CF
(0926) 				 	 {
(0927) 				         if(release_allow_motor_0)
    0069A A80B      LDD	R0,Y+51
    0069B 2000      TST	R0
    0069C F0B9      BEQ	0x06B4
(0928) 						 {
(0929) 						     //构造舵机指令
(0930) 							 motor_command[2]=0x00;//ID=0
    0069D 2422      CLR	R2
    0069E 8E2B      STD	Y+27,R2
(0931) 						 	 motor_command[6]=com_finger0_ratio_3_PARA2;
    0069F A02C      LDD	R2,Y+36
    006A0 8E2F      STD	Y+31,R2
(0932) 						 	 motor_command[7]=com_finger0_ratio_3_PARA3+0x04;
    006A1 A18D      LDD	R24,Y+37
    006A2 5F8C      SUBI	R24,0xFC
    006A3 A388      STD	Y+32,R24
(0933) 						 	 CHECK=ratio_command_check(0,com_finger0_ratio_3_PARA2,com_finger0_ratio_3_PARA3+0x04);
    006A4 A18D      LDD	R24,Y+37
    006A5 5F8C      SUBI	R24,0xFC
    006A6 8388      ST	Y,R24
    006A7 A12C      LDD	R18,Y+36
    006A8 2700      CLR	R16
    006A9 DCB2      RCALL	_ratio_command_check
    006AA 2EA0      MOV	R10,R16
(0934) 						 	 motor_command[8]=CHECK;
    006AB A2A9      STD	Y+33,R10
(0935) 						 	 delay(50);
    006AC E302      LDI	R16,0x32
    006AD E010      LDI	R17,0
    006AE DA34      RCALL	_delay
(0936) 						 	 uart1_send_string(motor_command,9);//下发指令
    006AF E029      LDI	R18,0x9
    006B0 018E      MOVW	R16,R28
    006B1 5E07      SUBI	R16,0xE7
    006B2 4F1F      SBCI	R17,0xFF
    006B3 DB63      RCALL	_uart1_send_string
(0937) 						 }
(0938) 						 
(0939) 						 if(release_allow_motor_1)
    006B4 A80C      LDD	R0,Y+52
    006B5 2000      TST	R0
    006B6 F0C1      BEQ	0x06CF
(0940) 						 {
(0941) 						     //构造舵机指令
(0942) 							 motor_command[2]=0x01;//ID=1
    006B7 E081      LDI	R24,1
    006B8 8F8B      STD	Y+27,R24
(0943) 						 	 motor_command[6]=com_finger1_ratio_3_PARA2;
    006B9 A428      LDD	R2,Y+40
    006BA 8E2F      STD	Y+31,R2
(0944) 						 	 motor_command[7]=com_finger1_ratio_3_PARA3+0x04;
    006BB A589      LDD	R24,Y+41
    006BC 5F8C      SUBI	R24,0xFC
    006BD A388      STD	Y+32,R24
(0945) 						 	 CHECK=ratio_command_check(1,com_finger1_ratio_3_PARA2,com_finger1_ratio_3_PARA3+0x04);
    006BE A589      LDD	R24,Y+41
    006BF 5F8C      SUBI	R24,0xFC
    006C0 8388      ST	Y,R24
    006C1 A528      LDD	R18,Y+40
    006C2 E001      LDI	R16,1
    006C3 DC98      RCALL	_ratio_command_check
    006C4 2EC0      MOV	R12,R16
    006C5 2CAC      MOV	R10,R12
(0946) 						 	 motor_command[8]=CHECK;
    006C6 A2A9      STD	Y+33,R10
(0947) 						 	 delay(50);
    006C7 E302      LDI	R16,0x32
    006C8 E010      LDI	R17,0
    006C9 DA19      RCALL	_delay
(0948) 						 	 uart1_send_string(motor_command,9);//下发指令
    006CA E029      LDI	R18,0x9
    006CB 018E      MOVW	R16,R28
    006CC 5E07      SUBI	R16,0xE7
    006CD 4F1F      SBCI	R17,0xFF
    006CE DB48      RCALL	_uart1_send_string
(0949) 						 }
(0950) 				 	 }
(0951) 				 
(0952) 				 	 if(array_cmp(uart0_instr,"1200")==0)//夹紧
    006CF EC27      LDI	R18,0xC7
    006D0 E031      LDI	R19,1
    006D1 EF0D      LDI	R16,0xFD
    006D2 E011      LDI	R17,1
    006D3 DB6E      RCALL	_array_cmp
    006D4 0168      MOVW	R12,R16
    006D5 3000      CPI	R16,0
    006D6 0701      CPC	R16,R17
    006D7 F009      BEQ	0x06D9
    006D8 C0C0      RJMP	0x0799
(0953) 				 	 {
(0954) 				         if(hold_allow_motor_0 & hold_allow_motor_1)
    006D9 A829      LDD	R2,Y+49
    006DA A80A      LDD	R0,Y+50
    006DB 2020      AND	R2,R0
    006DC F409      BNE	0x06DE
    006DD C0BB      RJMP	0x0799
(0955) 						 {
(0956) 						     //第一阶段
(0957) 							 //构造舵机指令
(0958) 							 motor_command[2]=0x00;//ID=0
    006DE 2422      CLR	R2
    006DF 8E2B      STD	Y+27,R2
(0959) 						 	 motor_command[6]=com_finger0_ratio_1_PARA2;
    006E0 A02A      LDD	R2,Y+34
    006E1 8E2F      STD	Y+31,R2
(0960) 						 	 motor_command[7]=com_finger0_ratio_1_PARA3;
    006E2 A02B      LDD	R2,Y+35
    006E3 A228      STD	Y+32,R2
(0961) 						 	 CHECK=ratio_command_check(0,com_finger0_ratio_1_PARA2,com_finger0_ratio_1_PARA3);
    006E4 A02B      LDD	R2,Y+35
    006E5 8228      ST	Y,R2
    006E6 A12A      LDD	R18,Y+34
    006E7 2700      CLR	R16
    006E8 DC73      RCALL	_ratio_command_check
    006E9 2EC0      MOV	R12,R16
    006EA 2CAC      MOV	R10,R12
(0962) 						 	 motor_command[8]=CHECK;
    006EB A2A9      STD	Y+33,R10
(0963) 						 	 delay(50);
    006EC E302      LDI	R16,0x32
    006ED E010      LDI	R17,0
    006EE D9F4      RCALL	_delay
(0964) 						 	 uart1_send_string(motor_command,9);//下发指令
    006EF E029      LDI	R18,0x9
    006F0 018E      MOVW	R16,R28
    006F1 5E07      SUBI	R16,0xE7
    006F2 4F1F      SBCI	R17,0xFF
    006F3 DB23      RCALL	_uart1_send_string
(0965) 							 
(0966) 							 //构造舵机指令
(0967) 							 motor_command[2]=0x01;//ID=1
    006F4 E081      LDI	R24,1
    006F5 8F8B      STD	Y+27,R24
(0968) 						 	 motor_command[6]=com_finger1_ratio_1_PARA2;
    006F6 A02E      LDD	R2,Y+38
    006F7 8E2F      STD	Y+31,R2
(0969) 						 	 motor_command[7]=com_finger1_ratio_1_PARA3;
    006F8 A02F      LDD	R2,Y+39
    006F9 A228      STD	Y+32,R2
(0970) 						 	 CHECK=ratio_command_check(1,com_finger1_ratio_1_PARA2,com_finger1_ratio_1_PARA3);
    006FA A02F      LDD	R2,Y+39
    006FB 8228      ST	Y,R2
    006FC A12E      LDD	R18,Y+38
    006FD E001      LDI	R16,1
    006FE DC5D      RCALL	_ratio_command_check
    006FF 2EC0      MOV	R12,R16
    00700 2CAC      MOV	R10,R12
(0971) 						 	 motor_command[8]=CHECK;
    00701 A2A9      STD	Y+33,R10
(0972) 						 	 delay(50);
    00702 E302      LDI	R16,0x32
    00703 E010      LDI	R17,0
    00704 D9DE      RCALL	_delay
(0973) 						 	 uart1_send_string(motor_command,9);//下发指令
    00705 E029      LDI	R18,0x9
    00706 018E      MOVW	R16,R28
    00707 5E07      SUBI	R16,0xE7
    00708 4F1F      SBCI	R17,0xFF
    00709 DB0D      RCALL	_uart1_send_string
(0974) 	
(0975) 							 approach_0=1;
    0070A 24CC      CLR	R12
    0070B 94C3      INC	R12
(0976) 							 approach_1=1;
    0070C 24EE      CLR	R14
    0070D 94E3      INC	R14
    0070E C01C      RJMP	0x072B
(0977) 							 
(0978) 							 //等接近开关触发，同时查询检测是否空夹
(0979) 							 while((approach_0|approach_1)&&(PINE & BIT(7)))
(0980) 							 {
(0981) 	   						     if(approach_0)
    0070F 20CC      TST	R12
    00710 F061      BEQ	0x071D
(0982) 								 {
(0983) 								     if(!(PINE & BIT(2)))//PE2=0进入
    00711 990A      SBIC	0x01,2
    00712 C00A      RJMP	0x071D
(0984) 									 {
(0985) 		        					     delay(50);
    00713 E302      LDI	R16,0x32
    00714 E010      LDI	R17,0
    00715 D9CD      RCALL	_delay
(0986) 										 if(!(PINE & BIT(2)))
    00716 990A      SBIC	0x01,2
    00717 C005      RJMP	0x071D
(0987) 										 {
(0988) 			        					     uart1_send_string((uchar*)no0stop,9);
    00718 E029      LDI	R18,0x9
    00719 E00C      LDI	R16,0xC
    0071A E011      LDI	R17,1
    0071B DAFB      RCALL	_uart1_send_string
(0989) 											 //uart0_send_string(" interrupt 5 ");
(0990) 											 approach_0=0;
    0071C 24CC      CLR	R12
(0991) 			    						 }
(0992) 			
(0993) 		    						 }
(0994) 							 	 }
(0995) 		
(0996) 	    					 	 if(approach_1)
    0071D 20EE      TST	R14
    0071E F061      BEQ	0x072B
(0997) 								 {
(0998)     	    					     if(!(PINE & BIT(3)))//PE3=0进入
    0071F 990B      SBIC	0x01,3
    00720 C00A      RJMP	0x072B
(0999) 	    						 	 {
(1000) 		       					          delay(50);
    00721 E302      LDI	R16,0x32
    00722 E010      LDI	R17,0
    00723 D9BF      RCALL	_delay
(1001) 								  	  	  if(!(PINE & BIT(3)))
    00724 990B      SBIC	0x01,3
    00725 C005      RJMP	0x072B
(1002) 								  	  	  {
(1003) 			        			  	          uart1_send_string((uchar*)no1stop,9);
    00726 E029      LDI	R18,0x9
    00727 E10E      LDI	R16,0x1E
    00728 E011      LDI	R17,1
    00729 DAED      RCALL	_uart1_send_string
(1004) 								  		  	  //uart0_send_string(" interrupt 6 ");
(1005) 								  		  	  approach_1=0;
    0072A 24EE      CLR	R14
    0072B 2C2C      MOV	R2,R12
    0072C 282E      OR	R2,R14
    0072D F011      BEQ	0x0730
    0072E 990F      SBIC	0x01,7
    0072F CFDF      RJMP	0x070F
(1006) 			    				          }
(1007) 		    					     }
(1008) 								 }
(1009) 							 }
(1010) 							 
(1011) 							 if(PINE & BIT(7))//不空夹则进行第二阶段
    00730 9B0F      SBIS	0x01,7
    00731 C067      RJMP	0x0799
(1012) 							 {
(1013) 							    //第二阶段
(1014) 							 	//构造舵机指令
(1015) 							 	motor_command[2]=0x00;//ID=0
    00732 2422      CLR	R2
    00733 8E2B      STD	Y+27,R2
(1016) 						 	 	motor_command[6]=com_finger0_ratio_2_PARA2;
    00734 A42A      LDD	R2,Y+42
    00735 8E2F      STD	Y+31,R2
(1017) 						 	 	motor_command[7]=com_finger0_ratio_2_PARA3;
    00736 A42B      LDD	R2,Y+43
    00737 A228      STD	Y+32,R2
(1018) 						 	 	CHECK=ratio_command_check(0,com_finger0_ratio_2_PARA2,com_finger0_ratio_2_PARA3);
    00738 A42B      LDD	R2,Y+43
    00739 8228      ST	Y,R2
    0073A A52A      LDD	R18,Y+42
    0073B 2700      CLR	R16
    0073C DC1F      RCALL	_ratio_command_check
    0073D 2EC0      MOV	R12,R16
    0073E 2CAC      MOV	R10,R12
(1019) 						 	 	motor_command[8]=CHECK;
    0073F A2A9      STD	Y+33,R10
(1020) 						 	 	delay(50);
    00740 E302      LDI	R16,0x32
    00741 E010      LDI	R17,0
    00742 D9A0      RCALL	_delay
(1021) 						 	 	uart1_send_string(motor_command,9);//下发指令
    00743 E029      LDI	R18,0x9
    00744 018E      MOVW	R16,R28
    00745 5E07      SUBI	R16,0xE7
    00746 4F1F      SBCI	R17,0xFF
    00747 DACF      RCALL	_uart1_send_string
(1022) 							 
(1023) 							 	//构造舵机指令
(1024) 								 motor_command[2]=0x01;//ID=1
    00748 E081      LDI	R24,1
    00749 8F8B      STD	Y+27,R24
(1025) 						 	 	 motor_command[6]=com_finger1_ratio_2_PARA2;
    0074A A42C      LDD	R2,Y+44
    0074B 8E2F      STD	Y+31,R2
(1026) 						 		 motor_command[7]=com_finger1_ratio_2_PARA3;
    0074C A42D      LDD	R2,Y+45
    0074D A228      STD	Y+32,R2
(1027) 						 	 	 CHECK=ratio_command_check(1,com_finger1_ratio_2_PARA2,com_finger1_ratio_2_PARA3);
    0074E A42D      LDD	R2,Y+45
    0074F 8228      ST	Y,R2
    00750 A52C      LDD	R18,Y+44
    00751 E001      LDI	R16,1
    00752 DC09      RCALL	_ratio_command_check
    00753 2EC0      MOV	R12,R16
    00754 2CAC      MOV	R10,R12
(1028) 						 		 motor_command[8]=CHECK;
    00755 A2A9      STD	Y+33,R10
(1029) 						 	 	 delay(50);
    00756 E302      LDI	R16,0x32
    00757 E010      LDI	R17,0
    00758 D98A      RCALL	_delay
(1030) 						 	 	 uart1_send_string(motor_command,9);//下发指令
    00759 E029      LDI	R18,0x9
    0075A 018E      MOVW	R16,R28
    0075B 5E07      SUBI	R16,0xE7
    0075C 4F1F      SBCI	R17,0xFF
    0075D DAB9      RCALL	_uart1_send_string
(1031) 							 
(1032) 							 	 //等待夹紧力达到阈值并继续判断是否空夹
(1033) 							 	 force_high8=0;
    0075E 2422      CLR	R2
    0075F 9220 01FC STS	force_high8,R2
(1034) 								 hold_stage_2_continue=1;
    00761 2400      CLR	R0
    00762 9403      INC	R0
    00763 AA0D      STD	Y+53,R0
    00764 C02F      RJMP	0x0794
(1035) 							 	 while(hold_stage_2_continue && (PINE & BIT(7)))
(1036) 							 	 {
(1037) 								     force_ulong=ReadCount();
    00765 DB40      RCALL	_ReadCount
    00766 9310 01F8 STS	force_ulong+1,R17
    00768 9300 01F7 STS	force_ulong,R16
    0076A 9330 01FA STS	force_ulong+3,R19
    0076C 9320 01F9 STS	force_ulong+2,R18
(1038) 								 	 ulong_to_uchar_array(force_ulong);//目的是获取force_high8
    0076E DB0F      RCALL	_ulong_to_uchar_array
(1039) 									 if(force_high8>=force_judge)
    0076F 9020 01FB LDS	R2,force_judge
    00771 9030 01FC LDS	R3,force_high8
    00773 1432      CP	R3,R2
    00774 F0F8      BCS	0x0794
(1040) 									 {
(1041) 									     hold_stage_2_continue=0;//下次循环跳出
    00775 2400      CLR	R0
    00776 AA0D      STD	Y+53,R0
(1042) 										 
(1043) 										 //停止舵机运行
(1044) 							 	 		 delay(50);
    00777 E302      LDI	R16,0x32
    00778 E010      LDI	R17,0
    00779 D969      RCALL	_delay
(1045) 							 	 		 uart1_send_string((uchar*)no0stop,9);
    0077A E029      LDI	R18,0x9
    0077B E00C      LDI	R16,0xC
    0077C E011      LDI	R17,1
    0077D DA99      RCALL	_uart1_send_string
(1046) 							 	 		 delay(50);
    0077E E302      LDI	R16,0x32
    0077F E010      LDI	R17,0
    00780 D962      RCALL	_delay
(1047) 							 	 		 uart1_send_string((uchar*)no1stop,9);
    00781 E029      LDI	R18,0x9
    00782 E10E      LDI	R16,0x1E
    00783 E011      LDI	R17,1
    00784 DA92      RCALL	_uart1_send_string
(1048) 							 
(1049) 							 	 		 hold_allow_motor_0=0;//禁止0号手指向端部靠近
    00785 2400      CLR	R0
    00786 AA09      STD	Y+49,R0
(1050) 							 	 		 hold_allow_motor_1=0;//禁止1号手指向端部靠近
    00787 AA0A      STD	Y+50,R0
(1051) 							 
(1052) 							 	 		 //报告上位机已经夹紧
(1053) 							 	 		 delay(50);
    00788 E302      LDI	R16,0x32
    00789 E010      LDI	R17,0
    0078A D958      RCALL	_delay
(1054) 							 	 		 uart0_send_string("zz10");
    0078B EC02      LDI	R16,0xC2
    0078C E011      LDI	R17,1
    0078D DA1B      RCALL	_uart0_send_string
(1055) 										 delay(50);
    0078E E302      LDI	R16,0x32
    0078F E010      LDI	R17,0
    00790 D952      RCALL	_delay
(1056) 							 	 		 uart0_send_string("zz10");
    00791 EC02      LDI	R16,0xC2
    00792 E011      LDI	R17,1
    00793 DA15      RCALL	_uart0_send_string
    00794 A80D      LDD	R0,Y+53
    00795 2000      TST	R0
    00796 F011      BEQ	0x0799
    00797 990F      SBIC	0x01,7
    00798 CFCC      RJMP	0x0765
(1057) 									 }
(1058) 							 	 }
(1059) 							 
(1060) 							 	 
(1061) 							 }
(1062) 							 
(1063) 						 }
(1064) 				 	 }
(1065) 					 
(1066) 					 if(array_cmp(Type(uart0_instr),"13")==0)//设定手指0，Ratio 1
    00799 EF0D      LDI	R16,0xFD
    0079A E011      LDI	R17,1
    0079B DAD1      RCALL	_Type
    0079C EB2F      LDI	R18,0xBF
    0079D E031      LDI	R19,1
    0079E DAA3      RCALL	_array_cmp
    0079F 0168      MOVW	R12,R16
    007A0 3000      CPI	R16,0
    007A1 0701      CPC	R16,R17
    007A2 F449      BNE	0x07AC
(1067) 				 	 {
(1068) 					     com_finger0_ratio_1_PARA2=uart0_instr[2];
    007A3 9020 01FF LDS	R2,uart0_instr+2
    007A5 A22A      STD	Y+34,R2
(1069) 						 com_finger0_ratio_1_PARA3=uart0_instr[3];
    007A6 9020 0200 LDS	R2,uart0_instr+3
    007A8 A22B      STD	Y+35,R2
(1070) 						 command_data_save_finger_0_ratio_1(com_finger0_ratio_1_PARA2,com_finger0_ratio_1_PARA3);
    007A9 2D22      MOV	R18,R2
    007AA A10A      LDD	R16,Y+34
    007AB DBBB      RCALL	_command_data_save_finger_0_ratio_1
(1071) 					 }
(1072) 					 
(1073) 					 if(array_cmp(Type(uart0_instr),"14")==0)//设定手指0，Ratio 2
    007AC EF0D      LDI	R16,0xFD
    007AD E011      LDI	R17,1
    007AE DABE      RCALL	_Type
    007AF EB2C      LDI	R18,0xBC
    007B0 E031      LDI	R19,1
    007B1 DA90      RCALL	_array_cmp
    007B2 0168      MOVW	R12,R16
    007B3 3000      CPI	R16,0
    007B4 0701      CPC	R16,R17
    007B5 F449      BNE	0x07BF
(1074) 				 	 {
(1075) 					     com_finger0_ratio_2_PARA2=uart0_instr[2];
    007B6 9020 01FF LDS	R2,uart0_instr+2
    007B8 A62A      STD	Y+42,R2
(1076) 						 com_finger0_ratio_2_PARA3=uart0_instr[3];
    007B9 9020 0200 LDS	R2,uart0_instr+3
    007BB A62B      STD	Y+43,R2
(1077) 						 command_data_save_finger_0_ratio_2(com_finger0_ratio_2_PARA2,com_finger0_ratio_2_PARA3);
    007BC 2D22      MOV	R18,R2
    007BD A50A      LDD	R16,Y+42
    007BE DBBF      RCALL	_command_data_save_finger_0_ratio_2
(1078) 					 }
(1079) 					 
(1080) 					 if(array_cmp(Type(uart0_instr),"15")==0)//设定手指0，Ratio 3
    007BF EF0D      LDI	R16,0xFD
    007C0 E011      LDI	R17,1
    007C1 DAAB      RCALL	_Type
    007C2 EB29      LDI	R18,0xB9
    007C3 E031      LDI	R19,1
    007C4 DA7D      RCALL	_array_cmp
    007C5 0168      MOVW	R12,R16
    007C6 3000      CPI	R16,0
    007C7 0701      CPC	R16,R17
    007C8 F449      BNE	0x07D2
(1081) 				 	 {
(1082) 					     com_finger0_ratio_3_PARA2=uart0_instr[2];
    007C9 9020 01FF LDS	R2,uart0_instr+2
    007CB A22C      STD	Y+36,R2
(1083) 						 com_finger0_ratio_3_PARA3=uart0_instr[3];
    007CC 9020 0200 LDS	R2,uart0_instr+3
    007CE A22D      STD	Y+37,R2
(1084) 						 command_data_save_finger_0_ratio_3(com_finger0_ratio_3_PARA2,com_finger0_ratio_3_PARA3);
    007CF 2D22      MOV	R18,R2
    007D0 A10C      LDD	R16,Y+36
    007D1 DBC3      RCALL	_command_data_save_finger_0_ratio_3
(1085) 					 }
(1086) 					 
(1087) 					 if(array_cmp(Type(uart0_instr),"16")==0)//设定手指1，Ratio 1
    007D2 EF0D      LDI	R16,0xFD
    007D3 E011      LDI	R17,1
    007D4 DA98      RCALL	_Type
    007D5 EB26      LDI	R18,0xB6
    007D6 E031      LDI	R19,1
    007D7 DA6A      RCALL	_array_cmp
    007D8 0168      MOVW	R12,R16
    007D9 3000      CPI	R16,0
    007DA 0701      CPC	R16,R17
    007DB F449      BNE	0x07E5
(1088) 				 	 {
(1089) 					     com_finger1_ratio_1_PARA2=uart0_instr[2];
    007DC 9020 01FF LDS	R2,uart0_instr+2
    007DE A22E      STD	Y+38,R2
(1090) 						 com_finger1_ratio_1_PARA3=uart0_instr[3];
    007DF 9020 0200 LDS	R2,uart0_instr+3
    007E1 A22F      STD	Y+39,R2
(1091) 						 command_data_save_finger_1_ratio_1(com_finger1_ratio_1_PARA2,com_finger1_ratio_1_PARA3);
    007E2 2D22      MOV	R18,R2
    007E3 A10E      LDD	R16,Y+38
    007E4 DC0C      RCALL	_command_data_save_finger_1_ratio_1
(1092) 					 }
(1093) 					 
(1094) 					 if(array_cmp(Type(uart0_instr),"17")==0)//设定手指1，Ratio 2
    007E5 EF0D      LDI	R16,0xFD
    007E6 E011      LDI	R17,1
    007E7 DA85      RCALL	_Type
    007E8 EB23      LDI	R18,0xB3
    007E9 E031      LDI	R19,1
    007EA DA57      RCALL	_array_cmp
    007EB 0168      MOVW	R12,R16
    007EC 3000      CPI	R16,0
    007ED 0701      CPC	R16,R17
    007EE F449      BNE	0x07F8
(1095) 				 	 {
(1096) 					     com_finger1_ratio_2_PARA2=uart0_instr[2];
    007EF 9020 01FF LDS	R2,uart0_instr+2
    007F1 A62C      STD	Y+44,R2
(1097) 						 com_finger1_ratio_2_PARA3=uart0_instr[3];
    007F2 9020 0200 LDS	R2,uart0_instr+3
    007F4 A62D      STD	Y+45,R2
(1098) 						 command_data_save_finger_1_ratio_2(com_finger1_ratio_2_PARA2,com_finger1_ratio_2_PARA3);
    007F5 2D22      MOV	R18,R2
    007F6 A50C      LDD	R16,Y+44
    007F7 DC10      RCALL	_command_data_save_finger_1_ratio_2
(1099) 					 }
(1100) 					 
(1101) 					 if(array_cmp(Type(uart0_instr),"18")==0)//设定手指1，Ratio 3
    007F8 EF0D      LDI	R16,0xFD
    007F9 E011      LDI	R17,1
    007FA DA72      RCALL	_Type
    007FB EB20      LDI	R18,0xB0
    007FC E031      LDI	R19,1
    007FD DA44      RCALL	_array_cmp
    007FE 0168      MOVW	R12,R16
    007FF 3000      CPI	R16,0
    00800 0701      CPC	R16,R17
    00801 F449      BNE	0x080B
(1102) 				 	 {
(1103) 					     com_finger1_ratio_3_PARA2=uart0_instr[2];
    00802 9020 01FF LDS	R2,uart0_instr+2
    00804 A628      STD	Y+40,R2
(1104) 						 com_finger1_ratio_3_PARA3=uart0_instr[3];
    00805 9020 0200 LDS	R2,uart0_instr+3
    00807 A629      STD	Y+41,R2
(1105) 						 command_data_save_finger_1_ratio_3(com_finger1_ratio_3_PARA2,com_finger1_ratio_3_PARA3);
    00808 2D22      MOV	R18,R2
    00809 A508      LDD	R16,Y+40
    0080A DC14      RCALL	_command_data_save_finger_1_ratio_3
(1106) 					 }
(1107) 					 
(1108) 					 if(array_cmp(Type(uart0_instr),"19")==0)//设定force_judge
    0080B EF0D      LDI	R16,0xFD
    0080C E011      LDI	R17,1
    0080D DA5F      RCALL	_Type
    0080E EA2D      LDI	R18,0xAD
    0080F E031      LDI	R19,1
    00810 DA31      RCALL	_array_cmp
    00811 0168      MOVW	R12,R16
    00812 3000      CPI	R16,0
    00813 0701      CPC	R16,R17
    00814 F009      BEQ	0x0816
    00815 C19F      RJMP	0x09B5
(1109) 				 	 {
(1110) 					     force_judge=uart0_instr[2];
    00816 9020 01FF LDS	R2,uart0_instr+2
    00818 9220 01FB STS	force_judge,R2
(1111) 						 command_data_save_force_high8(force_judge);
    0081A 2D02      MOV	R16,R2
    0081B 2711      CLR	R17
    0081C DACF      RCALL	_command_data_save_force_high8
(1112) 					 }
(1113) 				 
(1114) 				 	 break;
    0081D C197      RJMP	0x09B5
(1115) 			     }
(1116) 			 
(1117) 		         case 2:
(1118) 			     {
(1119) 					 if(array_cmp(uart0_instr,"2100")==0)//调试模式・手指0停止
    0081E EA28      LDI	R18,0xA8
    0081F E031      LDI	R19,1
    00820 EF0D      LDI	R16,0xFD
    00821 E011      LDI	R17,1
    00822 DA1F      RCALL	_array_cmp
    00823 0168      MOVW	R12,R16
    00824 3000      CPI	R16,0
    00825 0701      CPC	R16,R17
    00826 F439      BNE	0x082E
(1120) 				 	 {
(1121) 					     TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00827 B787      IN	R24,0x37
    00828 7F8B      ANDI	R24,0xFB
    00829 BF87      OUT	0x37,R24
(1122) 						 uart1_send_string((uchar*)no0stop,9);
    0082A E029      LDI	R18,0x9
    0082B E00C      LDI	R16,0xC
    0082C E011      LDI	R17,1
    0082D D9E9      RCALL	_uart1_send_string
(1123) 				 	 }
(1124) 
(1125) 					 if(array_cmp(uart0_instr,"2101")==0)//调试模式・手指0松开方向移动
    0082E EA23      LDI	R18,0xA3
    0082F E031      LDI	R19,1
    00830 EF0D      LDI	R16,0xFD
    00831 E011      LDI	R17,1
    00832 DA0F      RCALL	_array_cmp
    00833 0168      MOVW	R12,R16
    00834 3000      CPI	R16,0
    00835 0701      CPC	R16,R17
    00836 F501      BNE	0x0857
(1126) 				 	 {
(1127) 					     if(release_allow_motor_0)
    00837 A80B      LDD	R0,Y+51
    00838 2000      TST	R0
    00839 F0E9      BEQ	0x0857
(1128) 						 {
(1129) 						     TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    0083A B787      IN	R24,0x37
    0083B 7F8B      ANDI	R24,0xFB
    0083C BF87      OUT	0x37,R24
(1130) 						 	 motor_command[2]=0x00;//ID=0
    0083D 2422      CLR	R2
    0083E 8E2B      STD	Y+27,R2
(1131) 						 	 motor_command[6]=PARA2;
    0083F 8F4F      STD	Y+31,R20
(1132) 						 	 motor_command[7]=PARA3+0x04;//顺时针，绝对不可在此更改PARA3的值！
    00840 2F86      MOV	R24,R22
    00841 5F8C      SUBI	R24,0xFC
    00842 A388      STD	Y+32,R24
(1133) 						 	 CHECK=ratio_command_check(0,PARA2,PARA3+0x04);
    00843 2F86      MOV	R24,R22
    00844 5F8C      SUBI	R24,0xFC
    00845 8388      ST	Y,R24
    00846 2F24      MOV	R18,R20
    00847 2700      CLR	R16
    00848 DB13      RCALL	_ratio_command_check
    00849 2EC0      MOV	R12,R16
    0084A 2CAC      MOV	R10,R12
(1134) 						 	 motor_command[8]=CHECK;
    0084B A2A9      STD	Y+33,R10
(1135) 						 	 delay(50);
    0084C E302      LDI	R16,0x32
    0084D E010      LDI	R17,0
    0084E D894      RCALL	_delay
(1136) 						 	 uart1_send_string(motor_command,9);
    0084F E029      LDI	R18,0x9
    00850 018E      MOVW	R16,R28
    00851 5E07      SUBI	R16,0xE7
    00852 4F1F      SBCI	R17,0xFF
    00853 D9C3      RCALL	_uart1_send_string
(1137) 						 	 //delay(50);
(1138) 						 	 //uart0_send_string_with_num(motor_command,9);
(1139) 						 	 TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
    00854 B787      IN	R24,0x37
    00855 6084      ORI	R24,4
    00856 BF87      OUT	0x37,R24
(1140) 						 }
(1141) 				 	 }
(1142) 					 
(1143) 					 if(array_cmp(uart0_instr,"2102")==0)//调试模式・手指0夹紧方向移动
    00857 E92E      LDI	R18,0x9E
    00858 E031      LDI	R19,1
    00859 EF0D      LDI	R16,0xFD
    0085A E011      LDI	R17,1
    0085B D9E6      RCALL	_array_cmp
    0085C 0168      MOVW	R12,R16
    0085D 3000      CPI	R16,0
    0085E 0701      CPC	R16,R17
    0085F F4E1      BNE	0x087C
(1144) 				 	 {
(1145) 					     if(hold_allow_motor_0)
    00860 A809      LDD	R0,Y+49
    00861 2000      TST	R0
    00862 F0C9      BEQ	0x087C
(1146) 						 {
(1147) 						     TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00863 B787      IN	R24,0x37
    00864 7F8B      ANDI	R24,0xFB
    00865 BF87      OUT	0x37,R24
(1148) 						 	 motor_command[2]=0x00;//ID=0
    00866 2422      CLR	R2
    00867 8E2B      STD	Y+27,R2
(1149) 						 	 motor_command[6]=PARA2;
    00868 8F4F      STD	Y+31,R20
(1150) 						 	 motor_command[7]=PARA3;
    00869 A368      STD	Y+32,R22
(1151) 						 	 CHECK=ratio_command_check(0,PARA2,PARA3);
    0086A 8368      ST	Y,R22
    0086B 2F24      MOV	R18,R20
    0086C 2700      CLR	R16
    0086D DAEE      RCALL	_ratio_command_check
    0086E 2EC0      MOV	R12,R16
    0086F 2CAC      MOV	R10,R12
(1152) 						 	 motor_command[8]=CHECK;
    00870 A2A9      STD	Y+33,R10
(1153) 						 	 delay(50);
    00871 E302      LDI	R16,0x32
    00872 E010      LDI	R17,0
    00873 D86F      RCALL	_delay
(1154) 						 	 uart1_send_string(motor_command,9);
    00874 E029      LDI	R18,0x9
    00875 018E      MOVW	R16,R28
    00876 5E07      SUBI	R16,0xE7
    00877 4F1F      SBCI	R17,0xFF
    00878 D99E      RCALL	_uart1_send_string
(1155) 						 	 //delay(50);
(1156) 						 	 //uart0_send_string_with_num(motor_command,9);
(1157) 						 	 TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
    00879 B787      IN	R24,0x37
    0087A 6084      ORI	R24,4
    0087B BF87      OUT	0x37,R24
(1158) 						 }
(1159) 				 	 }
(1160) 
(1161) 					 if(array_cmp(uart0_instr,"2110")==0)//调试模式・手指1停止
    0087C E929      LDI	R18,0x99
    0087D E031      LDI	R19,1
    0087E EF0D      LDI	R16,0xFD
    0087F E011      LDI	R17,1
    00880 D9C1      RCALL	_array_cmp
    00881 0168      MOVW	R12,R16
    00882 3000      CPI	R16,0
    00883 0701      CPC	R16,R17
    00884 F439      BNE	0x088C
(1162) 				 	 {
(1163) 					     TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00885 B787      IN	R24,0x37
    00886 7F8B      ANDI	R24,0xFB
    00887 BF87      OUT	0x37,R24
(1164) 						 uart1_send_string((uchar*)no1stop,9);
    00888 E029      LDI	R18,0x9
    00889 E10E      LDI	R16,0x1E
    0088A E011      LDI	R17,1
    0088B D98B      RCALL	_uart1_send_string
(1165) 				 	 }
(1166) 
(1167) 					 if(array_cmp(uart0_instr,"2111")==0)//调试模式・手指1松开方向移动
    0088C E924      LDI	R18,0x94
    0088D E031      LDI	R19,1
    0088E EF0D      LDI	R16,0xFD
    0088F E011      LDI	R17,1
    00890 D9B1      RCALL	_array_cmp
    00891 0168      MOVW	R12,R16
    00892 3000      CPI	R16,0
    00893 0701      CPC	R16,R17
    00894 F501      BNE	0x08B5
(1168) 				 	 {
(1169) 					     if(release_allow_motor_1)
    00895 A80C      LDD	R0,Y+52
    00896 2000      TST	R0
    00897 F0E9      BEQ	0x08B5
(1170) 						 {
(1171) 						     TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00898 B787      IN	R24,0x37
    00899 7F8B      ANDI	R24,0xFB
    0089A BF87      OUT	0x37,R24
(1172) 						 	 motor_command[2]=0x01;//ID=1
    0089B E081      LDI	R24,1
    0089C 8F8B      STD	Y+27,R24
(1173) 						 	 motor_command[6]=PARA2;
    0089D 8F4F      STD	Y+31,R20
(1174) 						 	 motor_command[7]=PARA3+0x04;//顺时针，绝对不可在此更改PARA3的值！
    0089E 2F86      MOV	R24,R22
    0089F 5F8C      SUBI	R24,0xFC
    008A0 A388      STD	Y+32,R24
(1175) 						 	 CHECK=ratio_command_check(1,PARA2,PARA3+0x04);
    008A1 2F86      MOV	R24,R22
    008A2 5F8C      SUBI	R24,0xFC
    008A3 8388      ST	Y,R24
    008A4 2F24      MOV	R18,R20
    008A5 E001      LDI	R16,1
    008A6 DAB5      RCALL	_ratio_command_check
    008A7 2EC0      MOV	R12,R16
    008A8 2CAC      MOV	R10,R12
(1176) 						 	 motor_command[8]=CHECK;
    008A9 A2A9      STD	Y+33,R10
(1177) 						 	 delay(50);
    008AA E302      LDI	R16,0x32
    008AB E010      LDI	R17,0
    008AC D836      RCALL	_delay
(1178) 						 	 uart1_send_string(motor_command,9);
    008AD E029      LDI	R18,0x9
    008AE 018E      MOVW	R16,R28
    008AF 5E07      SUBI	R16,0xE7
    008B0 4F1F      SBCI	R17,0xFF
    008B1 D965      RCALL	_uart1_send_string
(1179) 						 	 //delay(50);
(1180) 						 	 //uart0_send_string_with_num(motor_command,9);
(1181) 						 	 TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
    008B2 B787      IN	R24,0x37
    008B3 6084      ORI	R24,4
    008B4 BF87      OUT	0x37,R24
(1182) 						 }
(1183) 				 	 }
(1184) 					 
(1185) 					 if(array_cmp(uart0_instr,"2112")==0)//调试模式・手指1夹紧方向移动
    008B5 E82F      LDI	R18,0x8F
    008B6 E031      LDI	R19,1
    008B7 EF0D      LDI	R16,0xFD
    008B8 E011      LDI	R17,1
    008B9 D988      RCALL	_array_cmp
    008BA 0168      MOVW	R12,R16
    008BB 3000      CPI	R16,0
    008BC 0701      CPC	R16,R17
    008BD F4E1      BNE	0x08DA
(1186) 				 	 {
(1187) 					     if(hold_allow_motor_1)
    008BE A80A      LDD	R0,Y+50
    008BF 2000      TST	R0
    008C0 F0C9      BEQ	0x08DA
(1188) 						 {
(1189) 						     TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    008C1 B787      IN	R24,0x37
    008C2 7F8B      ANDI	R24,0xFB
    008C3 BF87      OUT	0x37,R24
(1190) 						 	 motor_command[2]=0x01;//ID=1
    008C4 E081      LDI	R24,1
    008C5 8F8B      STD	Y+27,R24
(1191) 						 	 motor_command[6]=PARA2;
    008C6 8F4F      STD	Y+31,R20
(1192) 						 	 motor_command[7]=PARA3;
    008C7 A368      STD	Y+32,R22
(1193) 						 	 CHECK=ratio_command_check(1,PARA2,PARA3);
    008C8 8368      ST	Y,R22
    008C9 2F24      MOV	R18,R20
    008CA E001      LDI	R16,1
    008CB DA90      RCALL	_ratio_command_check
    008CC 2EC0      MOV	R12,R16
    008CD 2CAC      MOV	R10,R12
(1194) 						 	 motor_command[8]=CHECK;
    008CE A2A9      STD	Y+33,R10
(1195) 						 	 delay(50);
    008CF E302      LDI	R16,0x32
    008D0 E010      LDI	R17,0
    008D1 D811      RCALL	_delay
(1196) 						 	 uart1_send_string(motor_command,9);
    008D2 E029      LDI	R18,0x9
    008D3 018E      MOVW	R16,R28
    008D4 5E07      SUBI	R16,0xE7
    008D5 4F1F      SBCI	R17,0xFF
    008D6 D940      RCALL	_uart1_send_string
(1197) 						 	 //delay(50);
(1198) 						 	 //uart0_send_string_with_num(motor_command,9);
(1199) 						 	 TIMSK|=BIT(2);//打开定时计数1中断，向上返回夹持力值
    008D7 B787      IN	R24,0x37
    008D8 6084      ORI	R24,4
    008D9 BF87      OUT	0x37,R24
(1200) 						 }
(1201) 				 	 }
(1202) 
(1203) 					 if(array_cmp(Type(uart0_instr),"22")==0)
    008DA EF0D      LDI	R16,0xFD
    008DB E011      LDI	R17,1
    008DC D990      RCALL	_Type
    008DD E82C      LDI	R18,0x8C
    008DE E031      LDI	R19,1
    008DF D962      RCALL	_array_cmp
    008E0 0158      MOVW	R10,R16
    008E1 3000      CPI	R16,0
    008E2 0701      CPC	R16,R17
    008E3 F4B9      BNE	0x08FB
(1204) 				 	 {
(1205) 						 TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    008E4 B787      IN	R24,0x37
    008E5 7F8B      ANDI	R24,0xFB
    008E6 BF87      OUT	0x37,R24
(1206) 						 delay(50);
    008E7 E302      LDI	R16,0x32
    008E8 E010      LDI	R17,0
    008E9 940E 00E3 CALL	_delay
(1207) 						 uart1_send_string((uchar*)no0stop,9);
    008EB E029      LDI	R18,0x9
    008EC E00C      LDI	R16,0xC
    008ED E011      LDI	R17,1
    008EE D928      RCALL	_uart1_send_string
(1208) 						 delay(50);
    008EF E302      LDI	R16,0x32
    008F0 E010      LDI	R17,0
    008F1 940E 00E3 CALL	_delay
(1209) 						 uart1_send_string((uchar*)no1stop,9);
    008F3 E029      LDI	R18,0x9
    008F4 E10E      LDI	R16,0x1E
    008F5 E011      LDI	R17,1
    008F6 D920      RCALL	_uart1_send_string
(1210) 						 PARA2=uart0_instr[2];
    008F7 9140 01FF LDS	R20,uart0_instr+2
(1211) 						 PARA3=uart0_instr[3];
    008F9 9160 0200 LDS	R22,uart0_instr+3
(1212) 						 //delay(50);
(1213) 						 //uart0_send_string("ratio changed");
(1214) 				 	 }
(1215) 					 
(1216) 					 if(array_cmp(uart0_instr,"2301")==0)//调试模式・设置手指0速度1(两指相同)夹紧第一阶段
    008FB E827      LDI	R18,0x87
    008FC E031      LDI	R19,1
    008FD EF0D      LDI	R16,0xFD
    008FE E011      LDI	R17,1
    008FF D942      RCALL	_array_cmp
    00900 0158      MOVW	R10,R16
    00901 3000      CPI	R16,0
    00902 0701      CPC	R16,R17
    00903 F419      BNE	0x0907
(1217) 				 	 {
(1218) 					     command_data_save_finger_0_ratio_1(PARA2,PARA3);
    00904 2F26      MOV	R18,R22
    00905 2F04      MOV	R16,R20
    00906 DA60      RCALL	_command_data_save_finger_0_ratio_1
(1219) 						 //delay(50);
(1220) 						 //uart0_send_string(" Finger-0 Ratio-1 Set Successfully! ");
(1221) 					 }
(1222) 					 
(1223) 					 if(array_cmp(uart0_instr,"2302")==0)//调试模式・设置手指0速度2(两指相同)夹紧第二阶段
    00907 E822      LDI	R18,0x82
    00908 E031      LDI	R19,1
    00909 EF0D      LDI	R16,0xFD
    0090A E011      LDI	R17,1
    0090B D936      RCALL	_array_cmp
    0090C 0158      MOVW	R10,R16
    0090D 3000      CPI	R16,0
    0090E 0701      CPC	R16,R17
    0090F F419      BNE	0x0913
(1224) 				 	 {
(1225) 					     command_data_save_finger_0_ratio_2(PARA2,PARA3);
    00910 2F26      MOV	R18,R22
    00911 2F04      MOV	R16,R20
    00912 DA6B      RCALL	_command_data_save_finger_0_ratio_2
(1226) 						 //delay(50);
(1227) 						 //uart0_send_string(" Finger-0 Ratio-2 Set Successfully! ");
(1228) 					 }
(1229) 					 
(1230) 					 if(array_cmp(uart0_instr,"2303")==0)//调试模式・设置手指0速度3(两指相同)松开阶段
    00913 E72D      LDI	R18,0x7D
    00914 E031      LDI	R19,1
    00915 EF0D      LDI	R16,0xFD
    00916 E011      LDI	R17,1
    00917 D92A      RCALL	_array_cmp
    00918 0158      MOVW	R10,R16
    00919 3000      CPI	R16,0
    0091A 0701      CPC	R16,R17
    0091B F419      BNE	0x091F
(1231) 				 	 {
(1232) 					     command_data_save_finger_0_ratio_3(PARA2,PARA3);
    0091C 2F26      MOV	R18,R22
    0091D 2F04      MOV	R16,R20
    0091E DA76      RCALL	_command_data_save_finger_0_ratio_3
(1233) 						 //delay(50);
(1234) 						 //uart0_send_string(" Finger-0 Ratio-3 Set Successfully! ");
(1235) 					 }
(1236) 					 
(1237) 					 if(array_cmp(uart0_instr,"2311")==0)//调试模式・设置手指1速度1(两指相同)夹紧第一阶段
    0091F E728      LDI	R18,0x78
    00920 E031      LDI	R19,1
    00921 EF0D      LDI	R16,0xFD
    00922 E011      LDI	R17,1
    00923 D91E      RCALL	_array_cmp
    00924 0158      MOVW	R10,R16
    00925 3000      CPI	R16,0
    00926 0701      CPC	R16,R17
    00927 F419      BNE	0x092B
(1238) 				 	 {
(1239) 					     command_data_save_finger_1_ratio_1(PARA2,PARA3);
    00928 2F26      MOV	R18,R22
    00929 2F04      MOV	R16,R20
    0092A DAC6      RCALL	_command_data_save_finger_1_ratio_1
(1240) 						 //delay(50);
(1241) 						 //uart0_send_string(" Finger-1 Ratio-1 Set Successfully! ");
(1242) 					 }
(1243) 					 
(1244) 					 if(array_cmp(uart0_instr,"2312")==0)//调试模式・设置手指1速度2(两指相同)夹紧第二阶段
    0092B E723      LDI	R18,0x73
    0092C E031      LDI	R19,1
    0092D EF0D      LDI	R16,0xFD
    0092E E011      LDI	R17,1
    0092F D912      RCALL	_array_cmp
    00930 0158      MOVW	R10,R16
    00931 3000      CPI	R16,0
    00932 0701      CPC	R16,R17
    00933 F419      BNE	0x0937
(1245) 				 	 {
(1246) 					     command_data_save_finger_1_ratio_2(PARA2,PARA3);
    00934 2F26      MOV	R18,R22
    00935 2F04      MOV	R16,R20
    00936 DAD1      RCALL	_command_data_save_finger_1_ratio_2
(1247) 						 //delay(50);
(1248) 						 //uart0_send_string(" Finger-1 Ratio-2 Set Successfully! ");
(1249) 					 }
(1250) 					 
(1251) 					 if(array_cmp(uart0_instr,"2313")==0)//调试模式・设置手指1速度3(两指相同)松开阶段
    00937 E62E      LDI	R18,0x6E
    00938 E031      LDI	R19,1
    00939 EF0D      LDI	R16,0xFD
    0093A E011      LDI	R17,1
    0093B D906      RCALL	_array_cmp
    0093C 0158      MOVW	R10,R16
    0093D 3000      CPI	R16,0
    0093E 0701      CPC	R16,R17
    0093F F419      BNE	0x0943
(1252) 				 	 {
(1253) 					     command_data_save_finger_1_ratio_3(PARA2,PARA3);
    00940 2F26      MOV	R18,R22
    00941 2F04      MOV	R16,R20
    00942 DADC      RCALL	_command_data_save_finger_1_ratio_3
(1254) 						 //delay(50);
(1255) 						 //uart0_send_string(" Finger-1 Ratio-3 Set Successfully! ");
(1256) 					 }
(1257) 					 
(1258) 					 if(array_cmp(Type(uart0_instr),"24")==0)//调试模式・设置夹紧力阈值
    00943 EF0D      LDI	R16,0xFD
    00944 E011      LDI	R17,1
    00945 D927      RCALL	_Type
    00946 E62B      LDI	R18,0x6B
    00947 E031      LDI	R19,1
    00948 D8F9      RCALL	_array_cmp
    00949 0158      MOVW	R10,R16
    0094A 3000      CPI	R16,0
    0094B 0701      CPC	R16,R17
    0094C F439      BNE	0x0954
(1259) 				 	 {
(1260) 					     force_judge=uart0_instr[2];
    0094D 9020 01FF LDS	R2,uart0_instr+2
    0094F 9220 01FB STS	force_judge,R2
(1261) 						 command_data_save_force_high8(force_judge);
    00951 2D02      MOV	R16,R2
    00952 2711      CLR	R17
    00953 D998      RCALL	_command_data_save_force_high8
(1262) 						 //delay(50);
(1263) 						 //uart0_send_string(" Force Set Successfully! ");
(1264) 					 }
(1265) 					 
(1266) 					 
(1267) 					 if(array_cmp(uart0_instr,"2500")==0)//调试模式・读取EEPROM中存储的RATIO和力阈值
    00954 E626      LDI	R18,0x66
    00955 E031      LDI	R19,1
    00956 EF0D      LDI	R16,0xFD
    00957 E011      LDI	R17,1
    00958 D8E9      RCALL	_array_cmp
    00959 0158      MOVW	R10,R16
    0095A 3000      CPI	R16,0
    0095B 0701      CPC	R16,R17
    0095C F009      BEQ	0x095E
    0095D C057      RJMP	0x09B5
(1268) 				 	 {
(1269) 						 //更新ratio变量值、力阈值和消息数组的值
(1270) 						 
(1271) 						 //获取EEPROM中存储的RATIO值
(1272)     					 command_data_read_finger_0_ratio_1(&com_finger0_ratio_1_PARA2,&com_finger0_ratio_1_PARA3);
    0095E 019E      MOVW	R18,R28
    0095F 5D2D      SUBI	R18,0xDD
    00960 4F3F      SBCI	R19,0xFF
    00961 018E      MOVW	R16,R28
    00962 5D0E      SUBI	R16,0xDE
    00963 4F1F      SBCI	R17,0xFF
    00964 DA47      RCALL	_command_data_read_finger_0_ratio_1
(1273) 						 command_data_read_finger_0_ratio_2(&com_finger0_ratio_2_PARA2,&com_finger0_ratio_2_PARA3);
    00965 019E      MOVW	R18,R28
    00966 5D25      SUBI	R18,0xD5
    00967 4F3F      SBCI	R19,0xFF
    00968 018E      MOVW	R16,R28
    00969 5D06      SUBI	R16,0xD6
    0096A 4F1F      SBCI	R17,0xFF
    0096B DA57      RCALL	_command_data_read_finger_0_ratio_2
(1274) 						 command_data_read_finger_0_ratio_3(&com_finger0_ratio_3_PARA2,&com_finger0_ratio_3_PARA3);
    0096C 019E      MOVW	R18,R28
    0096D 5D2B      SUBI	R18,0xDB
    0096E 4F3F      SBCI	R19,0xFF
    0096F 018E      MOVW	R16,R28
    00970 5D0C      SUBI	R16,0xDC
    00971 4F1F      SBCI	R17,0xFF
    00972 DA67      RCALL	_command_data_read_finger_0_ratio_3
(1275) 						 command_data_read_finger_1_ratio_1(&com_finger1_ratio_1_PARA2,&com_finger1_ratio_1_PARA3);
    00973 019E      MOVW	R18,R28
    00974 5D29      SUBI	R18,0xD9
    00975 4F3F      SBCI	R19,0xFF
    00976 018E      MOVW	R16,R28
    00977 5D0A      SUBI	R16,0xDA
    00978 4F1F      SBCI	R17,0xFF
    00979 DABC      RCALL	_command_data_read_finger_1_ratio_1
(1276) 						 command_data_read_finger_1_ratio_2(&com_finger1_ratio_2_PARA2,&com_finger1_ratio_2_PARA3);
    0097A 019E      MOVW	R18,R28
    0097B 5D23      SUBI	R18,0xD3
    0097C 4F3F      SBCI	R19,0xFF
    0097D 018E      MOVW	R16,R28
    0097E 5D04      SUBI	R16,0xD4
    0097F 4F1F      SBCI	R17,0xFF
    00980 DACC      RCALL	_command_data_read_finger_1_ratio_2
(1277) 						 command_data_read_finger_1_ratio_3(&com_finger1_ratio_3_PARA2,&com_finger1_ratio_3_PARA3);
    00981 019E      MOVW	R18,R28
    00982 5D27      SUBI	R18,0xD7
    00983 4F3F      SBCI	R19,0xFF
    00984 018E      MOVW	R16,R28
    00985 5D08      SUBI	R16,0xD8
    00986 4F1F      SBCI	R17,0xFF
    00987 DADC      RCALL	_command_data_read_finger_1_ratio_3
(1278) 	
(1279) 						 msg_eeprom_array[0]='z';
    00988 E78A      LDI	R24,0x7A
    00989 8788      STD	Y+8,R24
(1280) 						 msg_eeprom_array[1]='z';
    0098A 8789      STD	Y+9,R24
(1281) 						 msg_eeprom_array[2]='3';
    0098B E383      LDI	R24,0x33
    0098C 878A      STD	Y+10,R24
(1282) 						 msg_eeprom_array[3]='3';
    0098D 878B      STD	Y+11,R24
(1283) 						 msg_eeprom_array[4]=com_finger0_ratio_1_PARA2;
    0098E A02A      LDD	R2,Y+34
    0098F 862C      STD	Y+12,R2
(1284) 						 msg_eeprom_array[5]=com_finger0_ratio_1_PARA3;
    00990 A02B      LDD	R2,Y+35
    00991 862D      STD	Y+13,R2
(1285) 						 msg_eeprom_array[6]=com_finger0_ratio_2_PARA2;
    00992 A42A      LDD	R2,Y+42
    00993 862E      STD	Y+14,R2
(1286) 						 msg_eeprom_array[7]=com_finger0_ratio_2_PARA3;
    00994 A42B      LDD	R2,Y+43
    00995 862F      STD	Y+15,R2
(1287) 						 msg_eeprom_array[8]=com_finger0_ratio_3_PARA2;
    00996 A02C      LDD	R2,Y+36
    00997 8A28      STD	Y+16,R2
(1288) 						 msg_eeprom_array[9]=com_finger0_ratio_3_PARA3;
    00998 A02D      LDD	R2,Y+37
    00999 8A29      STD	Y+17,R2
(1289) 						 msg_eeprom_array[10]=com_finger1_ratio_1_PARA2;
    0099A A02E      LDD	R2,Y+38
    0099B 8A2A      STD	Y+18,R2
(1290) 						 msg_eeprom_array[11]=com_finger1_ratio_1_PARA3;
    0099C A02F      LDD	R2,Y+39
    0099D 8A2B      STD	Y+19,R2
(1291) 						 msg_eeprom_array[12]=com_finger1_ratio_2_PARA2;
    0099E A42C      LDD	R2,Y+44
    0099F 8A2C      STD	Y+20,R2
(1292) 						 msg_eeprom_array[13]=com_finger1_ratio_2_PARA3;
    009A0 A42D      LDD	R2,Y+45
    009A1 8A2D      STD	Y+21,R2
(1293) 						 msg_eeprom_array[14]=com_finger1_ratio_3_PARA2;
    009A2 A428      LDD	R2,Y+40
    009A3 8A2E      STD	Y+22,R2
(1294) 						 msg_eeprom_array[15]=com_finger1_ratio_3_PARA3;
    009A4 A429      LDD	R2,Y+41
    009A5 8A2F      STD	Y+23,R2
(1295) 	
(1296) 						 //获取EEPROM中存储的夹紧力阈值有效值高八位
(1297) 						 command_data_read_force_high8(&force_judge);
    009A6 EF0B      LDI	R16,0xFB
    009A7 E011      LDI	R17,1
    009A8 D950      RCALL	_command_data_read_force_high8
(1298) 						 msg_eeprom_array[16]=force_judge;
    009A9 9020 01FB LDS	R2,force_judge
    009AB 8E28      STD	Y+24,R2
(1299) 						 
(1300) 						 delay(50);
    009AC E302      LDI	R16,0x32
    009AD E010      LDI	R17,0
    009AE 940E 00E3 CALL	_delay
(1301) 						 uart0_send_string_with_num(msg_eeprom_array,17);//上传EEPROM中存储的数值
    009B0 E121      LDI	R18,0x11
    009B1 018E      MOVW	R16,R28
    009B2 5F08      SUBI	R16,0xF8
    009B3 4F1F      SBCI	R17,0xFF
    009B4 D808      RCALL	_uart0_send_string_with_num
(1302) 	
(1303) 					 }
(1304) 					 
(1305) 				     break;
(1306) 			     }
(1307) 			 
(1308) 		         default:break;
(1309) 			 }
(1310) 			 
(1311) 			 if(array_cmp(uart0_instr,"3100")==0)//恢复触碰报警 ext interrupt 0 
    009B5 E621      LDI	R18,0x61
    009B6 E031      LDI	R19,1
    009B7 EF0D      LDI	R16,0xFD
    009B8 E011      LDI	R17,1
    009B9 D888      RCALL	_array_cmp
    009BA 0158      MOVW	R10,R16
    009BB 3000      CPI	R16,0
    009BC 0701      CPC	R16,R17
    009BD F419      BNE	0x09C1
(1312) 			 {
(1313) 			     ext_collision_alert_allow_int0=1;//上侧
    009BE E081      LDI	R24,1
    009BF 9380 012A STS	ext_collision_alert_allow_int0,R24
(1314) 			 }
(1315) 			 
(1316) 			 if(array_cmp(uart0_instr,"3200")==0)//恢复触碰报警 ext interrupt 1 
    009C1 E52C      LDI	R18,0x5C
    009C2 E031      LDI	R19,1
    009C3 EF0D      LDI	R16,0xFD
    009C4 E011      LDI	R17,1
    009C5 D87C      RCALL	_array_cmp
    009C6 0158      MOVW	R10,R16
    009C7 3000      CPI	R16,0
    009C8 0701      CPC	R16,R17
    009C9 F419      BNE	0x09CD
(1317) 			 {
(1318) 			     ext_collision_alert_allow_int1=1;//下侧
    009CA E081      LDI	R24,1
    009CB 9380 012B STS	ext_collision_alert_allow_int1,R24
(1319) 			 }
(1320) 			 
(1321) 			 if(array_cmp(uart0_instr,"3300")==0)//恢复触碰报警 ext interrupt 4 
    009CD E527      LDI	R18,0x57
    009CE E031      LDI	R19,1
    009CF EF0D      LDI	R16,0xFD
    009D0 E011      LDI	R17,1
    009D1 D870      RCALL	_array_cmp
    009D2 0158      MOVW	R10,R16
    009D3 3000      CPI	R16,0
    009D4 0701      CPC	R16,R17
    009D5 F419      BNE	0x09D9
(1322) 			 {
(1323) 			     ext_collision_alert_allow_int4=1;//指尖
    009D6 E081      LDI	R24,1
    009D7 9380 012C STS	ext_collision_alert_allow_int4,R24
(1324) 			 }
(1325) 			 
(1326) 			 if(array_cmp(uart0_instr,"3400")==0)//读取报警允许变量的状态
    009D9 E522      LDI	R18,0x52
    009DA E031      LDI	R19,1
    009DB EF0D      LDI	R16,0xFD
    009DC E011      LDI	R17,1
    009DD D864      RCALL	_array_cmp
    009DE 0158      MOVW	R10,R16
    009DF 3000      CPI	R16,0
    009E0 0701      CPC	R16,R17
    009E1 F479      BNE	0x09F1
(1327) 			 {
(1328) 			     msg_interrupt_array[4]=ext_collision_alert_allow_int0;
    009E2 9020 012A LDS	R2,ext_collision_alert_allow_int0
    009E4 822D      STD	Y+5,R2
(1329) 				 msg_interrupt_array[5]=ext_collision_alert_allow_int1;
    009E5 9020 012B LDS	R2,ext_collision_alert_allow_int1
    009E7 822E      STD	Y+6,R2
(1330) 				 msg_interrupt_array[6]=ext_collision_alert_allow_int4;
    009E8 9020 012C LDS	R2,ext_collision_alert_allow_int4
    009EA 822F      STD	Y+7,R2
(1331) 				 uart0_send_string_with_num(msg_interrupt_array,7);
    009EB E027      LDI	R18,7
    009EC 018E      MOVW	R16,R28
    009ED 5F0F      SUBI	R16,0xFF
    009EE 4F1F      SBCI	R17,0xFF
    009EF 940E 01BD CALL	_uart0_send_string_with_num
(1332) 			 }
(1333) 			 
(1334) 			 /*末尾应完成命令执行后的还原工作A-D*/
(1335) 			 uart0_instr_flag=0; //A.命令接收标志位置0
    009F1 2422      CLR	R2
    009F2 9220 0129 STS	uart0_instr_flag,R2
(1336) 			 uart0_r_instr_chk=0;//B.命令构造字符数计数置0
    009F4 9220 0128 STS	uart0_r_instr_chk,R2
(1337) 			 for(i=0;i<12;i++)//C.命令清除
    009F6 24AA      CLR	R10
    009F7 C009      RJMP	0x0A01
(1338) 			 {
(1339) 		         uart0_instr[i]=0;
    009F8 EF8D      LDI	R24,0xFD
    009F9 E091      LDI	R25,1
    009FA 2DEA      MOV	R30,R10
    009FB 27FF      CLR	R31
    009FC 0FE8      ADD	R30,R24
    009FD 1FF9      ADC	R31,R25
    009FE 2422      CLR	R2
    009FF 8220      ST	Z,R2
    00A00 94A3      INC	R10
    00A01 2D8A      MOV	R24,R10
    00A02 308C      CPI	R24,0xC
    00A03 F3A0      BCS	0x09F8
(1340) 			 }
(1341) 			 UCSR0B|=BIT(RXCIE0);//D.恢复UART0的接收中断			
    00A04 9A57      SBI	0x0A,7
(1342) 	     }
(1343) 		 
(1344) 
(1345) 		/*
(1346) 		    【偏向撞击保护的编程】
(1347) 			（1）一旦手指碰撞到限位开关产生低电平，哪怕是抖动、不稳定的低电平，
(1348) 			也要禁止手指继续向碰撞位置移动，此时不需要延迟防抖的处理；
(1349) 			（2）只有当手指真正完全地离开了碰撞地点，限位开关IO成为稳定的高电平，
(1350) 			才允许手指再次向碰撞的方向移动。
(1351) 		*/
(1352) 		
(1353) 		if(!(PINE & BIT(5)))//检测手指0是否复位
    00A05 990D      SBIC	0x01,5
    00A06 C027      RJMP	0x0A2E
(1354) 		{
(1355) 			if(stop_allow_cage_0)
    00A07 A40E      LDD	R0,Y+46
    00A08 2000      TST	R0
    00A09 F189      BEQ	0x0A3B
(1356) 			{
(1357) 			    release_allow_motor_0=0;//禁止1号手指向端部靠近
    00A0A 2400      CLR	R0
    00A0B AA0B      STD	Y+51,R0
(1358) 				hold_allow_motor_0=1;//允许1号手指向中间靠近
    00A0C 2400      CLR	R0
    00A0D 9403      INC	R0
    00A0E AA09      STD	Y+49,R0
(1359) 				TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00A0F B787      IN	R24,0x37
    00A10 7F8B      ANDI	R24,0xFB
    00A11 BF87      OUT	0x37,R24
(1360) 				delay(50);
    00A12 E302      LDI	R16,0x32
    00A13 E010      LDI	R17,0
    00A14 940E 00E3 CALL	_delay
(1361) 				uart1_send_string((uchar*)no0stop,9);
    00A16 E029      LDI	R18,0x9
    00A17 E00C      LDI	R16,0xC
    00A18 E011      LDI	R17,1
    00A19 940E 0217 CALL	_uart1_send_string
(1362) 				delay(50);
    00A1B E302      LDI	R16,0x32
    00A1C E010      LDI	R17,0
    00A1D 940E 00E3 CALL	_delay
(1363) 				uart0_send_string("zz30");
    00A1F E40D      LDI	R16,0x4D
    00A20 E011      LDI	R17,1
    00A21 940E 01A9 CALL	_uart0_send_string
(1364) 				delay(50);
    00A23 E302      LDI	R16,0x32
    00A24 E010      LDI	R17,0
    00A25 940E 00E3 CALL	_delay
(1365) 				uart0_send_string("zz30");
    00A27 E40D      LDI	R16,0x4D
    00A28 E011      LDI	R17,1
    00A29 940E 01A9 CALL	_uart0_send_string
(1366) 				stop_allow_cage_0=0;
    00A2B 2400      CLR	R0
    00A2C A60E      STD	Y+46,R0
(1367) 			}
(1368) 		}
    00A2D C00D      RJMP	0x0A3B
(1369) 		else
(1370) 		{
(1371) 		    if(!stop_allow_cage_0)
    00A2E A40E      LDD	R0,Y+46
    00A2F 2000      TST	R0
    00A30 F451      BNE	0x0A3B
(1372) 			{
(1373) 			    delay(500);
    00A31 EF04      LDI	R16,0xF4
    00A32 E011      LDI	R17,1
    00A33 940E 00E3 CALL	_delay
(1374) 			    if(PINE & BIT(5))
    00A35 9B0D      SBIS	0x01,5
    00A36 C004      RJMP	0x0A3B
(1375) 				{
(1376) 				    release_allow_motor_0=1;//允许1号手指向端部靠近
    00A37 2400      CLR	R0
    00A38 9403      INC	R0
    00A39 AA0B      STD	Y+51,R0
(1377) 					stop_allow_cage_0=1;
    00A3A A60E      STD	Y+46,R0
(1378) 				}
(1379) 			}
(1380) 		}
(1381) 		
(1382) 		if(!(PINE & BIT(6)))//检测手指1是否复位
    00A3B 990E      SBIC	0x01,6
    00A3C C027      RJMP	0x0A64
(1383) 		{
(1384) 			if(stop_allow_cage_1)
    00A3D A40F      LDD	R0,Y+47
    00A3E 2000      TST	R0
    00A3F F189      BEQ	0x0A71
(1385) 			{
(1386) 			    release_allow_motor_1=0;//禁止1号手指向端部靠近
    00A40 2400      CLR	R0
    00A41 AA0C      STD	Y+52,R0
(1387) 				hold_allow_motor_1=1;//允许1号手指向中间靠近
    00A42 2400      CLR	R0
    00A43 9403      INC	R0
    00A44 AA0A      STD	Y+50,R0
(1388) 				TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00A45 B787      IN	R24,0x37
    00A46 7F8B      ANDI	R24,0xFB
    00A47 BF87      OUT	0x37,R24
(1389) 				delay(50);
    00A48 E302      LDI	R16,0x32
    00A49 E010      LDI	R17,0
    00A4A 940E 00E3 CALL	_delay
(1390) 				uart1_send_string((uchar*)no1stop,9);
    00A4C E029      LDI	R18,0x9
    00A4D E10E      LDI	R16,0x1E
    00A4E E011      LDI	R17,1
    00A4F 940E 0217 CALL	_uart1_send_string
(1391) 				delay(50);
    00A51 E302      LDI	R16,0x32
    00A52 E010      LDI	R17,0
    00A53 940E 00E3 CALL	_delay
(1392) 				uart0_send_string("zz31");
    00A55 E408      LDI	R16,0x48
    00A56 E011      LDI	R17,1
    00A57 940E 01A9 CALL	_uart0_send_string
(1393) 				delay(50);
    00A59 E302      LDI	R16,0x32
    00A5A E010      LDI	R17,0
    00A5B 940E 00E3 CALL	_delay
(1394) 				uart0_send_string("zz31");
    00A5D E408      LDI	R16,0x48
    00A5E E011      LDI	R17,1
    00A5F 940E 01A9 CALL	_uart0_send_string
(1395) 				stop_allow_cage_1=0;
    00A61 2400      CLR	R0
    00A62 A60F      STD	Y+47,R0
(1396) 			}
(1397) 		}
    00A63 C00D      RJMP	0x0A71
(1398) 		else
(1399) 		{
(1400) 			if(!stop_allow_cage_1)
    00A64 A40F      LDD	R0,Y+47
    00A65 2000      TST	R0
    00A66 F451      BNE	0x0A71
(1401) 			{
(1402) 			    delay(500);
    00A67 EF04      LDI	R16,0xF4
    00A68 E011      LDI	R17,1
    00A69 940E 00E3 CALL	_delay
(1403) 			    if(PINE & BIT(6))
    00A6B 9B0E      SBIS	0x01,6
    00A6C C004      RJMP	0x0A71
(1404) 				{
(1405) 				    release_allow_motor_1=1;//允许1号手指向端部靠近
    00A6D 2400      CLR	R0
    00A6E 9403      INC	R0
    00A6F AA0C      STD	Y+52,R0
(1406) 					stop_allow_cage_1=1;
    00A70 A60F      STD	Y+47,R0
(1407) 				}
(1408) 			}
(1409) 		}
(1410) 
(1411) 		if(!(PINE & BIT(7)))//检测是否空夹
    00A71 990F      SBIC	0x01,7
    00A72 C02E      RJMP	0x0AA1
(1412) 		{
(1413) 			if(stop_allow_empty)
    00A73 A808      LDD	R0,Y+48
    00A74 2000      TST	R0
    00A75 F1C9      BEQ	0x0AAF
(1414) 			{
(1415) 			    hold_allow_motor_0=0;//禁止0号手指向端部靠近
    00A76 2400      CLR	R0
    00A77 AA09      STD	Y+49,R0
(1416) 				hold_allow_motor_1=0;//禁止1号手指向端部靠近
    00A78 AA0A      STD	Y+50,R0
(1417) 				TIMSK&=(~BIT(2));//屏蔽定时计数1中断，停止向上返回夹持力值
    00A79 B787      IN	R24,0x37
    00A7A 7F8B      ANDI	R24,0xFB
    00A7B BF87      OUT	0x37,R24
(1418) 				delay(50);
    00A7C E302      LDI	R16,0x32
    00A7D E010      LDI	R17,0
    00A7E 940E 00E3 CALL	_delay
(1419) 				uart1_send_string((uchar*)no1stop,9);
    00A80 E029      LDI	R18,0x9
    00A81 E10E      LDI	R16,0x1E
    00A82 E011      LDI	R17,1
    00A83 940E 0217 CALL	_uart1_send_string
(1420) 				delay(50);
    00A85 E302      LDI	R16,0x32
    00A86 E010      LDI	R17,0
    00A87 940E 00E3 CALL	_delay
(1421) 				uart1_send_string((uchar*)no0stop,9);
    00A89 E029      LDI	R18,0x9
    00A8A E00C      LDI	R16,0xC
    00A8B E011      LDI	R17,1
    00A8C 940E 0217 CALL	_uart1_send_string
(1422) 				delay(50);
    00A8E E302      LDI	R16,0x32
    00A8F E010      LDI	R17,0
    00A90 940E 00E3 CALL	_delay
(1423) 				uart0_send_string("zz32");
    00A92 E403      LDI	R16,0x43
    00A93 E011      LDI	R17,1
    00A94 940E 01A9 CALL	_uart0_send_string
(1424) 				delay(50);
    00A96 E302      LDI	R16,0x32
    00A97 E010      LDI	R17,0
    00A98 940E 00E3 CALL	_delay
(1425) 				uart0_send_string("zz32");
    00A9A E403      LDI	R16,0x43
    00A9B E011      LDI	R17,1
    00A9C 940E 01A9 CALL	_uart0_send_string
(1426) 				stop_allow_empty=0;
    00A9E 2400      CLR	R0
    00A9F AA08      STD	Y+48,R0
(1427) 			}
(1428) 		}
    00AA0 C00E      RJMP	0x0AAF
(1429) 		else
(1430) 		{
(1431) 			if(!stop_allow_empty)
    00AA1 A808      LDD	R0,Y+48
    00AA2 2000      TST	R0
    00AA3 F459      BNE	0x0AAF
(1432) 			{
(1433) 			    delay(500);
    00AA4 EF04      LDI	R16,0xF4
    00AA5 E011      LDI	R17,1
    00AA6 940E 00E3 CALL	_delay
(1434) 			    if(PINE & BIT(7))
    00AA8 9B0F      SBIS	0x01,7
    00AA9 C005      RJMP	0x0AAF
(1435) 				{
(1436) 				    hold_allow_motor_0=1;//允许0号手指向中间靠近
    00AAA 2400      CLR	R0
    00AAB 9403      INC	R0
    00AAC AA09      STD	Y+49,R0
(1437) 					hold_allow_motor_1=1;//允许1号手指向中间靠近
    00AAD AA0A      STD	Y+50,R0
(1438) 					stop_allow_empty=1;
FILE: <library>
    00AAE AA08      STD	Y+48,R0
    00AAF CB12      RJMP	0x05C2
    00AB0 96E6      ADIW	R28,0x36
    00AB1 9508      RET
_strlen:
    00AB2 2FE0      MOV	R30,R16
    00AB3 2FF1      MOV	R31,R17
    00AB4 27AA      CLR	R26
    00AB5 27BB      CLR	R27
    00AB6 9001      LD	R0,Z+
    00AB7 2000      TST	R0
    00AB8 F011      BEQ	0x0ABB
    00AB9 9611      ADIW	R26,1
    00ABA CFFB      RJMP	0x0AB6
    00ABB 2F0A      MOV	R16,R26
    00ABC 2F1B      MOV	R17,R27
    00ABD 9508      RET
push_arg4:
    00ABE 933A      ST	-Y,R19
    00ABF 932A      ST	-Y,R18
push_arg2:
    00AC0 931A      ST	-Y,R17
    00AC1 930A      ST	-Y,R16
    00AC2 9508      RET
div32u:
    00AC3 94E8      BCLR	6
    00AC4 C001      RJMP	0x0AC6
mod32u:
    00AC5 9468      BSET	6
    00AC6 D030      RCALL	long_div_prolog
    00AC7 24CC      CLR	R12
    00AC8 C009      RJMP	0x0AD2
div32s:
    00AC9 94E8      BCLR	6
    00ACA C001      RJMP	0x0ACC
mod32s:
    00ACB 9468      BSET	6
    00ACC D02A      RCALL	long_div_prolog
    00ACD FD37      SBRC	R19,7
    00ACE 940E 0B57 CALL	neg32
    00AD0 FDB7      SBRC	R27,7
    00AD1 D052      RCALL	neg_R24_R27
    00AD2 2477      CLR	R7
    00AD3 2488      CLR	R8
    00AD4 2499      CLR	R9
    00AD5 24AA      CLR	R10
    00AD6 24BB      CLR	R11
    00AD7 D042      RCALL	tst_R16_R19
    00AD8 F0C1      BEQ	0x0AF1
    00AD9 D045      RCALL	tst_R24_R27
    00ADA F0B1      BEQ	0x0AF1
    00ADB E2E8      LDI	R30,0x28
    00ADC 0F00      LSL	R16
    00ADD 1F11      ROL	R17
    00ADE 1F22      ROL	R18
    00ADF 1F33      ROL	R19
    00AE0 1C77      ROL	R7
    00AE1 1C88      ROL	R8
    00AE2 1C99      ROL	R9
    00AE3 1CAA      ROL	R10
    00AE4 1CBB      ROL	R11
    00AE5 1688      CP	R8,R24
    00AE6 0699      CPC	R9,R25
    00AE7 06AA      CPC	R10,R26
    00AE8 06BB      CPC	R11,R27
    00AE9 F028      BCS	0x0AEF
    00AEA 1A88      SUB	R8,R24
    00AEB 0A99      SBC	R9,R25
    00AEC 0AAA      SBC	R10,R26
    00AED 0ABB      SBC	R11,R27
    00AEE 9503      INC	R16
    00AEF 95EA      DEC	R30
    00AF0 F759      BNE	0x0ADC
    00AF1 F426      BRTC	0x0AF6
    00AF2 2D08      MOV	R16,R8
    00AF3 2D19      MOV	R17,R9
    00AF4 2D2A      MOV	R18,R10
    00AF5 2D3B      MOV	R19,R11
    00AF6 C013      RJMP	long_div_epilog
long_div_prolog:
    00AF7 927A      ST	-Y,R7
    00AF8 928A      ST	-Y,R8
    00AF9 929A      ST	-Y,R9
    00AFA 92AA      ST	-Y,R10
    00AFB 92BA      ST	-Y,R11
    00AFC 92CA      ST	-Y,R12
    00AFD 93EA      ST	-Y,R30
    00AFE 938A      ST	-Y,R24
    00AFF 939A      ST	-Y,R25
    00B00 93AA      ST	-Y,R26
    00B01 93BA      ST	-Y,R27
    00B02 858B      LDD	R24,Y+11
    00B03 859C      LDD	R25,Y+12
    00B04 85AD      LDD	R26,Y+13
    00B05 85BE      LDD	R27,Y+14
    00B06 2EC3      MOV	R12,R19
    00B07 F00E      BRTS	0x0B09
    00B08 26CB      EOR	R12,R27
    00B09 9508      RET
long_div_epilog:
    00B0A FCC7      SBRC	R12,7
    00B0B 940E 0B57 CALL	neg32
    00B0D 91B9      LD	R27,Y+
    00B0E 91A9      LD	R26,Y+
    00B0F 9199      LD	R25,Y+
    00B10 9189      LD	R24,Y+
    00B11 91E9      LD	R30,Y+
    00B12 90C9      LD	R12,Y+
    00B13 90B9      LD	R11,Y+
    00B14 90A9      LD	R10,Y+
    00B15 9099      LD	R9,Y+
    00B16 9089      LD	R8,Y+
    00B17 9079      LD	R7,Y+
    00B18 9624      ADIW	R28,4
    00B19 9508      RET
tst_R16_R19:
    00B1A 2FE0      MOV	R30,R16
    00B1B 2BE1      OR	R30,R17
    00B1C 2BE2      OR	R30,R18
    00B1D 2BE3      OR	R30,R19
    00B1E 9508      RET
tst_R24_R27:
    00B1F 2FE8      MOV	R30,R24
    00B20 2BE9      OR	R30,R25
    00B21 2BEA      OR	R30,R26
    00B22 2BEB      OR	R30,R27
    00B23 9508      RET
neg_R24_R27:
    00B24 9580      COM	R24
    00B25 9590      COM	R25
    00B26 95A0      COM	R26
    00B27 95B0      COM	R27
    00B28 5F8F      SUBI	R24,0xFF
    00B29 4F9F      SBCI	R25,0xFF
    00B2A 4FAF      SBCI	R26,0xFF
    00B2B 4FBF      SBCI	R27,0xFF
    00B2C 9508      RET
pop_xgset00FC:
    00B2D 90A9      LD	R10,Y+
    00B2E 90B9      LD	R11,Y+
    00B2F 90C9      LD	R12,Y+
    00B30 90D9      LD	R13,Y+
    00B31 90E9      LD	R14,Y+
    00B32 90F9      LD	R15,Y+
    00B33 9508      RET
push_xgsetF0FC:
    00B34 937A      ST	-Y,R23
    00B35 936A      ST	-Y,R22
push_xgset30FC:
    00B36 935A      ST	-Y,R21
    00B37 934A      ST	-Y,R20
push_xgset00FC:
    00B38 92FA      ST	-Y,R15
    00B39 92EA      ST	-Y,R14
push_xgset003C:
    00B3A 92DA      ST	-Y,R13
    00B3B 92CA      ST	-Y,R12
    00B3C 92BA      ST	-Y,R11
    00B3D 92AA      ST	-Y,R10
    00B3E 9508      RET
push_xgsetF000:
    00B3F 937A      ST	-Y,R23
    00B40 936A      ST	-Y,R22
    00B41 935A      ST	-Y,R21
    00B42 934A      ST	-Y,R20
    00B43 9508      RET
pop_xgsetF000:
    00B44 9149      LD	R20,Y+
    00B45 9159      LD	R21,Y+
    00B46 9169      LD	R22,Y+
    00B47 9179      LD	R23,Y+
    00B48 9508      RET
push_xgsetF00C:
    00B49 937A      ST	-Y,R23
    00B4A 936A      ST	-Y,R22
    00B4B 935A      ST	-Y,R21
    00B4C 934A      ST	-Y,R20
    00B4D 92BA      ST	-Y,R11
    00B4E 92AA      ST	-Y,R10
    00B4F 9508      RET
pop_xgsetF00C:
    00B50 90A9      LD	R10,Y+
    00B51 90B9      LD	R11,Y+
    00B52 9149      LD	R20,Y+
    00B53 9159      LD	R21,Y+
    00B54 9169      LD	R22,Y+
    00B55 9179      LD	R23,Y+
    00B56 9508      RET
neg32:
    00B57 9500      COM	R16
    00B58 9510      COM	R17
    00B59 9520      COM	R18
    00B5A 9530      COM	R19
    00B5B 5F0F      SUBI	R16,0xFF
    00B5C 4F1F      SBCI	R17,0xFF
    00B5D 4F2F      SBCI	R18,0xFF
    00B5E 4F3F      SBCI	R19,0xFF
    00B5F 9508      RET
asgnblk:
    00B60 93AA      ST	-Y,R26
    00B61 93BA      ST	-Y,R27
    00B62 93EA      ST	-Y,R30
    00B63 93FA      ST	-Y,R31
    00B64 920A      ST	-Y,R0
    00B65 81AF      LDD	R26,Y+7
    00B66 85B8      LDD	R27,Y+8
    00B67 81ED      LDD	R30,Y+5
    00B68 81FE      LDD	R31,Y+6
    00B69 3000      CPI	R16,0
    00B6A 0701      CPC	R16,R17
    00B6B F029      BEQ	0x0B71
    00B6C 9001      LD	R0,Z+
    00B6D 920D      ST	X+,R0
    00B6E 5001      SUBI	R16,1
    00B6F 4010      SBCI	R17,0
    00B70 CFF8      RJMP	0x0B69
    00B71 9009      LD	R0,Y+
    00B72 91F9      LD	R31,Y+
    00B73 91E9      LD	R30,Y+
    00B74 91B9      LD	R27,Y+
    00B75 91A9      LD	R26,Y+
    00B76 9624      ADIW	R28,4
    00B77 9508      RET
